(define (displayln a) (format #t "~a\n" a))
(define (flatten-all tree)
	(if (null? tree)
		'()
		(if (not (pair? tree))
			(list tree)
			(append (flatten-all (car tree)) (flatten-all (cdr tree))))))
(define (add-char c i) (integer->char (+ i (char->integer c))))
(define (alist-replace key val xs)
	(alist-cons key val (alist-delete key xs)))
;;;http://comments.gmane.org/gmane.lisp.scheme.scheme48/2262
(define-syntax defmacro 
  (syntax-rules ()
    ((defmacro name args body ...)
     (define-syntax name 
       (lambda (form rename compare)
	 (apply (lambda args body ...)
		(cdr form)))))))
;;;PG in Arc and On Lisp
(defmacro aif (c x y)
	`(let ((it ,c))
		(if it ,x ,y)))
(define (inv x) (lambda (f) (f x)))
(define (flatten depth lst)
	(define (flatten1 lst)
		(if (null? lst)
			lst
			(let ((x (car lst)))
				((if (or (null? x) (pair? x)) append cons)
				 x
				 (flatten1 (cdr lst))))))
	(if (zero? depth)
		lst
		(flatten (- depth 1) (flatten1 lst))))
(define (make-collector fns)
	(lambda (x) (map (inv x) fns)))
(define (consecutive-pairs xs)
	(if (null? xs)
		'()
		(cons (list (car xs) (cadr xs))
			  (consecutive-pairs (cddr xs)))))
(define (separate xs s)
	(if (or (null? xs) (null? (cdr xs)))
		xs
		(cons (car xs) (cons s (separate (cdr xs) s)))))
;replaced by equivalent srfi-13 (string-join xs s)
;(define (join xs s)
;	(apply string-append (separate xs s)))
(define (replace xs i y)
	(if (zero? i)
		(cons y (cdr xs))
		(cons (car xs) (replace (cdr xs) (- i 1) y))))
(define (split x s)
	((infix-splitter s) x))
(define (format-table lst)
	(define (format-string n)
		(cond ((zero? n) "")
			  ((equal? n 1) "~a")
			  (else (string-append "~a," (format-string (- n 1))))))
	(map (lambda (x)
			(apply format #f (format-string (length x)) x))
		 lst))
(define (display-table lst)
	(map displayln (format-table lst)))

;there is a transpose in the reference implementation of srfi-25
;if you can get scsh to expose it, and learn how to use it
(define (transpose xs)
	(if (or (null? xs) (null? (car xs)))
		'()
		(cons (map car xs) (transpose (map cdr xs)))))
;returns a dimensionless vector if given no args
(define (vector-sum1 vectors)
	(map (lambda (xs) (fold + 0 xs))
		 (transpose vectors)))
;n=dimensions
(define (vector-sum n vectors)
	(fold (lambda (v1 v2) (map + v1 v2))
		  (iota n 0 0)
		  vectors))
(define (pad lst n x)
  (append lst (make-list (- n (length lst)) x)))

;;;; latch
;;;; ,open locks threads thread-fluids

; n > 0
(define (make-latch n)
  (let ((await-lock (make-lock)))
    (obtain-lock await-lock)
    (list n (make-lock) await-lock)))
(define (n-critical fn)
  (lambda (latch)
    (obtain-lock (cadr latch))
    (let ((result (fn latch)))
      (release-lock (cadr latch))
      result)))
(define latch-countdown
  (n-critical
    (lambda (latch)
      (set-car! latch (- (car latch) 1))
      (if (zero? (car latch))
        (release-lock (caddr latch))))))
(define (latch-await latch)
  (obtain-lock (caddr latch))
  (release-lock (caddr latch)))

(define (latch-test)
  (define x (make-latch 2))
  (define (f i latch)
    (lambda ()
      (sleep (* i 1000))
      (latch-countdown latch)))

  (map (lambda (i) (fork-thread (f i x)))
       (iota 2 1 1))
  (display "waiting for threads to complete\n")
  (latch-await x)
  (display "all threads done\n"))

;;;;finally

; ,open handle threads thread-fluids
;(with-handler
;  (lambda (condition f)
;    (format #t "got condition ~a\n" condition)
;    (f))
;  (lambda ()
;    (error "some error")
;    (display "after error")))
(define (finally end-thunk thunk)
  (with-handler (lambda (condition f)
                  (end-thunk)
                  (f))
                (lambda ()
                  (let ((result (thunk)))
                    (end-thunk)
                    result))))
(define (test-finally1)
  (finally (lambda () (display "finally 1\n"))
           (lambda () (display "hallo world"))))
(define (test-finally2)
  (finally (lambda () (display "finally 2\n"))
           (lambda () (error "mistake"))))
(define (test-finally3)
  (define (bg id)
    (fork-thread
      (lambda ()
        (finally
          (lambda () (format #t "~a finally\n" id))
          (lambda ()
            (sleep (* id 200))
            (if (even? id)
              (format #t "~a okay\n" id)
              (error (number->string id))))))))
  (map bg (iota 5 1 1))
  (sleep 2000)
  (display "test-finally 3 finished"))
