cscope 15 $HOME/job/src/SparseLib++/1.7 -c               0000715805
	@include/compcol_double.h

36 #ifndef 
CompCol_Mat_double_H


37 #define 
	#CompCol_Mat_double_H


	)

39 #include 
	~"vecdefs.h
"

40 #include 
VECTOR_H


42 
class
 
	gCompRow_Mat_double
;

43 
class
 
	gCoord_Mat_double
;

45 class 
	cCompCol_Mat_double
 {

47 
	mprivate
:

48 
VECTOR_double
 
val_
;

49 
VECTOR_int
 
	mrowind_
;

50 
VECTOR_int
 
	mcolptr_
;

52 int 
	mbase_
;

53 int 
	mnz_
;

54 int 
	mdim_
[2];

56 
	mpublic
:

57 
CompCol_Mat_double
(void);

58 
CompCol_Mat_double
(const CompCol_Mat_double &
S
);

59 
CompCol_Mat_double
(const 
CompRow_Mat_double
 &
R
);

60 
CompCol_Mat_double
(const 
Coord_Mat_double
 &
CO
);

61 
CompCol_Mat_double
(int 
M
, int 
N
, int 
nz
, double *
val
, int *
r
,

62 int *
c
, int 
base
=0);

63 
CompCol_Mat_double
(int 
M
, int 
N
, int 
nz
, const 
VECTOR_double
 &
val
,

64 const 
VECTOR_int
 &
r
, const VECTOR_int &
c
,

65 int 
base
=0);

66 ~
	$CompCol_Mat_double
() {};

72 double& 
	$val
(int 
i
) { return 
	`val_
(i); 
	}
}

73 int& 
	$row_ind
(int 
i
) { return 
	`rowind_
(i); 
	}
}

74 int& 
	$col_ptr
(int 
i
) { return 
	`colptr_
(i);
	}
}

76 const double& 
	$val
(int 
i
) const { return 
	`val_
(i); 
	}
}

77 const int& 
	$row_ind
(int 
i
) const { return 
	`rowind_
(i); 
	}
}

78 const int& 
	$col_ptr
(int 
i
) const { return 
	`colptr_
(i);
	}
}

80 int 
	$dim
(int 
i
) const {return 
dim_
[i];
	}
};

81 int 
	$size
(int 
i
) const {return 
dim_
[i];
	}
};

82 int 
	$NumNonzeros
() const {return 
nz_
;
	}
};

83 int 
	$base
() const {return 
base_
;
	}
}

89 
	gCompCol_Mat_double
& 
	goperator
=(const 
CompCol_Mat_double
 &
C
);

90 
	gCompCol_Mat_double
& 
newsize
(int 
M
, int 
N
, int 
nz
);

96 double 
	$operator
() (int 
i
, int 
j
) const;

97 double& 
	`set
(int 
i
, int 
j
);

103 
VECTOR_double
 
operator
*(const VECTOR_double &
x
) const;

104 
VECTOR_double
 
	$trans_mult
(const 
VECTOR_double
 &
x
) const;

106 
	}
};

108 
	gstd
::
ostream
& 
operator
 << (
std
::ostream & 
os
, const 
	gCompCol_Mat_double
 & 
	gmat
);

109 void 
readHB
(const char *
c
, 
CompCol_Mat_double
 &
M
);

	@include/comprow_double.h

36 #ifndef 
CompRow_Mat_double_H


37 #define 
	#CompRow_Mat_double_H


	)

40 #include 
	~"vecdefs.h
"

41 #include 
VECTOR_H


43 
class
 
	gCompCol_Mat_double
;

44 
class
 
	gCoord_Mat_double
;

46 class 
	cCompRow_Mat_double
 {

48 
	mprivate
:

49 
VECTOR_double
 
val_
;

50 
VECTOR_int
 
	mrowptr_
;

51 
VECTOR_int
 
	mcolind_
;

53 int 
	mbase_
;

54 int 
	mnz_
;

55 int 
	mdim_
[2];

57 
	mpublic
:

58 
CompRow_Mat_double
(void);

59 
CompRow_Mat_double
(const CompRow_Mat_double &
S
);

60 
CompRow_Mat_double
(const 
CompCol_Mat_double
 &
C
);

61 
CompRow_Mat_double
(const 
Coord_Mat_double
 &
CO
);

62 
CompRow_Mat_double
(int 
M
, int 
N
, int 
nz
, double *
val
, int *
r
,

63 int *
c
, int 
base
=0);

64 
CompRow_Mat_double
(int 
M
, int 
N
, int 
nz
, const 
VECTOR_double
 &
val
,

65 const 
VECTOR_int
 &
r
, const VECTOR_int &
c
,

66 int 
base
=0);

67 ~
	$CompRow_Mat_double
() {};

73 double& 
	$val
(int 
i
) { return 
	`val_
(i); 
	}
}

74 int& 
	$row_ptr
(int 
i
) { return 
	`rowptr_
(i); 
	}
}

75 int& 
	$col_ind
(int 
i
) { return 
	`colind_
(i);
	}
}

77 const double& 
	$val
(int 
i
) const { return 
	`val_
(i); 
	}
}

78 const int& 
	$row_ptr
(int 
i
) const { return 
	`rowptr_
(i); 
	}
}

79 const int& 
	$col_ind
(int 
i
) const { return 
	`colind_
(i);
	}
}

81 int 
	$dim
(int 
i
) const {return 
dim_
[i];
	}
};

82 int 
	$size
(int 
i
) const {return 
dim_
[i];
	}
};

83 int 
	$NumNonzeros
() const {return 
nz_
;
	}
};

84 int 
	$base
() const {return 
base_
;
	}
}

90 
	gCompRow_Mat_double
& 
	goperator
=(const 
CompRow_Mat_double
 &
R
);

91 
	gCompRow_Mat_double
& 
newsize
(int 
M
, int 
N
, int 
nz
);

97 double 
	$operator
() (int 
i
, int 
j
) const;

98 double& 
	`set
(int 
i
, int 
j
);

104 
VECTOR_double
 
operator
*(const VECTOR_double &
x
) const;

105 
VECTOR_double
 
	$trans_mult
(const 
VECTOR_double
 &
x
) const;

107 
	}
};

109 
	gstd
::
ostream
& 
operator
 << (
std
::ostream & 
os
, const 
	gCompRow_Mat_double
 & 
	gmat
);

	@include/coord_double.h

39 #ifndef 
Coord_Mat_double_H


40 #define 
	#Coord_Mat_double_H


	)

42 #include 
	~"vecdefs.h
"

43 #include 
VECTOR_H


45 
class
 
	gCompCol_Mat_double
;

46 
class
 
	gCompRow_Mat_double
;

48 class 
	cCoord_Mat_double
 {

50 
	mprivate
:

51 
VECTOR_double
 
val_
;

52 
VECTOR_int
 
	mrowind_
;

53 
VECTOR_int
 
	mcolind_
;

55 int 
	mbase_
;

56 int 
	mnz_
;

57 int 
	mdim_
[2];

59 
	mpublic
:

60 
Coord_Mat_double
(void);

61 
Coord_Mat_double
(const Coord_Mat_double &
S
);

62 
Coord_Mat_double
(int 
M
, int 
N
, int 
nz
, double *
val
, int *
r
,

63 int *
c
, int 
base
=0);

64 
Coord_Mat_double
(const 
CompCol_Mat_double
 &
C
);

65 
Coord_Mat_double
(const 
CompRow_Mat_double
 &
R
);

66 ~
	$Coord_Mat_double
() {};

72 double& 
	$val
(int 
i
) { return 
	`val_
(i); 
	}
}

73 int& 
	$row_ind
(int 
i
) { return 
	`rowind_
(i); 
	}
}

74 int& 
	$col_ind
(int 
i
) { return 
	`colind_
(i);
	}
}

76 const double& 
	$val
(int 
i
) const { return 
	`val_
(i); 
	}
}

77 const int& 
	$row_ind
(int 
i
) const { return 
	`rowind_
(i); 
	}
}

78 const int& 
	$col_ind
(int 
i
) const { return 
	`colind_
(i);
	}
}

80 int 
	$dim
(int 
i
) const {return 
dim_
[i];
	}
};

81 int 
	$size
(int 
i
) const {return 
dim_
[i];
	}
};

82 int 
	$NumNonzeros
() const {return 
nz_
;
	}
};

83 int 
	$base
() const {return 
base_
;
	}
}

89 
	gCoord_Mat_double
& 
	goperator
=(const 
Coord_Mat_double
 &
C
);

90 
	gCoord_Mat_double
& 
newsize
(int 
M
, int 
N
, int 
nz
);

96 double 
	$operator
() (int 
i
, int 
j
) const;

97 double& 
	`set
(int 
i
, int 
j
);

103 
VECTOR_double
 
operator
*(const VECTOR_double &
x
) const;

104 
VECTOR_double
 
	$trans_mult
(const 
VECTOR_double
 &
x
) const;

107 
	}
};

112 
	gstd
::
ostream
& 
operator
 << (
std
::ostream & 
os
, const 
	gCoord_Mat_double
 & 
	gmat
);

	@include/diagpre_double.h

31 #ifndef 
DIAGPRE_H


32 #define 
	#DIAGPRE_H


	)

34 #include 
	~"vecdefs.h
"

35 #include 
VECTOR_H


37 #include 
	~"comprow_double.h
"

38 #include 
	~"compcol_double.h
"

40 class 
	cDiagPreconditioner_double
 {

42 
	mprivate
:

43 
VECTOR_double
 
diag_
;

45 
	mpublic
:

46 
DiagPreconditioner_double
 (const 
CompCol_Mat_double
 &);

47 
DiagPreconditioner_double
 (const 
CompRow_Mat_double
 &);

48 ~
	$DiagPreconditioner_double
 (void) { };

49 
VECTOR_double
 
	$solve
 (const 
VECTOR_double
 &
x
) const;

50 
VECTOR_double
 
	$trans_solve
 (const 
VECTOR_double
 &
x
) const;

52 const double& 
	$diag
(int 
i
) const { return 
	`diag_
(i); 
	}
}

53 double& 
	$diag
(int 
i
) { return 
	`diag_
(i); 
	}
}

	@include/icpre_double.h

31 #ifndef 
ICPRE_H


32 #define 
	#ICPRE_H


	)

34 #include 
	~"vecdefs.h
"

35 #include 
VECTOR_H


36 #include 
	~"comprow_double.h
"

37 #include 
	~"compcol_double.h
"

40 class 
	cICPreconditioner_double
 {

42 
	mprivate
:

43 
VECTOR_double
 
val_
;

44 
VECTOR_int
 
	mpntr_
;

45 
VECTOR_int
 
	mindx_
;

46 int 
	mnz_
;

47 int 
	mdim_
[2];

49 
	mpublic
:

50 
ICPreconditioner_double
(const 
CompCol_Mat_double
 &
A
);

51 
ICPreconditioner_double
(const 
CompRow_Mat_double
 &
A
);

52 ~
	$ICPreconditioner_double
(void){};

54 
VECTOR_double
 
	$solve
(const 
VECTOR_double
 &
x
) const;

55 
VECTOR_double
 
	$trans_solve
(const 
VECTOR_double
 &
x
) const;

56 
	}
};

	@include/ilupre_double.h

31 #ifndef 
ILUPRE_H


32 #define 
	#ILUPRE_H


	)

34 #include 
	~"vecdefs.h
"

35 #include 
VECTOR_H


36 #include 
	~"comprow_double.h
"

37 #include 
	~"compcol_double.h
"

40 class 
	cCompCol_ILUPreconditioner_double
 {

42 
	mprivate
:

43 
VECTOR_double
 
l_val_
;

44 
VECTOR_int
 
	ml_colptr_
;

45 
VECTOR_int
 
	ml_rowind_
;

46 int 
	ml_nz_
;

48 
VECTOR_double
 
	mu_val_
;

49 
VECTOR_int
 
	mu_colptr_
;

50 
VECTOR_int
 
	mu_rowind_
;

51 int 
	mu_nz_
;

53 int 
	mdim_
[2];

55 
	mpublic
:

56 
CompCol_ILUPreconditioner_double
(const 
CompCol_Mat_double
 &
A
);

57 ~
	$CompCol_ILUPreconditioner_double
(void){};

59 
VECTOR_double
 
	$solve
(const 
VECTOR_double
 &
x
) const;

60 
VECTOR_double
 
	$trans_solve
(const 
VECTOR_double
 &
x
) const;

61 
	}
};

64 class 
	cCompRow_ILUPreconditioner_double
 {

66 
	mprivate
:

67 
VECTOR_double
 
l_val_
;

68 
VECTOR_int
 
	ml_rowptr_
;

69 
VECTOR_int
 
	ml_colind_
;

70 int 
	ml_nz_
;

72 
VECTOR_double
 
	mu_val_
;

73 
VECTOR_int
 
	mu_rowptr_
;

74 
VECTOR_int
 
	mu_colind_
;

75 int 
	mu_nz_
;

77 int 
	mdim_
[2];

79 
	mpublic
:

80 
CompRow_ILUPreconditioner_double
(const 
CompRow_Mat_double
 &
A
);

81 ~
	$CompRow_ILUPreconditioner_double
(void){};

83 
VECTOR_double
 
	$solve
(const 
VECTOR_double
 &
x
) const;

84 
VECTOR_double
 
	$trans_solve
(const 
VECTOR_double
 &
x
) const;

85 
	}
};

	@include/iohb.h

32 #ifndef 
_IOHB_H_


33 #define 
	#_IOHB_H_


	)

35 #ifdef 
__ProtoGlarp__


36 #undef 
__ProtoGlarp__


38 #if 
defined
(
__STDC__
) || defined(
__cplusplus
)

39 #define 
	#__ProtoGlarp__
(
x
) 
	)
x

41 #define 
	#__ProtoGlarp__
(
x
) ()

	)

44 #ifdef 
__cplusplus


48 void 
readHB_info
 
__ProtoGlarp__
(( const char*, int*, int*, int*, int* ));

49 void 
readHB_mat_double
 
__ProtoGlarp__
(( const char*, int*, int*, double*));

50 void 
readHB_mat_float
 
__ProtoGlarp__
(( const char*, int*, int*, float*));

52 void 
readHB_rhs_double
 
__ProtoGlarp__
(( const char*, double*, int));

53 void 
readHB_rhs_float
 
__ProtoGlarp__
(( const char*, float*, int));

55 void 
writeHB_mat_double


56 
__ProtoGlarp__
(( const char*, int, int, int, const int*, const int*,

58 void 
writeHB_mat_float


59 
__ProtoGlarp__
(( const char*, int, int, int, const int*, const int*,

62 #ifdef 
__cplusplus


	@include/iohb_double.h

36 #include 
	~"iohb.h
"

39 
	gCompCol_Mat_double
& 
readHB_mat
(const char *
filename
, 
CompCol_Mat_double
 *
A
);

40 
	gCompRow_Mat_double
& 
readHB_mat
(const char *
filename
, 
CompRow_Mat_double
 *
A
);

41 
	gCoord_Mat_double
& 
readHB_mat
(const char *
filename
, 
Coord_Mat_double
 *
A
);

43 const 
	gCompCol_Mat_double
& 
writeHB_mat
(const char *
filename
,

44 const 
CompCol_Mat_double
 &
A
,

45 int 
nrhs
=0, const double *
rhs
 = 0,

46 const char *
title
=0, const char *
key
=0);

48 const 
	gCompRow_Mat_double
& 
writeHB_mat
(const char *
filename
,

49 const 
CompRow_Mat_double
 &
A
,

50 int 
nrhs
=0, const double* 
rhs
 = 0,

51 const char *
title
=0, const char *
key
=0);

54 const 
	gCoord_Mat_double
& 
writeHB_mat
(const char *
filename
,

55 const 
Coord_Mat_double
 &
A
,

56 int 
nrhs
=0, const double* 
rhs
=0,

57 const char *
title
=0, const char *
key
=0);

59 
	gVECTOR_double
& 
readHB_rhs
(const char *
filename
, 
VECTOR_double
 *
b
, int 
j
=0);

	@include/iotext.h

34 #ifndef 
_IOTEXT_H_


35 #define 
	#_IOTEXT_H_


	)

37 int 
readtxtfile_vec
(const char *
filename
, 
MV_Vector_double
 *
Aptr
);

38 int 
writetxtfile_vec
(const char *
filename
, const 
MV_Vector_double
 &
A
);

39 int 
readtxtfile_vec
(const char *
filename
, 
MV_Vector_int
 *
Aptr
);

40 int 
writetxtfile_vec
(const char *
filename
, const 
MV_Vector_int
 &
A
);

	@include/iotext_double.h

35 #include 
	~"compcol_double.h
"

36 #include 
	~"comprow_double.h
"

37 #include 
	~"coord_double.h
"

39 void 
readtxtfile_mat
(const char *
filename
, 
Coord_Mat_double
 *
A
);

40 void 
readtxtfile_mat
(const char *
filename
, 
CompCol_Mat_double
 *
A
);

41 void 
readtxtfile_mat
(const char *
filename
, 
CompRow_Mat_double
 *
A
);

42 void 
writetxtfile_mat
(const char *
filename
, const 
Coord_Mat_double
 &
A
);

43 void 
writetxtfile_mat
(const char *
filename
, const 
CompCol_Mat_double
 &
A
);

44 void 
writetxtfile_mat
(const char *
filename
, const 
CompRow_Mat_double
 &
A
);

	@include/iotext_type.h

35 #include 
	~"compcol_TYPE.h
"

36 #include 
	~"comprow_TYPE.h
"

37 #include 
	~"coord_TYPE.h
"

39 void 
readtxtfile_mat
(const char *
filename
, 
Coord_Mat_TYPE
 &
A
);

40 void 
readtxtfile_mat
(const char *
filename
, 
CompCol_Mat_TYPE
 &
A
);

41 void 
readtxtfile_mat
(const char *
filename
, 
CompRow_Mat_TYPE
 &
A
);

42 void 
writetxtfile_mat
(const char *
filename
, 
Coord_Mat_TYPE
 &
A
);

43 void 
writetxtfile_mat
(const char *
filename
, 
CompCol_Mat_TYPE
 &
A
);

44 void 
writetxtfile_mat
(const char *
filename
, 
CompRow_Mat_TYPE
 &
A
);

	@include/minstr.h

42 char* 
substr
(char * 
S
, int 
pos
, int 
len
);

43 char* 
substr_after
(char * 
S
, char 
M
);

44 char* 
substr_before
(char * 
S
, char 
M
);

45 char* 
substr_through
(char * 
S
, char 
M
);

46 void 
upcase
(char * 
S
);

47 int 
index
(char * 
S
, char 
M
);

	@include/qsort_double.h

35 #include 
	~"vecdefs.h
"

36 #include 
VECTOR_H


38 int 
QSort
(
VECTOR_double
& 
v
, int 
base_ptr
, int 
total_elems
);

39 int 
QSort
(
VECTOR_int
 & 
v
, 
VECTOR_double
& 
x
, int 
base_ptr
, int 
total_elems
);

	@include/qsort_int.h

35 #include 
	~"vecdefs.h
"

36 #include 
VECTOR_H


38 int 
QSort
(
VECTOR_int
& 
v
, int 
base_ptr
, int 
total_elems
);

39 int 
QSort
(
VECTOR_int
 & 
v
, VECTOR_int& 
x
, int 
base_ptr
, int 
total_elems
);

	@include/qsort_type.h

35 #include 
	~"vecdefs.h
"

36 #include 
VECTOR_H


38 int 
QSort
(
VECTOR_TYPE
& 
v
, int 
base_ptr
, int 
total_elems
);

39 int 
QSort
(
VECTOR_int
 & 
v
, 
VECTOR_TYPE
& 
x
, int 
base_ptr
, int 
total_elems
);

	@include/spblas.h

32 #ifndef 
SPBLAS_H


33 #define 
	#SPBLAS_H


	)

35 #ifndef 
F77NAME


36 #if 
defined
(
RIOS
)

37 #define 
	#F77NAME
(
x
) 
	)
x

39 #define 
	#F77NAME
(
x
) x##
_


	)

43 #ifdef 
COMPLEX_SUPPORT


44 #include 
	~"complex.h
"

49 void 
F77NAME
(
scoomm
)

50 (const int &
transa
, const int &
m
, const int &
n
, const int &
k
,

51 const float &
alpha
,

52 const int 
descra
[], const float *
val
,

53 const int *
indx
, const int *
jndx
, const int &
nnz
,

54 const float *
b
, const int &
ldb
,

55 const float &
beta
, float *
c
, const int &
ldc
,

56 float *
work
, const int &
lwork
);

58 void 
F77NAME
(
scscmm
)

59 (const int &
transa
, const int &
m
, const int &
n
, const int &
k
,

60 const float &
alpha
,

61 const int 
descra
[], const float *
val
,

62 const int *
indx
, const int *
pntr
, const float *
b
, int &
ldb
,

63 const float &
beta
, float *
c
, const int &
ldc
,

64 float *
work
, const int &
lwork
);

66 void 
F77NAME
(
scsrmm
)

67 (const int &
transa
, const int &
m
, const int &
n
, const int &
k
,

68 const float &
alpha
,

69 const int 
descra
[], const float *
val
,

70 const int *
indx
, const int *
pntr
, const float *
b
, int &
ldb
,

71 const float &
beta
, float *
c
, const int &
ldc
,

72 float *
work
, const int &
lwork
);

74 void 
F77NAME
(
dcoomm
)

75 (const int &
transa
, const int &
m
, const int &
n
, const int &
k
,

76 const double &
alpha
,

77 const int 
descra
[], const double *
val
,

78 const int *
indx
, const int *
jndx
, const int &
nnz
,

79 const double *
b
, const int &
ldb
,

80 const double &
beta
, double *
c
, const int &
ldc
,

81 double *
work
, const int &
lwork
);

83 void 
F77NAME
(
dcscmm
)

84 (const int &
transa
, const int &
m
, const int &
n
, const int &
k
,

85 const double &
alpha
,

86 const int 
descra
[], const double *
val
,

87 const int *
indx
, const int *
pntr
, const double *
b
, int &
ldb
,

88 const double &
beta
, double *
c
, const int &
ldc
,

89 double *
work
, const int &
lwork
);

91 void 
F77NAME
(
dcsrmm
)

92 (const int &
transa
, const int &
m
, const int &
n
, const int &
k
,

93 const double &
alpha
,

94 const int 
descra
[], const double *
val
,

95 const int *
indx
, const int *
pntr
, const double *
b
, int &
ldb
,

96 const double &
beta
, double *
c
, const int &
ldc
,

97 double *
work
, const int &
lwork
);

100 void 
F77NAME
(
dcscsm
)

101 (const int &
transa
, const int &
m
, const int &
n
,

102 const int &
unitd
, const double *
dv
, const double &
alpha
,

103 const int 
descra
[], const double *
val
,

104 const int *
indx
, const int *
pntr
, const double *
b
, int &
ldb
,

105 const double &
beta
, double *
c
, const int &
ldc
,

106 double *
work
, const int &
lwork
);

108 void 
F77NAME
(
dcsrsm
)

109 (const int &
transa
, const int &
m
, const int &
n
,

110 const int &
unitd
, const double *
dv
, const double &
alpha
,

111 const int 
descra
[], const double *
val
,

112 const int *
indx
, const int *
pntr
, const double *
b
, int &
ldb
,

113 const double &
beta
, double *
c
, const int &
ldc
,

114 double *
work
, const int &
lwork
);

116 void 
F77NAME
(
scscsm
)

117 (const int &
transa
, const int &
m
, const int &
n
,

118 const int &
unitd
, const float *
dv
, const float &
alpha
,

119 const int 
descra
[], const float *
val
,

120 const int *
indx
, const int *
pntr
, const float *
b
, int &
ldb
,

121 const float &
beta
, float *
c
, const int &
ldc
,

122 float *
work
, const int &
lwork
);

124 void 
F77NAME
(
scsrsm
)

125 (const int &
transa
, const int &
m
, const int &
n
,

126 const int &
unitd
, const float *
dv
, const float &
alpha
,

127 const int 
descra
[], const float *
val
,

128 const int *
indx
, const int *
pntr
, const float *
b
, int &
ldb
,

129 const float &
beta
, float *
c
, const int &
ldc
,

130 float *
work
, const int &
lwork
);

132 #ifdef 
COMPLEX_SUPPORT


134 void 
F77NAME
(
zcoomm
)

135 (const int &
transa
, const int &
m
, const int &
n
, const int &
k
,

136 const 
complex
 &
alpha
,

137 const int 
descra
[], const 
complex
 *
val
,

138 const int *
indx
, const int *
jndx
, const int &
nnz
,

139 const 
complex
 *
b
, const int &
ldb
,

140 const 
complex
 &
beta
, complex *
c
, const int &
ldc
,

141 
complex
 *
work
, const int &
lwork
);

143 void 
F77NAME
(
zcscmm
)

144 (const int &
transa
, const int &
m
, const int &
n
, const int &
k
,

145 const 
complex
 &
alpha
,

146 const int 
descra
[], const 
complex
 *
val
,

147 const int *
indx
, const int *
pntr
, const 
complex
 *
b
, int &
ldb
,

148 const 
complex
 &
beta
, complex *
c
, const int &
ldc
,

149 
complex
 *
work
, const int &
lwork
);

151 void 
F77NAME
(
zcsrmm
)

152 (const int &
transa
, const int &
m
, const int &
n
, const int &
k
,

153 const 
complex
 &
alpha
,

154 const int 
descra
[], const 
complex
 *
val
,

155 const int *
indx
, const int *
pntr
, const 
complex
 *
b
, int &
ldb
,

156 const 
complex
 &
beta
, complex *
c
, const int &
ldc
,

157 
complex
 *
work
, const int &
lwork
);

159 void 
F77NAME
(
zcscsm
)

160 (const int &
transa
, const int &
m
, const int &
n
,

161 const int &
unitd
, const 
complex
 *
dv
, const complex &
alpha
,

162 const int 
descra
[], const 
complex
 *
val
,

163 const int *
indx
, const int *
pntr
, const 
complex
 *
b
, int &
ldb
,

164 const 
complex
 &
beta
, complex *
c
, const int &
ldc
,

165 
complex
 *
work
, const int &
lwork
);

167 void 
F77NAME
(
zcsrsm
)

168 (const int &
transa
, const int &
m
, const int &
n
,

169 const int &
unitd
, const 
complex
 *
dv
, const complex &
alpha
,

170 const int 
descra
[], const 
complex
 *
val
,

171 const int *
indx
, const int *
pntr
, const 
complex
 *
b
, int &
ldb
,

172 const 
complex
 &
beta
, complex *
c
, const int &
ldc
,

173 
complex
 *
work
, const int &
lwork
);

	@include/tblas1.h

31 #ifndef 
_MV_BLAS1_TYPE_H_


32 #define 
	#_MV_BLAS1_TYPE_H_


	)

34 #include 
	~<math.h
>

35 #include 
	~<stdlib.h
>

38 
	gMV_Vector_TYPE
& 
	goperator
*=(
MV_Vector_TYPE
 &
x
, const 
	gTYPE
 &
	ga
);

39 
MV_Vector_TYPE
 
	goperator
*(const 
	gTYPE
 &
	ga
, const 
	gMV_Vector_TYPE
 &
	gx
);

40 
MV_Vector_TYPE
 
	goperator
*(const 
	gMV_Vector_TYPE
 &
	gx
, const 
	gTYPE
 &
	ga
);

41 
MV_Vector_TYPE
 
	goperator
+(const 
	gMV_Vector_TYPE
 &
	gx
,

42 const 
	gMV_Vector_TYPE
 &
	gy
);

43 
MV_Vector_TYPE
 
	goperator
-(const 
	gMV_Vector_TYPE
 &
	gx
,

44 const 
	gMV_Vector_TYPE
 &
	gy
);

45 
	gMV_Vector_TYPE
& 
	goperator
+=(
MV_Vector_TYPE
 &
x
, const MV_Vector_TYPE &
	gy
);

46 
	gMV_Vector_TYPE
& 
	goperator
-=(
MV_Vector_TYPE
 &
x
, const MV_Vector_TYPE &
	gy
);

48 
TYPE
 
dot
(const 
MV_Vector_TYPE
 &
x
, const MV_Vector_TYPE &
y
);

49 
TYPE
 
norm
(const 
MV_Vector_TYPE
 &
x
);

	@include/tmvec.h

35 #ifndef 
_MV_VECTOR_TYPE_H


36 #define 
	#_MV_VECTOR_TYPE_H


	)

87 #include 
	~<sstream
>

90 #ifdef 
MV_VECTOR_BOUNDS_CHECK


91 #include 
	~<assert.h
>

94 #include 
	~"mv_vecindex.h
"

101 #include 
	~"mv_vector_ref.h
"

103 class 
	cMV_Vector_TYPE


105 
	mprotected
:

106 
TYPE
 *
p_
;

107 unsigned int 
	mdim_
;

108 int 
	mref_
;

109 
	mpublic
:

116 
MV_Vector_TYPE
();

117 
MV_Vector_TYPE
(unsigned int);

118 
MV_Vector_TYPE
(unsigned int, const 
TYPE
&);

121 
MV_Vector_TYPE
(
TYPE
*, unsigned int);

122 
MV_Vector_TYPE
(const 
TYPE
*, unsigned int);

126 
MV_Vector_TYPE
(
TYPE
*, unsigned int, 
MV_Vector_
::
ref_type
 
i
);

127 
MV_Vector_TYPE
(const MV_Vector_TYPE &);

128 ~
MV_Vector_TYPE
();

138 
	mTYPE
& 
	$operator
()(unsigned int 
i
)

140 #ifdef 
MV_VECTOR_BOUNDS_CHECK


141 
	`assert
(
i
 < 
dim_
);

143 return 
p_
[
i
];

145 const 
TYPE
& 
	$operator
()(unsigned int 
i
) const

147 #ifdef 
MV_VECTOR_BOUNDS_CHECK


148 
	`assert
(
i
 < 
dim_
);

150 return 
p_
[
i
];

151 
	}
}

153 
	gTYPE
& 
	goperator
[](unsigned int 
	gi
)

155 #ifdef 
MV_VECTOR_BOUNDS_CHECK


156 
assert
(
i
 < 
dim_
);

158 return 
	gp_
[
i
];

160 const 
	gTYPE
& 
	goperator
[](unsigned int 
	gi
) const

162 #ifdef 
MV_VECTOR_BOUNDS_CHECK


163 
assert
(
i
 < 
dim_
);

165 return 
	gp_
[
i
];

170 
MV_Vector_TYPE
 
	$operator
()(const 
MV_VecIndex
 &
I
) ;

171 
MV_Vector_TYPE
 
	$operator
()(void);

172 const 
MV_Vector_TYPE
 
	$operator
()(void) const;

173 const 
MV_Vector_TYPE
 
	$operator
()(const 
MV_VecIndex
 &
I
) const;

179 
inline
 unsigned int 
	$size
() const { return 
dim_
;
	}
}

180 
inline
 int 
	$ref
() const { return 
ref_
;
	}
}

181 
inline
 int 
	$null
() const {return 
dim_
== 0;
	}
}

184 
	gMV_Vector_TYPE
 & 
newsize
(unsigned int );

190 
	gMV_Vector_TYPE
 & 
	goperator
=(const 
MV_Vector_TYPE
&);

191 
	gMV_Vector_TYPE
 & 
	goperator
=(const 
TYPE
&);

194 
friend
 
	gstd
::
ostream
& 
operator
<<(
std
::ostream &
s
, const 
	gMV_Vector_TYPE
 &
	gA
);

198 #include 
	~"mv_blas1_TYPE.h
"

	@include/tmvmat.h

39 #ifndef 
_MV_MATRIX_TYPE_H_


40 #define 
	#_MV_MATRIX_TYPE_H_


	)

42 #include 
	~"mv_vector_TYPE.h
"

43 #include 
	~"mv_matrix_ref.h
"

47 #include 
	~<sstream
>

49 #ifdef 
MV_MATRIX_BOUNDS_CHECK


50 #include 
	~<assert.h
>

54 class 
	cMV_ColMat_TYPE


56 
	mprivate
:

57 
MV_Vector_TYPE
 
v_
;

58 int 
	mdim0_
;

59 int 
	mdim1_
;

60 int 
	mlda_
;

61 int 
	mref_
;

64 
	mpublic
:

70 
MV_ColMat_TYPE
();

71 
MV_ColMat_TYPE
(unsigned int, unsigned int);

74 
MV_ColMat_TYPE
(unsigned int, unsigned int, const 
TYPE
&);

79 
MV_ColMat_TYPE
(
TYPE
*, unsigned int 
m
, unsigned int 
n
);

80 
MV_ColMat_TYPE
(
TYPE
*, unsigned int 
m
, unsigned int 
n
, unsigned int 
lda
);

85 
MV_ColMat_TYPE
(
TYPE
*, unsigned int 
m
, unsigned int 
n
, 
MV_Matrix_
::
ref_type
 
i
);

86 
MV_ColMat_TYPE
(
TYPE
*, unsigned int 
m
, unsigned int 
n
, unsigned int 
lda
,

87 
MV_Matrix_
::
ref_type
 
i
);

89 
MV_ColMat_TYPE
(const MV_ColMat_TYPE&);

90 ~
MV_ColMat_TYPE
();

96 
inline
 
	mTYPE
& 
	$operator
()(unsigned int, unsigned int);

97 
inline
 const 
TYPE
& 
	$operator
()(unsigned int, unsigned int) const;

98 
MV_ColMat_TYPE
 
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
) ;

99 const 
MV_ColMat_TYPE
 
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
) const;

100 unsigned int 
	$size
(int 
i
) const;

101 
MV_ColMat_TYPE
& 
	`newsize
(unsigned int, unsigned int);

102 int 
	$ref
() const { return 
ref_
;}

108 
MV_ColMat_TYPE
 & 
operator
=(const MV_ColMat_TYPE&);

109 
MV_ColMat_TYPE
 & 
operator
=(const 
TYPE
&);

112 
friend
 
std
::
ostream
& 
operator
<<(std::ostream &
s
, const 
MV_ColMat_TYPE
 &
A
);

114 
	}
};

116 
inline
 
	gTYPE
& 
	gMV_ColMat_TYPE
::
	$operator
()(unsigned int 
i
, unsigned int 
j
)

118 #ifdef 
MV_MATRIX_BOUNDS_CHECK


119 
	`assert
(0<=
i
 && i<
	`size
(0));

120 
	`assert
(0<=
j
 && j<
	`size
(1));

122 return 
	`v_
(
j
*
lda_
 + 
i
);

124 
	}
}

126 
inline
 const 
	gTYPE
& 
	gMV_ColMat_TYPE
::
	$operator
()

127 (unsigned int 
i
, unsigned int 
j
) const

129 #ifdef 
MV_MATRIX_BOUNDS_CHECK


130 
	`assert
(0<=
i
 && i<
	`size
(0));

131 
	`assert
(0<=
j
 && j<
	`size
(1));

133 return 
	`v_
(
j
*
lda_
 + 
i
);

134 
	}
}

136 
inline
 
	gMV_ColMat_TYPE
::
MV_ColMat_TYPE
(
TYPE
* 
d
, unsigned int 
m
, unsigned int 
n
,

137 
MV_Matrix_
::
ref_type
 
i
 ):

138 
v_
(
d
,
m
*
n
, 
MV_Vector_
::
ref
), 
dim0_
(m), 
dim1_
(n), 
lda_
(m), 
	$ref_
(
i
) {
	}
}

140 
inline
 
	gMV_ColMat_TYPE
::
MV_ColMat_TYPE
(
TYPE
* 
d
, unsigned int 
m
, unsigned int 
n
,

141 unsigned int 
lda
, 
MV_Matrix_
::
ref_type
 
i
) :

142 
v_
(
d
, 
lda
*
n
, 
MV_Vector_
::
ref
), 
dim0_
(
m
), 
dim1_
(n), 
lda_
(lda),

143 
	$ref_
(
i
) {
	}
}

	@mv/include/iotext.h

28 #ifndef 
_IOTEXT_H_


29 #define 
	#_IOTEXT_H_


	)

31 int 
readtxtfile_vec
(const char *
filename
, 
MV_Vector_double
 *
Aptr
);

32 int 
writetxtfile_vec
(const char *
filename
, const 
MV_Vector_double
 &
A
);

33 int 
readtxtfile_vec
(const char *
filename
, 
MV_Vector_int
 *
Aptr
);

34 int 
writetxtfile_vec
(const char *
filename
, const 
MV_Vector_int
 &
A
);

	@mv/include/mvblas.h

25 #ifndef 
_MV_BLAS1_TPL_H_


26 #define 
	#_MV_BLAS1_TPL_H_


	)

30 
	gtemplate
 <
class
 
	gTYPE
>

31 
	gMV_Vector
<
	gTYPE
>& 
	goperator
*=(
MV_Vector
<
TYPE
> &
x
, const TYPE &
	ga
)

33 int 
	gN
 = 
x
.
size
();

34 for (int 
	gi
=0;i<
	gN
;i++)

35 
x
(
i
) *= 
a
;

36 return 
	gx
;

39 
	gtemplate
 <
class
 
	gTYPE
>

40 
	gMV_Vector
<
	gTYPE
> 
	goperator
*(const TYPE &
	ga
, const MV_Vector<TYPE> &
	gx
)

42 int 
	gN
 = 
x
.
size
();

43 
	gMV_Vector
<
	gTYPE
> 
result
(
N
);

44 for (int 
	gi
=0;i<
	gN
;i++)

45 
result
(
i
) = 
x
(i)*
a
;

46 return 
	gresult
;

49 
	gtemplate
 <
class
 
	gTYPE
>

50 
	gMV_Vector
<
	gTYPE
> 
	goperator
*(const MV_Vector<TYPE> &
	gx
, const TYPE &
	ga
)

60 int 
	gN
 = 
x
.
size
();

61 
	gMV_Vector
<
	gTYPE
> 
result
(
N
);

62 for (int 
	gi
=0;i<
	gN
;i++)

63 
result
(
i
) = 
x
(i)*
a
;

64 return 
	gresult
;

68 
	gtemplate
 <
class
 
	gTYPE
>

69 
	gMV_Vector
<
	gTYPE
> 
	goperator
+(const MV_Vector<TYPE> &
	gx
, const MV_Vector<TYPE> &
	gy
)

71 int 
	gN
 = 
x
.
size
();

72 if (
	gN
 != 
y
.
size
())

74 
cout
 << "Incompatible vector lengths in +." << 
endl
;

75 
exit
(1);

78 
	gMV_Vector
<
	gTYPE
> 
result
(
N
);

79 for (int 
	gi
=0;i<
	gN
; i++)

80 
result
(
i
) = 
x
(i) + 
y
(i);

81 return 
	gresult
;

84 
	gtemplate
 <
class
 
	gTYPE
>

85 
	gMV_Vector
<
	gTYPE
> 
	goperator
-(const MV_Vector<TYPE> &
	gx
, const MV_Vector<TYPE> &
	gy
)

87 int 
	gN
 = 
x
.
size
();

88 if (
	gN
 != 
y
.
size
())

90 
cout
 << "Incompatible vector lengths in -." << 
endl
;

91 
exit
(1);

94 
	gMV_Vector
<
	gTYPE
> 
result
(
N
);

95 for (int 
	gi
=0;i<
	gN
; i++)

96 
result
(
i
) = 
x
(i) - 
y
(i);

97 return 
	gresult
;

101 
	gtemplate
 <
class
 
	gTYPE
>

102 
	gMV_Vector
<
	gTYPE
>& 
	goperator
+=(
MV_Vector
<
TYPE
> &
x
, const MV_Vector<TYPE> &
	gy
)

104 int 
	gN
 = 
x
.
size
();

105 if (
	gN
 != 
y
.
size
())

107 
cout
 << "Incompatible vector lengths in -." << 
endl
;

108 
exit
(1);

111 for (int 
	gi
=0;i<
	gN
; i++)

112 
x
(
i
) += 
y
(i);

113 return 
	gx
;

117 
	gtemplate
 <
class
 
	gTYPE
>

118 
	gMV_Vector
<
	gTYPE
>& 
	goperator
-=(
MV_Vector
<
TYPE
> &
x
, const MV_Vector<TYPE> &
	gy
)

120 int 
	gN
 = 
x
.
size
();

121 if (
	gN
 != 
y
.
size
())

123 
cout
 << "Incompatible vector lengths in -." << 
endl
;

124 
exit
(1);

127 for (int 
	gi
=0;i<
	gN
; i++)

128 
x
(
i
) -= 
y
(i);

129 return 
	gx
;

137 
	gtemplate
 <
class
 
	gTYPE
>

138 
TYPE
 
dot
(const 
MV_Vector
<TYPE> &
x
, const MV_Vector<TYPE> &
y
)

142 if (
	gx
.
size
() != 
y
.size())

144 
cout
 << "Incompatible dimensions in dot(). " << 
endl
;

145 
exit
(1);

148 
TYPE
 
	gtemp
=0.0;

149 for (int 
	gi
=0; i<
	gx
.
size
();i++)

150 
	gtemp
 += 
x
(
i
)*
y
(i);

151 return 
	gtemp
;

154 
	gtemplate
 <
class
 
	gTYPE
>

155 
TYPE
 
norm
(const 
MV_Vector
<TYPE> &
x
)

157 
TYPE
 
	gtemp
 = 
dot
(
x
,x);

158 return 
sqrt
(
temp
);

	@mv/include/mvblasc.h

25 #ifndef 
_MV_BLAS1_COMPLEX_H_


26 #define 
	#_MV_BLAS1_COMPLEX_H_


	)

29 
	gMV_Vector_COMPLEX
& 
	goperator
*=(
MV_Vector_COMPLEX
 &
x
, const 
	gCOMPLEX
 &
	ga
);

30 
MV_Vector_COMPLEX
 
	goperator
*(const 
	gCOMPLEX
 &
	ga
, const 
	gMV_Vector_COMPLEX
 &
	gx
);

31 
MV_Vector_COMPLEX
 
	goperator
*(const 
	gMV_Vector_COMPLEX
 &
	gx
, const 
	gCOMPLEX
 &
	ga
);

32 
MV_Vector_COMPLEX
 
	goperator
+(const 
	gMV_Vector_COMPLEX
 &
	gx
,

33 const 
	gMV_Vector_COMPLEX
 &
	gy
);

34 
MV_Vector_COMPLEX
 
	goperator
-(const 
	gMV_Vector_COMPLEX
 &
	gx
,

35 const 
	gMV_Vector_COMPLEX
 &
	gy
);

36 
	gMV_Vector_COMPLEX
& 
	goperator
+=(
MV_Vector_COMPLEX
 &
x
, const MV_Vector_COMPLEX &
	gy
);

37 
	gMV_Vector_COMPLEX
& 
	goperator
-=(
MV_Vector_COMPLEX
 &
x
, const MV_Vector_COMPLEX &
	gy
);

39 
COMPLEX
 
dot
(const 
MV_Vector_COMPLEX
 &
x
, const MV_Vector_COMPLEX &
y
);

40 
COMPLEX
 
norm
(const 
MV_Vector_COMPLEX
 &
x
);

	@mv/include/mvblasd.h

25 #ifndef 
_MV_BLAS1_double_H_


26 #define 
	#_MV_BLAS1_double_H_


	)

29 
	gMV_Vector_double
& 
	goperator
*=(
MV_Vector_double
 &
x
, const double &
	ga
);

30 
MV_Vector_double
 
	goperator
*(const double &
	ga
, const 
	gMV_Vector_double
 &
	gx
);

31 
MV_Vector_double
 
	goperator
*(const 
	gMV_Vector_double
 &
	gx
, const double &
	ga
);

32 
MV_Vector_double
 
	goperator
+(const 
	gMV_Vector_double
 &
	gx
,

33 const 
	gMV_Vector_double
 &
	gy
);

34 
MV_Vector_double
 
	goperator
-(const 
	gMV_Vector_double
 &
	gx
,

35 const 
	gMV_Vector_double
 &
	gy
);

36 
	gMV_Vector_double
& 
	goperator
+=(
MV_Vector_double
 &
x
, const MV_Vector_double &
	gy
);

37 
	gMV_Vector_double
& 
	goperator
-=(
MV_Vector_double
 &
x
, const MV_Vector_double &
	gy
);

39 double 
dot
(const 
MV_Vector_double
 &
x
, const MV_Vector_double &
y
);

40 double 
norm
(const 
MV_Vector_double
 &
x
);

	@mv/include/mvblasf.h

25 #ifndef 
_MV_BLAS1_float_H_


26 #define 
	#_MV_BLAS1_float_H_


	)

29 
	gMV_Vector_float
& 
	goperator
*=(
MV_Vector_float
 &
x
, const float &
	ga
);

30 
MV_Vector_float
 
	goperator
*(const float &
	ga
, const 
	gMV_Vector_float
 &
	gx
);

31 
MV_Vector_float
 
	goperator
*(const 
	gMV_Vector_float
 &
	gx
, const float &
	ga
);

32 
MV_Vector_float
 
	goperator
+(const 
	gMV_Vector_float
 &
	gx
,

33 const 
	gMV_Vector_float
 &
	gy
);

34 
MV_Vector_float
 
	goperator
-(const 
	gMV_Vector_float
 &
	gx
,

35 const 
	gMV_Vector_float
 &
	gy
);

36 
	gMV_Vector_float
& 
	goperator
+=(
MV_Vector_float
 &
x
, const MV_Vector_float &
	gy
);

37 
	gMV_Vector_float
& 
	goperator
-=(
MV_Vector_float
 &
x
, const MV_Vector_float &
	gy
);

39 float 
dot
(const 
MV_Vector_float
 &
x
, const MV_Vector_float &
y
);

40 float 
norm
(const 
MV_Vector_float
 &
x
);

	@mv/include/mvblasi.h

25 #ifndef 
_MV_BLAS1_int_H_


26 #define 
	#_MV_BLAS1_int_H_


	)

29 
	gMV_Vector_int
& 
	goperator
*=(
MV_Vector_int
 &
x
, const int &
	ga
);

30 
MV_Vector_int
 
	goperator
*(const int &
	ga
, const 
	gMV_Vector_int
 &
	gx
);

31 
MV_Vector_int
 
	goperator
*(const 
	gMV_Vector_int
 &
	gx
, const int &
	ga
);

32 
MV_Vector_int
 
	goperator
+(const 
	gMV_Vector_int
 &
	gx
,

33 const 
	gMV_Vector_int
 &
	gy
);

34 
MV_Vector_int
 
	goperator
-(const 
	gMV_Vector_int
 &
	gx
,

35 const 
	gMV_Vector_int
 &
	gy
);

36 
	gMV_Vector_int
& 
	goperator
+=(
MV_Vector_int
 &
x
, const MV_Vector_int &
	gy
);

37 
	gMV_Vector_int
& 
	goperator
-=(
MV_Vector_int
 &
x
, const MV_Vector_int &
	gy
);

39 int 
dot
(const 
MV_Vector_int
 &
x
, const MV_Vector_int &
y
);

40 int 
norm
(const 
MV_Vector_int
 &
x
);

	@mv/include/mvblast.h

25 #ifndef 
_MV_BLAS1_$TYPE_H_


26 #define 
	#_MV_BLAS1_$TYPE_H_


	)

29 
	gMV_Vector_$TYPE
& 
	goperator
*=(
MV_Vector_$TYPE
 &
x
, const 
	g$TYPE
 &
	ga
);

30 
MV_Vector_$TYPE
 
	goperator
*(const 
	g$TYPE
 &
	ga
, const 
	gMV_Vector_$TYPE
 &
	gx
);

31 
MV_Vector_$TYPE
 
	goperator
*(const 
	gMV_Vector_$TYPE
 &
	gx
, const 
	g$TYPE
 &
	ga
);

32 
MV_Vector_$TYPE
 
	goperator
+(const 
	gMV_Vector_$TYPE
 &
	gx
,

33 const 
	gMV_Vector_$TYPE
 &
	gy
);

34 
MV_Vector_$TYPE
 
	goperator
-(const 
	gMV_Vector_$TYPE
 &
	gx
,

35 const 
	gMV_Vector_$TYPE
 &
	gy
);

36 
	gMV_Vector_$TYPE
& 
	goperator
+=(
MV_Vector_$TYPE
 &
x
, const MV_Vector_$TYPE &
	gy
);

37 
	gMV_Vector_$TYPE
& 
	goperator
-=(
MV_Vector_$TYPE
 &
x
, const MV_Vector_$TYPE &
	gy
);

39 
$TYPE
 
dot
(const 
MV_Vector_$TYPE
 &
x
, const MV_Vector_$TYPE &
y
);

40 
$TYPE
 
norm
(const 
MV_Vector_$TYPE
 &
x
);

	@mv/include/mvm.h

31 #ifndef 
_MV_MATRIX_ALL_H_


32 #define 
	#_MV_MATRIX_ALL_H_


	)

34 #include 
	~"mvmrf.h
"

35 #include 
	~"mvmd.h
"

36 #include 
	~"mvmi.h
"

37 #include 
	~"mvmf.h
"

39 #include 
	~<complex
>

40 #include 
	~"mvmc.h
"

	@mv/include/mvmc.h

33 #ifndef 
_MV_MATRIX_COMPLEX_H_


34 #define 
	#_MV_MATRIX_COMPLEX_H_


	)

36 #include 
	~"mvvc.h
"

37 #include 
	~"mvmrf.h
"

40 #include 
	~<sstream
>

42 #ifdef 
MV_MATRIX_BOUNDS_CHECK


43 #include 
	~<assert.h
>

47 class 
	cMV_ColMat_COMPLEX


49 
	mprivate
:

50 
MV_Vector_COMPLEX
 
v_
;

51 int 
	mdim0_
;

52 int 
	mdim1_
;

53 int 
	mlda_
;

54 int 
	mref_
;

57 
	mpublic
:

63 
MV_ColMat_COMPLEX
();

64 
MV_ColMat_COMPLEX
( int, int);

67 
MV_ColMat_COMPLEX
( int, int, const 
COMPLEX
&);

72 
MV_ColMat_COMPLEX
(
COMPLEX
*, int 
m
, int 
n
);

73 
MV_ColMat_COMPLEX
(
COMPLEX
*, int 
m
, int 
n
, int 
lda
);

78 
MV_ColMat_COMPLEX
(MV_ColMat_COMPLEX &
A
, 
MV_Matrix_
::
ref_type
 
i
);

79 
MV_ColMat_COMPLEX
(
COMPLEX
*, int 
m
, int 
n
, 
MV_Matrix_
::
ref_type
 
i
);

80 
MV_ColMat_COMPLEX
(
COMPLEX
*, int 
m
, int 
n
, int 
lda
,

81 
MV_Matrix_
::
ref_type
 
i
);

83 
MV_ColMat_COMPLEX
(const MV_ColMat_COMPLEX&);

84 ~
MV_ColMat_COMPLEX
();

90 
inline
 
	mCOMPLEX
& 
	$operator
()( int, int);

91 
inline
 const 
COMPLEX
& 
	$operator
()( int, int) const;

92 
MV_ColMat_COMPLEX
 
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
) ;

93 const 
MV_ColMat_COMPLEX
 
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
) const;

94 int 
	$dim
(int 
i
) const;

95 int 
	$lda
(void) const{ return 
lda_
; }

96 int 
	$size
(int 
i
) const { return 
	`dim
(i);
	}
}

97 
	gMV_ColMat_COMPLEX
& 
newsize
( int, int);

98 int 
	$ref
() const { return 
ref_
;
	}
}

104 
	gMV_ColMat_COMPLEX
 & 
	goperator
=(const 
MV_ColMat_COMPLEX
&);

105 
	gMV_ColMat_COMPLEX
 & 
	goperator
=(const 
COMPLEX
&);

108 
friend
 
	gstd
::
ostream
& 
operator
<<(
std
::ostream &
s
, const 
	gMV_ColMat_COMPLEX
 &
	gA
);

112 
inline
 
	gCOMPLEX
& 
	gMV_ColMat_COMPLEX
::
	$operator
()( int 
i
, int 
j
)

114 #ifdef 
MV_MATRIX_BOUNDS_CHECK


115 
	`assert
(0<=
i
 && i<
	`dim
(0));

116 
	`assert
(0<=
j
 && j<
	`dim
(1));

118 return 
	`v_
(
j
*
lda_
 + 
i
);

120 
	}
}

122 
inline
 const 
	gCOMPLEX
& 
	gMV_ColMat_COMPLEX
::
	$operator
()

123 ( int 
i
, int 
j
) const

125 #ifdef 
MV_MATRIX_BOUNDS_CHECK


126 
	`assert
(0<=
i
 && i<
	`dim
(0));

127 
	`assert
(0<=
j
 && j<
	`dim
(1));

129 return 
	`v_
(
j
*
lda_
 + 
i
);

130 
	}
}

132 
inline
 
	gMV_ColMat_COMPLEX
::
MV_ColMat_COMPLEX
(
COMPLEX
* 
d
, int 
m
,

133 int 
n
, 
MV_Matrix_
::
ref_type
 
i
 ):

134 
v_
(
d
,
m
*
n
, 
MV_Vector_
::
ref
), 
dim0_
(m), 
dim1_
(n), 
lda_
(m), 
	$ref_
(
i
) {
	}
}

136 
inline
 
	gMV_ColMat_COMPLEX
::
MV_ColMat_COMPLEX
( MV_ColMat_COMPLEX &
A
,

137 
MV_Matrix_
::
ref_type
 
i
 ):

138 
v_
(&
A
(0,0), A.
dim
(0)*A.dim(1), 
MV_Vector_
::
ref
),

139 
dim0_
(
A
.
dim
(0)), 
dim1_
(A.dim(1)), 
lda_
(A.
lda
()), 
	$ref_
(
i
) {
	}
}

141 
inline
 
	gMV_ColMat_COMPLEX
::
MV_ColMat_COMPLEX
(
COMPLEX
* 
d
, int 
m
, int 
n
,

142 int 
lda
, 
MV_Matrix_
::
ref_type
 
i
) :

143 
v_
(
d
, 
lda
*
n
, 
MV_Vector_
::
ref
), 
dim0_
(
m
), 
dim1_
(n), 
lda_
(lda),

144 
	$ref_
(
i
) {
	}
}

	@mv/include/mvmd.h

33 #ifndef 
_MV_MATRIX_double_H_


34 #define 
	#_MV_MATRIX_double_H_


	)

36 #include 
	~"mvvd.h
"

37 #include 
	~"mvmrf.h
"

40 #include 
	~<sstream
>

42 #ifdef 
MV_MATRIX_BOUNDS_CHECK


43 #include 
	~<assert.h
>

47 class 
	cMV_ColMat_double


49 
	mprivate
:

50 
MV_Vector_double
 
v_
;

51 int 
	mdim0_
;

52 int 
	mdim1_
;

53 int 
	mlda_
;

54 int 
	mref_
;

57 
	mpublic
:

63 
MV_ColMat_double
();

64 
MV_ColMat_double
( int, int);

67 
MV_ColMat_double
( int, int, const double&);

72 
MV_ColMat_double
(double*, int 
m
, int 
n
);

73 
MV_ColMat_double
(double*, int 
m
, int 
n
, int 
lda
);

78 
MV_ColMat_double
(MV_ColMat_double &
A
, 
MV_Matrix_
::
ref_type
 
i
);

79 
MV_ColMat_double
(double*, int 
m
, int 
n
, 
MV_Matrix_
::
ref_type
 
i
);

80 
MV_ColMat_double
(double*, int 
m
, int 
n
, int 
lda
,

81 
MV_Matrix_
::
ref_type
 
i
);

83 
MV_ColMat_double
(const MV_ColMat_double&);

84 ~
MV_ColMat_double
();

90 
inline
 double& 
	$operator
()( int, int);

91 
inline
 const double& 
	$operator
()( int, int) const;

92 
MV_ColMat_double
 
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
) ;

93 const 
MV_ColMat_double
 
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
) const;

94 int 
	$dim
(int 
i
) const;

95 int 
	$lda
(void) const{ return 
lda_
; }

96 int 
	$size
(int 
i
) const { return 
	`dim
(i);
	}
}

97 
	gMV_ColMat_double
& 
newsize
( int, int);

98 int 
	$ref
() const { return 
ref_
;
	}
}

104 
	gMV_ColMat_double
 & 
	goperator
=(const 
MV_ColMat_double
&);

105 
	gMV_ColMat_double
 & 
	goperator
=(const double&);

108 
friend
 
	gstd
::
ostream
& 
operator
<<(
std
::ostream &
s
, const 
	gMV_ColMat_double
 &
	gA
);

112 
inline
 double& 
	gMV_ColMat_double
::
	$operator
()( int 
i
, int 
j
)

114 #ifdef 
MV_MATRIX_BOUNDS_CHECK


115 
	`assert
(0<=
i
 && i<
	`dim
(0));

116 
	`assert
(0<=
j
 && j<
	`dim
(1));

118 return 
	`v_
(
j
*
lda_
 + 
i
);

120 
	}
}

122 
inline
 const double& 
	gMV_ColMat_double
::
	$operator
()

123 ( int 
i
, int 
j
) const

125 #ifdef 
MV_MATRIX_BOUNDS_CHECK


126 
	`assert
(0<=
i
 && i<
	`dim
(0));

127 
	`assert
(0<=
j
 && j<
	`dim
(1));

129 return 
	`v_
(
j
*
lda_
 + 
i
);

130 
	}
}

132 
inline
 
	gMV_ColMat_double
::
MV_ColMat_double
(double* 
d
, int 
m
,

133 int 
n
, 
MV_Matrix_
::
ref_type
 
i
 ):

134 
v_
(
d
,
m
*
n
, 
MV_Vector_
::
ref
), 
dim0_
(m), 
dim1_
(n), 
lda_
(m), 
	$ref_
(
i
) {
	}
}

136 
inline
 
	gMV_ColMat_double
::
MV_ColMat_double
( MV_ColMat_double &
A
,

137 
MV_Matrix_
::
ref_type
 
i
 ):

138 
v_
(&
A
(0,0), A.
dim
(0)*A.dim(1), 
MV_Vector_
::
ref
),

139 
dim0_
(
A
.
dim
(0)), 
dim1_
(A.dim(1)), 
lda_
(A.
lda
()), 
	$ref_
(
i
) {
	}
}

141 
inline
 
	gMV_ColMat_double
::
MV_ColMat_double
(double* 
d
, int 
m
, int 
n
,

142 int 
lda
, 
MV_Matrix_
::
ref_type
 
i
) :

143 
v_
(
d
, 
lda
*
n
, 
MV_Vector_
::
ref
), 
dim0_
(
m
), 
dim1_
(n), 
lda_
(lda),

144 
	$ref_
(
i
) {
	}
}

	@mv/include/mvmf.h

33 #ifndef 
_MV_MATRIX_float_H_


34 #define 
	#_MV_MATRIX_float_H_


	)

36 #include 
	~"mvvf.h
"

37 #include 
	~"mvmrf.h
"

40 #include 
	~<sstream
>

42 #ifdef 
MV_MATRIX_BOUNDS_CHECK


43 #include 
	~<assert.h
>

47 class 
	cMV_ColMat_float


49 
	mprivate
:

50 
MV_Vector_float
 
v_
;

51 int 
	mdim0_
;

52 int 
	mdim1_
;

53 int 
	mlda_
;

54 int 
	mref_
;

57 
	mpublic
:

63 
MV_ColMat_float
();

64 
MV_ColMat_float
( int, int);

67 
MV_ColMat_float
( int, int, const float&);

72 
MV_ColMat_float
(float*, int 
m
, int 
n
);

73 
MV_ColMat_float
(float*, int 
m
, int 
n
, int 
lda
);

78 
MV_ColMat_float
(MV_ColMat_float &
A
, 
MV_Matrix_
::
ref_type
 
i
);

79 
MV_ColMat_float
(float*, int 
m
, int 
n
, 
MV_Matrix_
::
ref_type
 
i
);

80 
MV_ColMat_float
(float*, int 
m
, int 
n
, int 
lda
,

81 
MV_Matrix_
::
ref_type
 
i
);

83 
MV_ColMat_float
(const MV_ColMat_float&);

84 ~
MV_ColMat_float
();

90 
inline
 float& 
	$operator
()( int, int);

91 
inline
 const float& 
	$operator
()( int, int) const;

92 
MV_ColMat_float
 
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
) ;

93 const 
MV_ColMat_float
 
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
) const;

94 int 
	$dim
(int 
i
) const;

95 int 
	$lda
(void) const{ return 
lda_
; }

96 int 
	$size
(int 
i
) const { return 
	`dim
(i);
	}
}

97 
	gMV_ColMat_float
& 
newsize
( int, int);

98 int 
	$ref
() const { return 
ref_
;
	}
}

104 
	gMV_ColMat_float
 & 
	goperator
=(const 
MV_ColMat_float
&);

105 
	gMV_ColMat_float
 & 
	goperator
=(const float&);

108 
friend
 
	gstd
::
ostream
& 
operator
<<(
std
::ostream &
s
, const 
	gMV_ColMat_float
 &
	gA
);

112 
inline
 float& 
	gMV_ColMat_float
::
	$operator
()( int 
i
, int 
j
)

114 #ifdef 
MV_MATRIX_BOUNDS_CHECK


115 
	`assert
(0<=
i
 && i<
	`dim
(0));

116 
	`assert
(0<=
j
 && j<
	`dim
(1));

118 return 
	`v_
(
j
*
lda_
 + 
i
);

120 
	}
}

122 
inline
 const float& 
	gMV_ColMat_float
::
	$operator
()

123 ( int 
i
, int 
j
) const

125 #ifdef 
MV_MATRIX_BOUNDS_CHECK


126 
	`assert
(0<=
i
 && i<
	`dim
(0));

127 
	`assert
(0<=
j
 && j<
	`dim
(1));

129 return 
	`v_
(
j
*
lda_
 + 
i
);

130 
	}
}

132 
inline
 
	gMV_ColMat_float
::
MV_ColMat_float
(float* 
d
, int 
m
,

133 int 
n
, 
MV_Matrix_
::
ref_type
 
i
 ):

134 
v_
(
d
,
m
*
n
, 
MV_Vector_
::
ref
), 
dim0_
(m), 
dim1_
(n), 
lda_
(m), 
	$ref_
(
i
) {
	}
}

136 
inline
 
	gMV_ColMat_float
::
MV_ColMat_float
( MV_ColMat_float &
A
,

137 
MV_Matrix_
::
ref_type
 
i
 ):

138 
v_
(&
A
(0,0), A.
dim
(0)*A.dim(1), 
MV_Vector_
::
ref
),

139 
dim0_
(
A
.
dim
(0)), 
dim1_
(A.dim(1)), 
lda_
(A.
lda
()), 
	$ref_
(
i
) {
	}
}

141 
inline
 
	gMV_ColMat_float
::
MV_ColMat_float
(float* 
d
, int 
m
, int 
n
,

142 int 
lda
, 
MV_Matrix_
::
ref_type
 
i
) :

143 
v_
(
d
, 
lda
*
n
, 
MV_Vector_
::
ref
), 
dim0_
(
m
), 
dim1_
(n), 
lda_
(lda),

144 
	$ref_
(
i
) {
	}
}

	@mv/include/mvmi.h

33 #ifndef 
_MV_MATRIX_int_H_


34 #define 
	#_MV_MATRIX_int_H_


	)

36 #include 
	~"mvvi.h
"

37 #include 
	~"mvmrf.h
"

41 #include 
	~<iostream
>

42 #ifdef 
MV_MATRIX_BOUNDS_CHECK


43 #include 
	~<assert.h
>

47 class 
	cMV_ColMat_int


49 
	mprivate
:

50 
MV_Vector_int
 
v_
;

51 int 
	mdim0_
;

52 int 
	mdim1_
;

53 int 
	mlda_
;

54 int 
	mref_
;

57 
	mpublic
:

63 
MV_ColMat_int
();

64 
MV_ColMat_int
( int, int);

67 
MV_ColMat_int
( int, int, const int&);

72 
MV_ColMat_int
(int*, int 
m
, int 
n
);

73 
MV_ColMat_int
(int*, int 
m
, int 
n
, int 
lda
);

78 
MV_ColMat_int
(MV_ColMat_int &
A
, 
MV_Matrix_
::
ref_type
 
i
);

79 
MV_ColMat_int
(int*, int 
m
, int 
n
, 
MV_Matrix_
::
ref_type
 
i
);

80 
MV_ColMat_int
(int*, int 
m
, int 
n
, int 
lda
,

81 
MV_Matrix_
::
ref_type
 
i
);

83 
MV_ColMat_int
(const MV_ColMat_int&);

84 ~
MV_ColMat_int
();

90 
inline
 int& 
	$operator
()( int, int);

91 
inline
 const int& 
	$operator
()( int, int) const;

92 
MV_ColMat_int
 
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
) ;

93 const 
MV_ColMat_int
 
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
) const;

94 int 
	$dim
(int 
i
) const;

95 int 
	$lda
(void) const{ return 
lda_
; }

96 int 
	$size
(int 
i
) const { return 
	`dim
(i);
	}
}

97 
	gMV_ColMat_int
& 
newsize
( int, int);

98 int 
	$ref
() const { return 
ref_
;
	}
}

104 
	gMV_ColMat_int
 & 
	goperator
=(const 
MV_ColMat_int
&);

105 
	gMV_ColMat_int
 & 
	goperator
=(const int&);

108 
friend
 
	gstd
::
ostream
& 
operator
<<(
std
::ostream &
s
, const 
	gMV_ColMat_int
 &
	gA
);

112 
inline
 int& 
	gMV_ColMat_int
::
	$operator
()( int 
i
, int 
j
)

114 #ifdef 
MV_MATRIX_BOUNDS_CHECK


115 
	`assert
(0<=
i
 && i<
	`dim
(0));

116 
	`assert
(0<=
j
 && j<
	`dim
(1));

118 return 
	`v_
(
j
*
lda_
 + 
i
);

120 
	}
}

122 
inline
 const int& 
	gMV_ColMat_int
::
	$operator
()

123 ( int 
i
, int 
j
) const

125 #ifdef 
MV_MATRIX_BOUNDS_CHECK


126 
	`assert
(0<=
i
 && i<
	`dim
(0));

127 
	`assert
(0<=
j
 && j<
	`dim
(1));

129 return 
	`v_
(
j
*
lda_
 + 
i
);

130 
	}
}

132 
inline
 
	gMV_ColMat_int
::
MV_ColMat_int
(int* 
d
, int 
m
,

133 int 
n
, 
MV_Matrix_
::
ref_type
 
i
 ):

134 
v_
(
d
,
m
*
n
, 
MV_Vector_
::
ref
), 
dim0_
(m), 
dim1_
(n), 
lda_
(m), 
	$ref_
(
i
) {
	}
}

136 
inline
 
	gMV_ColMat_int
::
MV_ColMat_int
( MV_ColMat_int &
A
,

137 
MV_Matrix_
::
ref_type
 
i
 ):

138 
v_
(&
A
(0,0), A.
dim
(0)*A.dim(1), 
MV_Vector_
::
ref
),

139 
dim0_
(
A
.
dim
(0)), 
dim1_
(A.dim(1)), 
lda_
(A.
lda
()), 
	$ref_
(
i
) {
	}
}

141 
inline
 
	gMV_ColMat_int
::
MV_ColMat_int
(int* 
d
, int 
m
, int 
n
,

142 int 
lda
, 
MV_Matrix_
::
ref_type
 
i
) :

143 
v_
(
d
, 
lda
*
n
, 
MV_Vector_
::
ref
), 
dim0_
(
m
), 
dim1_
(n), 
lda_
(lda),

144 
	$ref_
(
i
) {
	}
}

	@mv/include/mvmrf.h

31 #ifndef 
_MV_MATRIX_REF_


32 #define 
	#_MV_MATRIX_REF_


	)

33 struct 
	sMV_Matrix_


35 enum 
	eref_type
 { 
	mref
 = 1};

	@mv/include/mvmt.h

33 #ifndef 
_MV_MATRIX_$TYPE_H_


34 #define 
	#_MV_MATRIX_$TYPE_H_


	)

36 #include 
	~"$INCLUDE
"

37 #include 
	~"mvmrf.h
"

41 #include 
	~<sstream
>

42 #ifdef 
MV_MATRIX_BOUNDS_CHECK


43 #include 
	~<assert.h
>

47 class 
	cMV_ColMat_$TYPE


49 
	mprivate
:

50 
MV_Vector_$TYPE
 
v_
;

51 int 
	mdim0_
;

52 int 
	mdim1_
;

53 int 
	mlda_
;

54 int 
	mref_
;

57 
	mpublic
:

63 
MV_ColMat_$TYPE
();

64 
MV_ColMat_$TYPE
( int, int);

67 
MV_ColMat_$TYPE
( int, int, const 
$TYPE
&);

72 
MV_ColMat_$TYPE
(
$TYPE
*, int 
m
, int 
n
);

73 
MV_ColMat_$TYPE
(
$TYPE
*, int 
m
, int 
n
, int 
lda
);

78 
MV_ColMat_$TYPE
(MV_ColMat_$TYPE &
A
, 
MV_Matrix_
::
ref_type
 
i
);

79 
MV_ColMat_$TYPE
(
$TYPE
*, int 
m
, int 
n
, 
MV_Matrix_
::
ref_type
 
i
);

80 
MV_ColMat_$TYPE
(
$TYPE
*, int 
m
, int 
n
, int 
lda
,

81 
MV_Matrix_
::
ref_type
 
i
);

83 
MV_ColMat_$TYPE
(const MV_ColMat_$TYPE&);

84 ~
MV_ColMat_$TYPE
();

90 
inline
 
	m$TYPE
& 
	$operator
()( int, int);

91 
inline
 const 
$TYPE
& 
	$operator
()( int, int) const;

92 
MV_ColMat_$TYPE
 
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
) ;

93 const 
MV_ColMat_$TYPE
 
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
) const;

94 int 
	$dim
(int 
i
) const;

95 int 
	$lda
(void) const{ return 
lda_
; }

96 int 
	$size
(int 
i
) const { return 
	`dim
(i);
	}
}

97 
	gMV_ColMat_$TYPE
& 
newsize
( int, int);

98 int 
	$ref
() const { return 
ref_
;
	}
}

104 
	gMV_ColMat_$TYPE
 & 
	goperator
=(const 
MV_ColMat_$TYPE
&);

105 
	gMV_ColMat_$TYPE
 & 
	goperator
=(const 
$TYPE
&);

108 
friend
 
	gstd
::
ostream
& 
operator
<<(
std
::ostream &
s
, const 
	gMV_ColMat_$TYPE
 &
	gA
);

112 
inline
 
	g$TYPE
& 
	gMV_ColMat_$TYPE
::
	$operator
()( int 
i
, int 
j
)

114 #ifdef 
MV_MATRIX_BOUNDS_CHECK


115 
	`assert
(0<=
i
 && i<
	`dim
(0));

116 
	`assert
(0<=
j
 && j<
	`dim
(1));

118 return 
	`v_
(
j
*
lda_
 + 
i
);

120 
	}
}

122 
inline
 const 
	g$TYPE
& 
	gMV_ColMat_$TYPE
::
	$operator
()

123 ( int 
i
, int 
j
) const

125 #ifdef 
MV_MATRIX_BOUNDS_CHECK


126 
	`assert
(0<=
i
 && i<
	`dim
(0));

127 
	`assert
(0<=
j
 && j<
	`dim
(1));

129 return 
	`v_
(
j
*
lda_
 + 
i
);

130 
	}
}

132 
inline
 
	gMV_ColMat_$TYPE
::
MV_ColMat_$TYPE
(
$TYPE
* 
d
, int 
m
,

133 int 
n
, 
MV_Matrix_
::
ref_type
 
i
 ):

134 
v_
(
d
,
m
*
n
, 
MV_Vector_
::
ref
), 
dim0_
(m), 
dim1_
(n), 
lda_
(m), 
	$ref_
(
i
) {
	}
}

136 
inline
 
	gMV_ColMat_$TYPE
::
MV_ColMat_$TYPE
( MV_ColMat_$TYPE &
A
,

137 
MV_Matrix_
::
ref_type
 
i
 ):

138 
v_
(&
A
(0,0), A.
dim
(0)*A.dim(1), 
MV_Vector_
::
ref
),

139 
dim0_
(
A
.
dim
(0)), 
dim1_
(A.dim(1)), 
lda_
(A.
lda
()), 
	$ref_
(
i
) {
	}
}

141 
inline
 
	gMV_ColMat_$TYPE
::
MV_ColMat_$TYPE
(
$TYPE
* 
d
, int 
m
, int 
n
,

142 int 
lda
, 
MV_Matrix_
::
ref_type
 
i
) :

143 
v_
(
d
, 
lda
*
n
, 
MV_Vector_
::
ref
), 
dim0_
(
m
), 
dim1_
(n), 
lda_
(lda),

144 
	$ref_
(
i
) {
	}
}

	@mv/include/mvmtp.h

33 #ifndef 
_MV_MATRIX_H_


34 #define 
	#_MV_MATRIX_H_


	)

36 #include 
	~"mvvtp.h
"

38 struct 
	sMatrix_


40 enum 
	eref_type
 { 
	mref
 = 1 };

44 #include 
	~<iostream
>

45 #ifdef 
MV_MATRIX_BOUNDS_CHECK


46 #include 
	~<assert.h
>

50 
	gtemplate
 <
class
 
	gTYPE
>

51 class 
	cMV_ColMat


53 
	mprivate
:

54 
MV_Vector
<
TYPE
> 
v_
;

55 int 
	mdim0_
;

56 int 
	mdim1_
;

57 int 
	mlda_
;

58 int 
	mref_
;

61 
	mpublic
:

67 
MV_ColMat
();

68 
MV_ColMat
( int, int);

71 
MV_ColMat
( int, int, const 
TYPE
&);

76 
MV_ColMat
(
TYPE
*, int 
m
, int 
n
);

77 
MV_ColMat
(
TYPE
*, int 
m
, int 
n
, int 
lda
);

82 
MV_ColMat
(
TYPE
*, int 
m
, int 
n
, 
Matrix_
::
ref_type
 
i
);

83 
MV_ColMat
(
TYPE
*, int 
m
, int 
n
, int 
lda
,

84 
Matrix_
::
ref_type
 
i
);

86 
MV_ColMat
(const MV_ColMat<
TYPE
>&);

87 ~
MV_ColMat
();

93 
inline
 
	mTYPE
& 
	$operator
()( int, int);

94 
inline
 const 
TYPE
& 
	$operator
()( int, int) const;

95 
MV_ColMat
<
TYPE
> 
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
) ;

96 const 
MV_ColMat
<
TYPE
> 
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
) const;

97 int 
	$size
(int 
i
) const;

98 
MV_ColMat
<
TYPE
>& 
	`newsize
( int, int);

99 int 
	$ref
() const { return 
ref_
;}

105 
MV_ColMat
<
TYPE
> & 
operator
=(const MV_ColMat<TYPE>&);

106 
MV_ColMat
<
TYPE
> & 
operator
=(const TYPE&);

109 
friend
 
std
::
ostream
& 
operator
<<(std::ostream &
s
, const 
MV_ColMat
<
TYPE
> &
A
);

111 
	}
};

115 
	gtemplate
<
class
 
	gTYPE
>

116 int 
	gMV_ColMat
<
	gTYPE
>::
	$size
(int 
i
) const

118 if (
i
==0) return 
dim0_
;

119 if (
i
==1) return 
dim1_
;

122 
cerr
 << "Called MV_ColMat::size(" << 
i
 << ") must be 0 or 1 " << 
endl
;

123 
	`exit
(1);

129 
	}
}

133 
	gtemplate
 <
class
 
	gTYPE
>

134 
	gMV_ColMat
<
	gTYPE
>::
	$MV_ColMat
() : 
	`v_
(), 
	`dim0_
(0), 
	`dim1_
(0) , 
	`lda_
(0), 
	$ref_
(0){
	}
}

137 
	gtemplate
 <
class
 
	gTYPE
>

138 
	gMV_ColMat
<
	gTYPE
>::
	$MV_ColMat
( int 
m
, int 
n
) : 
	`v_
(m*n),

139 
	`dim0_
(
m
), 
	`dim1_
(
n
), 
	`lda_
(m), 
	$ref_
(0) {
	}
}

141 
	gtemplate
 <
class
 
	gTYPE
>

142 
	gMV_ColMat
<
	gTYPE
>::
	$MV_ColMat
( int 
m
, int 
n
, const 
TYPE
 &
s
) : 
	`v_
(m*n),

143 
	`dim0_
(
m
), 
	`dim1_
(
n
), 
	`lda_
(m), 
	$ref_
(0)

145 
operator
=(
s
);

146 
	}
}

152 
	gtemplate
 <
class
 
	gTYPE
>

153 
inline
 
	gTYPE
& 
	gMV_ColMat
<TYPE>::
	$operator
()( int 
i
, int 
j
)

155 #ifdef 
MV_MATRIX_BOUNDS_CHECK


156 
	`assert
(0<=
i
 && i<
	`size
(0));

157 
	`assert
(0<=
j
 && j<
	`size
(1));

159 return 
	`v_
(
j
*
lda_
 + 
i
);

161 
	}
}

163 
	gtemplate
 <
class
 
	gTYPE
>

164 
inline
 const 
	gTYPE
& 
	gMV_ColMat
<TYPE>::
	$operator
()

165 ( int 
i
, int 
j
) const

167 #ifdef 
MV_MATRIX_BOUNDS_CHECK


168 
	`assert
(0<=
i
 && i<
	`size
(0));

169 
	`assert
(0<=
j
 && j<
	`size
(1));

171 return 
	`v_
(
j
*
lda_
 + 
i
);

172 
	}
}

175 
	gtemplate
 <
class
 
	gTYPE
>

176 
	gMV_ColMat
<
	gTYPE
>& MV_ColMat<TYPE>::
operator
=(const 
TYPE
 & 
s
)

178 int 
M
 = 
size
(0);

179 int 
	gN
 = 
size
(1);

181 if (
	glda_
 == 
M
)

182 
v_
 = 
s
;

190 
MV_VecIndex
 
I
(0,
M
-1);

191 for (int 
	gj
=0; j<
	gN
; j++)

193 
v_
(
I
) = 
s
;

194 
	gI
 += 
lda_
;

198 return *
	gthis
;

201 
	gtemplate
 <
class
 
	gTYPE
>

202 
	gMV_ColMat
<
	gTYPE
>& MV_ColMat<TYPE>::
	$newsize
( int 
M
, int 
N
)

204 
v_
.
	`newsize
(
M
*
N
);

205 
dim0_
 = 
M
;

206 
dim1_
 = 
N
;

207 
lda_
 = 
M
;

209 return *
this
;

210 
	}
}

212 
	gtemplate
 <
class
 
	gTYPE
>

213 
	gMV_ColMat
<
	gTYPE
>& MV_ColMat<TYPE>::
operator
=(const 
MV_ColMat
<
TYPE
> & 
m
)

216 int 
lM
 = 
dim0_
;

217 int 
	glN
 = 
dim1_
;

219 int 
	grM
 = 
m
.
dim0_
;

220 int 
	grN
 = 
m
.
dim1_
;

227 if (
	gref_
)

230 if (
	glM
 != 
rM
 || 
lN
 != 
rN
)

232 
cerr
 << "MV_ColMatRef::operator= non-conformant assignment.\n";

233 
exit
(1);

238 
newsize
(
rM
,
rN
);

247 if ( 
	glM
 == 
lda_
 && 
rM
 == 
m
.lda_)

249 
MV_VecIndex
 
I
(0,
rM
*
rN
-1);

250 
v_
(
I
) = 
m
.v_(I);

256 
MV_VecIndex
 
I
(0,
rM
-1);

257 
MV_VecIndex
 
K
(0,
rM
-1);

258 for (int 
	gj
=0; j<
	grN
; j++)

260 
v_
(
I
) = 
m
.v_(
K
);

261 
	gI
 += 
lda_
;

262 
	gK
 += 
m
.
lda_
;

266 return *
	gthis
;

269 
	gtemplate
 <
class
 
	gTYPE
>

270 
	gMV_ColMat
<
	gTYPE
>::
MV_ColMat
(const MV_ColMat<
TYPE
> & 
m
) :

271 
v_
(
m
.
dim0_
*m.
dim1_
), dim0_(m.dim0_),

272 
dim1_
(
m
.dim1_), 
ref_
(0), 
	$lda_
(
m
.
dim0_
)

275 int 
M
 = 
m
.
dim0_
;

276 int 
N
 = 
m
.
dim1_
;

281 
MV_VecIndex
 
	`I
(0,
M
-1);

282 
MV_VecIndex
 
	`K
(0,
M
-1);

283 for (int 
j
=0; j<
N
; j++)

285 
	`v_
(
I
) = 
m
.v_(
K
);

286 
I
 += 
lda_
;

287 
K
 += 
m
.
lda_
;

289 
	}
}

292 
	gtemplate
 <
class
 
	gTYPE
>

293 
inline
 
	gMV_ColMat
<
	gTYPE
>::
MV_ColMat
(
TYPE
* 
d
, int 
m
, int 
n
,

294 
Matrix_
::
ref_type
 
i
 ):

295 
v_
(
d
,
m
*
n
, 
MV_Vector_
::
ref
), 
dim0_
(m), 
dim1_
(n), 
lda_
(m), 
	$ref_
(
i
) {
	}
}

297 
	gtemplate
 <
class
 
	gTYPE
>

298 
inline
 
	gMV_ColMat
<
	gTYPE
>::
MV_ColMat
(
TYPE
* 
d
, int 
m
, int 
n
,

299 int 
lda
, 
Matrix_
::
ref_type
 
i
) :

300 
v_
(
d
, 
lda
*
n
, 
MV_Vector_
::
ref
), 
dim0_
(
m
), 
dim1_
(n), 
lda_
(lda),

301 
	$ref_
(
i
) {
	}
}

303 
	gtemplate
 <
class
 
	gTYPE
>

304 
	gMV_ColMat
<
	gTYPE
>::
	$MV_ColMat
(
TYPE
* 
d
, int 
m
, int 
n
) :

305 
	`v_
(
m
*
n
), 
	`dim0_
(m), 
	`dim1_
(n), 
	`lda_
(m), 
	$ref_
(0)

307 int 
mn
 = 
m
*
n
;

310 for (int 
i
=0; i< 
mn
; i++)

311 
v_
[
i
] = 
d
[i];

312 
	}
}

315 
	gtemplate
 <
class
 
	gTYPE
>

316 
	gMV_ColMat
<
	gTYPE
>::
	$MV_ColMat
(
TYPE
* 
d
, int 
m
, int 
n
,

317 int 
lda
) :

318 
	`v_
(
m
*
n
), 
	`dim0_
(m), 
	`dim1_
(n), 
	`lda_
(
lda
), 
	$ref_
(0)

320 for (int 
j
=0; j< 
n
; j++)

321 for (int 
i
=0; i<
m
; i++)

322 
	`operator
()(
i
,
j
) = 
d
[j*
lda
 + i];

323 
	}
}

326 
	gtemplate
 <
class
 
	gTYPE
>

327 
	gMV_ColMat
<
	gTYPE
> MV_ColMat<TYPE>::
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
)

331 if (
I
.
	`end
() >= 
dim0_
 || 
J
.end() >= 
dim1_
)

333 
cerr
 << "Matrix index: (" << 
I
.
	`start
() << ":" << I.
	`end
()

334 << "," << 
J
.
	`start
() << ":" << J.
	`end
()

335 << ") not a subset of (0:" << 
dim0_
 - 1 << ", 0:"

336 << 
dim1_
-1 << ") " << 
endl
;

337 
	`exit
(1);

342 return 
MV_ColMat
<
TYPE
>(&
v_
[
J
.
	`start
()*
lda_
 + 
I
.start()],

343 
I
.
	`end
() - I.
	`start
() + 1,

344 
J
.
	`end
() - J.
	`start
() + 1, 
lda_
, 
Matrix_
::
ref
);

345 
	}
}

347 
	gtemplate
 <
class
 
	gTYPE
>

348 const 
	gMV_ColMat
<
	gTYPE
> MV_ColMat<TYPE>::
	$operator
()(const 
MV_VecIndex
 &
I
,

349 const 
MV_VecIndex
 &
J
) const

352 
cerr
 << "Const operator()(MV_VecIndex, MV_VecIndex) called " << 
endl
;

356 if (
I
.
	`end
() >= 
dim0_
 || 
J
.end() >= 
dim1_
)

358 
cerr
 << "Matrix index: (" << 
I
.
	`start
() << ":" << I.
	`end
()

359 << "," << 
J
.
	`start
() << ":" << J.
	`end
()

360 << ") not a subset of (0:" << 
dim0_
 - 1 << ", 0:"

361 << 
dim1_
-1 << ") " << 
endl
;

362 
	`exit
(1);

369 
MV_ColMat
<
TYPE
> *
t
 = (MV_ColMat<TYPE>*) 
this
;

370 return 
MV_ColMat
<
TYPE
>(&(
t
->
v_
[
J
.
	`start
()*
lda_
 + 
I
.start()]),

371 
I
.
	`end
() - I.
	`start
() + 1,

372 
J
.
	`end
() - J.
	`start
() + 1, 
lda_
, 
Matrix_
::
ref
);

373 
	}
}

375 
	gtemplate
 <
class
 
	gTYPE
>

376 
	gMV_ColMat
<
	gTYPE
>::~
	$MV_ColMat
() {
	}
}

378 
template
 <
class
 
TYPE
>

379 
ostream
& 
operator
<<(ostream& 
s
, const 
	gMV_ColMat
<
	gTYPE
>& 
	gV
)

381 int 
	gM
 = 
V
.
size
(0);

382 int 
	gN
 = 
V
.
size
(1);

384 for (int 
	gi
=0; i<
	gM
; i++)

386 for (int 
	gj
=0; j<
	gN
; j++)

387 
	gs
 << 
V
(
i
,
j
) << " " ;

388 
	gs
 << 
	gendl
;

391 return 
	gs
;

	@mv/include/mvv.h

31 #ifndef 
_MV_VECTOR_ALL_H_


32 #define 
	#_MV_VECTOR_ALL_H_


	)

34 #include 
	~"mvvrf.h
"

35 #include 
	~"mvvd.h
"

36 #include 
	~"mvvi.h
"

37 #include 
	~"mvvf.h
"

39 #include 
	~"mvblasf.h
"

40 #include 
	~"mvblasd.h
"

41 #include 
	~"mvblasi.h
"

43 #include 
	~<complex
>

44 #include 
	~"mvvc.h
"

45 #include 
	~"mvblasc.h
"

46 #include 
	~"iotext.h
"

	@mv/include/mvvc.h

29 #ifndef 
_MV_VECTOR_COMPLEX_H


30 #define 
	#_MV_VECTOR_COMPLEX_H


	)

34 #include 
	~<stdlib.h
>

36 #include 
	~<sstream
>

39 #ifdef 
MV_VECTOR_BOUNDS_CHECK


40 #include 
	~<assert.h
>

43 #include 
	~"mvvind.h
"

51 #include 
	~"mvvrf.h
"

53 class 
	cMV_Vector_COMPLEX


55 
	mprotected
:

56 
COMPLEX
 *
p_
;

57 int 
	mdim_
;

58 int 
	mref_
;

59 
	mpublic
:

66 
MV_Vector_COMPLEX
();

67 
MV_Vector_COMPLEX
( int);

68 
MV_Vector_COMPLEX
( int, const 
COMPLEX
&);

71 
MV_Vector_COMPLEX
(
COMPLEX
*, int);

72 
MV_Vector_COMPLEX
(const 
COMPLEX
*, int);

73 
MV_Vector_COMPLEX
(const MV_Vector_COMPLEX &);

82 
MV_Vector_COMPLEX
(
COMPLEX
* 
d
, int 
N
, 
MV_Vector_
::
ref_type
 
i
) :

83 
p_
(
d
), 
dim_
(
N
), 
	$ref_
(
i
) {}

85 
	`MV_Vector_COMPLEX
(const 
MV_Vector_COMPLEX
 &
V
, 
MV_Vector_
::
ref_type
 
i
) :

86 
	`p_
(
V
.
p_
), 
	`dim_
(V.
dim_
), 
	$ref_
(
i
) {
	}
}

88 ~
MV_Vector_COMPLEX
();

95 
	gCOMPLEX
& 
	$operator
()( int 
i
)

97 #ifdef 
MV_VECTOR_BOUNDS_CHECK


98 
	`assert
(
i
 < 
dim_
);

100 return 
p_
[
i
];

101 
	}
}

102 const 
	gCOMPLEX
& 
	$operator
()( int 
i
) const

104 #ifdef 
MV_VECTOR_BOUNDS_CHECK


105 
	`assert
(
i
 < 
dim_
);

107 return 
p_
[
i
];

108 
	}
}

110 
	gCOMPLEX
& 
	goperator
[]( int 
	gi
)

112 #ifdef 
MV_VECTOR_BOUNDS_CHECK


113 
assert
(
i
 < 
dim_
);

115 return 
	gp_
[
i
];

117 const 
	gCOMPLEX
& 
	goperator
[]( int 
	gi
) const

119 #ifdef 
MV_VECTOR_BOUNDS_CHECK


120 
assert
(
i
 < 
dim_
);

122 return 
	gp_
[
i
];

126 
MV_Vector_COMPLEX
 
	$operator
()(const 
MV_VecIndex
 &
I
) ;

127 
MV_Vector_COMPLEX
 
	$operator
()(void);

128 const 
MV_Vector_COMPLEX
 
	$operator
()(void) const;

129 const 
MV_Vector_COMPLEX
 
	$operator
()(const 
MV_VecIndex
 &
I
) const;

131 
inline
 int 
	$size
() const { return 
dim_
;
	}
}

132 
inline
 int 
	$dim
() const { return 
dim_
;
	}
}

133 
inline
 int 
	$ref
() const { return 
ref_
;
	}
}

134 
inline
 int 
	$null
() const {return 
dim_
== 0;
	}
}

137 
	gMV_Vector_COMPLEX
 & 
newsize
( int );

143 
	gMV_Vector_COMPLEX
 & 
	goperator
=(const 
MV_Vector_COMPLEX
&);

144 
	gMV_Vector_COMPLEX
 & 
	goperator
=(const 
COMPLEX
&);

147 
friend
 
	gstd
::
ostream
& 
operator
<<(
std
::ostream &
s
,

148 const 
	gMV_Vector_COMPLEX
 &
	gA
);

	@mv/include/mvvd.h

29 #ifndef 
_MV_VECTOR_double_H


30 #define 
	#_MV_VECTOR_double_H


	)

34 #include 
	~<stdlib.h
>

37 #include 
	~<sstream
>

40 #ifdef 
MV_VECTOR_BOUNDS_CHECK


41 #include 
	~<assert.h
>

44 #include 
	~"mvvind.h
"

52 #include 
	~"mvvrf.h
"

54 class 
	cMV_Vector_double


56 
	mprotected
:

57 double *
p_
;

58 int 
	mdim_
;

59 int 
	mref_
;

60 
	mpublic
:

67 
MV_Vector_double
();

68 
MV_Vector_double
( int);

69 
MV_Vector_double
( int, const double&);

72 
MV_Vector_double
(double*, int);

73 
MV_Vector_double
(const double*, int);

74 
MV_Vector_double
(const MV_Vector_double &);

83 
MV_Vector_double
(double* 
d
, int 
N
, 
MV_Vector_
::
ref_type
 
i
) :

84 
p_
(
d
), 
dim_
(
N
), 
	$ref_
(
i
) {}

86 
	`MV_Vector_double
(const 
MV_Vector_double
 &
V
, 
MV_Vector_
::
ref_type
 
i
) :

87 
	`p_
(
V
.
p_
), 
	`dim_
(V.
dim_
), 
	$ref_
(
i
) {
	}
}

89 ~
MV_Vector_double
();

96 double& 
	$operator
()( int 
i
)

98 #ifdef 
MV_VECTOR_BOUNDS_CHECK


99 
	`assert
(
i
 < 
dim_
);

101 return 
p_
[
i
];

102 
	}
}

103 const double& 
	$operator
()( int 
i
) const

105 #ifdef 
MV_VECTOR_BOUNDS_CHECK


106 
	`assert
(
i
 < 
dim_
);

108 return 
p_
[
i
];

109 
	}
}

111 double& 
	goperator
[]( int 
	gi
)

113 #ifdef 
MV_VECTOR_BOUNDS_CHECK


114 
assert
(
i
 < 
dim_
);

116 return 
	gp_
[
i
];

118 const double& 
	goperator
[]( int 
	gi
) const

120 #ifdef 
MV_VECTOR_BOUNDS_CHECK


121 
assert
(
i
 < 
dim_
);

123 return 
	gp_
[
i
];

127 
MV_Vector_double
 
	$operator
()(const 
MV_VecIndex
 &
I
) ;

128 
MV_Vector_double
 
	$operator
()(void);

129 const 
MV_Vector_double
 
	$operator
()(void) const;

130 const 
MV_Vector_double
 
	$operator
()(const 
MV_VecIndex
 &
I
) const;

132 
inline
 int 
	$size
() const { return 
dim_
;
	}
}

133 
inline
 int 
	$dim
() const { return 
dim_
;
	}
}

134 
inline
 int 
	$ref
() const { return 
ref_
;
	}
}

135 
inline
 int 
	$null
() const {return 
dim_
== 0;
	}
}

138 
	gMV_Vector_double
 & 
newsize
( int );

144 
	gMV_Vector_double
 & 
	goperator
=(const 
MV_Vector_double
&);

145 
	gMV_Vector_double
 & 
	goperator
=(const double&);

148 
friend
 
	gstd
::
ostream
& 
operator
<<(
std
::ostream &
s
, const 
	gMV_Vector_double
 &
	gA
);

	@mv/include/mvvf.h

29 #ifndef 
_MV_VECTOR_float_H


30 #define 
	#_MV_VECTOR_float_H


	)

34 #include 
	~<stdlib.h
>

35 #include 
	~<sstream
>

38 #ifdef 
MV_VECTOR_BOUNDS_CHECK


39 #include 
	~<assert.h
>

42 #include 
	~"mvvind.h
"

50 #include 
	~"mvvrf.h
"

52 class 
	cMV_Vector_float


54 
	mprotected
:

55 float *
p_
;

56 int 
	mdim_
;

57 int 
	mref_
;

58 
	mpublic
:

65 
MV_Vector_float
();

66 
MV_Vector_float
( int);

67 
MV_Vector_float
( int, const float&);

70 
MV_Vector_float
(float*, int);

71 
MV_Vector_float
(const float*, int);

72 
MV_Vector_float
(const MV_Vector_float &);

81 
MV_Vector_float
(float* 
d
, int 
N
, 
MV_Vector_
::
ref_type
 
i
) :

82 
p_
(
d
), 
dim_
(
N
), 
	$ref_
(
i
) {}

84 
	`MV_Vector_float
(const 
MV_Vector_float
 &
V
, 
MV_Vector_
::
ref_type
 
i
) :

85 
	`p_
(
V
.
p_
), 
	`dim_
(V.
dim_
), 
	$ref_
(
i
) {
	}
}

87 ~
MV_Vector_float
();

94 float& 
	$operator
()( int 
i
)

96 #ifdef 
MV_VECTOR_BOUNDS_CHECK


97 
	`assert
(
i
 < 
dim_
);

99 return 
p_
[
i
];

100 
	}
}

101 const float& 
	$operator
()( int 
i
) const

103 #ifdef 
MV_VECTOR_BOUNDS_CHECK


104 
	`assert
(
i
 < 
dim_
);

106 return 
p_
[
i
];

107 
	}
}

109 float& 
	goperator
[]( int 
	gi
)

111 #ifdef 
MV_VECTOR_BOUNDS_CHECK


112 
assert
(
i
 < 
dim_
);

114 return 
	gp_
[
i
];

116 const float& 
	goperator
[]( int 
	gi
) const

118 #ifdef 
MV_VECTOR_BOUNDS_CHECK


119 
assert
(
i
 < 
dim_
);

121 return 
	gp_
[
i
];

125 
MV_Vector_float
 
	$operator
()(const 
MV_VecIndex
 &
I
) ;

126 
MV_Vector_float
 
	$operator
()(void);

127 const 
MV_Vector_float
 
	$operator
()(void) const;

128 const 
MV_Vector_float
 
	$operator
()(const 
MV_VecIndex
 &
I
) const;

130 
inline
 int 
	$size
() const { return 
dim_
;
	}
}

131 
inline
 int 
	$dim
() const { return 
dim_
;
	}
}

132 
inline
 int 
	$ref
() const { return 
ref_
;
	}
}

133 
inline
 int 
	$null
() const {return 
dim_
== 0;
	}
}

136 
	gMV_Vector_float
 & 
newsize
( int );

142 
	gMV_Vector_float
 & 
	goperator
=(const 
MV_Vector_float
&);

143 
	gMV_Vector_float
 & 
	goperator
=(const float&);

146 
friend
 
	gstd
::
ostream
& 
operator
<<(
std
::ostream &
s
, const 
	gMV_Vector_float
 &
	gA
);

	@mv/include/mvvi.h

29 #ifndef 
_MV_VECTOR_int_H


30 #define 
	#_MV_VECTOR_int_H


	)

34 #include 
	~<stdlib.h
>

35 #include 
	~<sstream
>

38 #ifdef 
MV_VECTOR_BOUNDS_CHECK


39 #include 
	~<assert.h
>

42 #include 
	~"mvvind.h
"

50 #include 
	~"mvvrf.h
"

52 class 
	cMV_Vector_int


54 
	mprotected
:

55 int *
p_
;

56 int 
	mdim_
;

57 int 
	mref_
;

58 
	mpublic
:

65 
MV_Vector_int
();

66 
MV_Vector_int
( int);

67 
MV_Vector_int
( int, const int&);

70 
MV_Vector_int
(int*, int);

71 
MV_Vector_int
(const int*, int);

72 
MV_Vector_int
(const MV_Vector_int &);

81 
MV_Vector_int
(int* 
d
, int 
N
, 
MV_Vector_
::
ref_type
 
i
) :

82 
p_
(
d
), 
dim_
(
N
), 
	$ref_
(
i
) {}

84 
	`MV_Vector_int
(const 
MV_Vector_int
 &
V
, 
MV_Vector_
::
ref_type
 
i
) :

85 
	`p_
(
V
.
p_
), 
	`dim_
(V.
dim_
), 
	$ref_
(
i
) {
	}
}

87 ~
MV_Vector_int
();

94 int& 
	$operator
()( int 
i
)

96 #ifdef 
MV_VECTOR_BOUNDS_CHECK


97 
	`assert
(
i
 < 
dim_
);

99 return 
p_
[
i
];

100 
	}
}

101 const int& 
	$operator
()( int 
i
) const

103 #ifdef 
MV_VECTOR_BOUNDS_CHECK


104 
	`assert
(
i
 < 
dim_
);

106 return 
p_
[
i
];

107 
	}
}

109 int& 
	goperator
[]( int 
	gi
)

111 #ifdef 
MV_VECTOR_BOUNDS_CHECK


112 
assert
(
i
 < 
dim_
);

114 return 
	gp_
[
i
];

116 const int& 
	goperator
[]( int 
	gi
) const

118 #ifdef 
MV_VECTOR_BOUNDS_CHECK


119 
assert
(
i
 < 
dim_
);

121 return 
	gp_
[
i
];

125 
MV_Vector_int
 
	$operator
()(const 
MV_VecIndex
 &
I
) ;

126 
MV_Vector_int
 
	$operator
()(void);

127 const 
MV_Vector_int
 
	$operator
()(void) const;

128 const 
MV_Vector_int
 
	$operator
()(const 
MV_VecIndex
 &
I
) const;

130 
inline
 int 
	$size
() const { return 
dim_
;
	}
}

131 
inline
 int 
	$dim
() const { return 
dim_
;
	}
}

132 
inline
 int 
	$ref
() const { return 
ref_
;
	}
}

133 
inline
 int 
	$null
() const {return 
dim_
== 0;
	}
}

136 
	gMV_Vector_int
 & 
newsize
( int );

142 
	gMV_Vector_int
 & 
	goperator
=(const 
MV_Vector_int
&);

143 
	gMV_Vector_int
 & 
	goperator
=(const int&);

146 
friend
 
	gstd
::
ostream
 & 
operator
<<(
std
::ostream &
s
, const 
	gMV_Vector_int
 &
	gA
);

	@mv/include/mvvind.h

28 #ifndef 
_MV_VEC_INDEX_H_


29 #define 
	#_MV_VEC_INDEX_H_


	)

43 #include 
	~<assert.h
>

45 class 
	cMV_VecIndex


47 
	mprivate
:

48 int 
start_
;

49 int 
	mend_
;

50 char 
	mall_
;

52 
	mpublic
:

53 
	$MV_VecIndex
() : 
	`start_
(0), 
	`end_
(0), 
	$all_
(1) {}

54 
	$MV_VecIndex
( int 
i1
) :
	`start_
(i1), 
	`end_
(i1), 
	$all_
(0) {
	}
}

55 
	$MV_VecIndex
( int 
i1
, int 
i2
): 
	`start_
(i1), 
	`end_
(i2),

56 
	$all_
(0)

58 
	`assert
(
i1
 <= 
i2
);

59 
	}
}

60 
	$MV_VecIndex
(const 
MV_VecIndex
 &
s
) : 
	`start_
(s.
start_
), 
	`end_
(s.
end_
),

61 
	$all_
(
s
.
all_
){
	}
}

64 int 
	$start
() const { return (
all_
==1) ? 0 : 
start_
;
	}
}

65 int 
	$end
() const { return (
all_
 ==1) ? 0 : 
end_
;
	}
}

66 int 
	$length
() const {

67 return (
all_
==1) ? 0 : (
end_
-
start_
+1);
	}
}

68 int 
	$all
() const { return 
all_
; 
	}
}

69 
	gMV_VecIndex
& 
	goperator
=(const 
MV_VecIndex
& 
I
)

70 { 
start_
=
I
.start_; 
	gend_
 = I.
end_
; return *
	gthis
;}

71 
MV_VecIndex
 
	goperator
+(int 
	gi
)

72 { return 
MV_VecIndex
(
start_
 +
i
, 
end_
 +i); }

73 
	gMV_VecIndex
& 
	goperator
+=(int 
i
)

74 { 
start_
 += 
i
; 
	gend_
 += i; return *
	gthis
; }

75 
MV_VecIndex
 
	goperator
-(int 
	gi
)

76 { return 
MV_VecIndex
(
start_
 -
i
, 
end_
 -i); }

77 
	gMV_VecIndex
& 
	goperator
-=(int 
i
)

78 { 
start_
 -= 
i
; 
	gend_
 -= i; return *
	gthis
; }

	@mv/include/mvvrf.h

31 #ifndef 
_MV_VECTOR_REF_


32 #define 
	#_MV_VECTOR_REF_


	)

33 struct 
	sMV_Vector_


35 enum 
	eref_type
 { 
	mref
 = 1};

	@mv/include/mvvt.h

29 #ifndef 
_MV_VECTOR_$TYPE_H


30 #define 
	#_MV_VECTOR_$TYPE_H


	)

34 #include 
	~<stdlib.h
>

35 #include 
	~<sstream
>

38 #ifdef 
MV_VECTOR_BOUNDS_CHECK


39 #include 
	~<assert.h
>

42 #include 
	~"mvvind.h
"

50 #include 
	~"mvvrf.h
"

52 class 
	cMV_Vector_$TYPE


54 
	mprotected
:

55 
$TYPE
 *
p_
;

56 int 
	mdim_
;

57 int 
	mref_
;

58 
	mpublic
:

65 
MV_Vector_$TYPE
();

66 
MV_Vector_$TYPE
( int);

67 
MV_Vector_$TYPE
( int, const 
$TYPE
&);

70 
MV_Vector_$TYPE
(
$TYPE
*, int);

71 
MV_Vector_$TYPE
(const 
$TYPE
*, int);

72 
MV_Vector_$TYPE
(const MV_Vector_$TYPE &);

81 
MV_Vector_$TYPE
(
$TYPE
* 
d
, int 
N
, 
MV_Vector_
::
ref_type
 
i
) :

82 
p_
(
d
), 
dim_
(
N
), 
	$ref_
(
i
) {}

84 
	`MV_Vector_$TYPE
(const 
MV_Vector_$TYPE
 &
V
, 
MV_Vector_
::
ref_type
 
i
) :

85 
	`p_
(
V
.
p_
), 
	`dim_
(V.
dim_
), 
	$ref_
(
i
) {
	}
}

87 ~
MV_Vector_$TYPE
();

94 
	g$TYPE
& 
	$operator
()( int 
i
)

96 #ifdef 
MV_VECTOR_BOUNDS_CHECK


97 
	`assert
(
i
 < 
dim_
);

99 return 
p_
[
i
];

100 
	}
}

101 const 
	g$TYPE
& 
	$operator
()( int 
i
) const

103 #ifdef 
MV_VECTOR_BOUNDS_CHECK


104 
	`assert
(
i
 < 
dim_
);

106 return 
p_
[
i
];

107 
	}
}

109 
	g$TYPE
& 
	goperator
[]( int 
	gi
)

111 #ifdef 
MV_VECTOR_BOUNDS_CHECK


112 
assert
(
i
 < 
dim_
);

114 return 
	gp_
[
i
];

116 const 
	g$TYPE
& 
	goperator
[]( int 
	gi
) const

118 #ifdef 
MV_VECTOR_BOUNDS_CHECK


119 
assert
(
i
 < 
dim_
);

121 return 
	gp_
[
i
];

125 
MV_Vector_$TYPE
 
	$operator
()(const 
MV_VecIndex
 &
I
) ;

126 
MV_Vector_$TYPE
 
	$operator
()(void);

127 const 
MV_Vector_$TYPE
 
	$operator
()(void) const;

128 const 
MV_Vector_$TYPE
 
	$operator
()(const 
MV_VecIndex
 &
I
) const;

130 
inline
 int 
	$size
() const { return 
dim_
;
	}
}

131 
inline
 int 
	$dim
() const { return 
dim_
;
	}
}

132 
inline
 int 
	$ref
() const { return 
ref_
;
	}
}

133 
inline
 int 
	$null
() const {return 
dim_
== 0;
	}
}

136 
	gMV_Vector_$TYPE
 & 
newsize
( int );

142 
	gMV_Vector_$TYPE
 & 
	goperator
=(const 
MV_Vector_$TYPE
&);

143 
	gMV_Vector_$TYPE
 & 
	goperator
=(const 
$TYPE
&);

146 
friend
 
	gstd
::
ostream
& 
operator
<<(
std
::ostream &
s
, const 
	gMV_Vector_$TYPE
 &
	gA
);

	@mv/include/mvvtp.h

29 #ifndef 
_MV_VECTOR_TPL_H_


30 #define 
	#_MV_VECTOR_TPL_H_


	)

32 #include 
	~<stdlib.h
>

33 #ifdef 
MV_VECTOR_BOUNDS_CHECK


34 #include 
	~<assert.h
>

37 #include 
	~"mvvind.h
"

38 #include 
	~"mvvrf.h
"

40 
	gtemplate
 <
class
 
	gTYPE
>

41 class 
	cMV_Vector


43 
	mprotected
:

44 
TYPE
 *
p_
;

45 int 
	mdim_
;

46 int 
	mref_
;

47 
	mpublic
:

54 
MV_Vector
();

55 
MV_Vector
( int);

56 
MV_Vector
( int, const 
TYPE
&);

58 
MV_Vector
(
TYPE
*, int);

59 
MV_Vector
(const 
TYPE
*, int);

63 
MV_Vector
(
TYPE
*, int, 
MV_Vector_
::
ref_type
 
i
);

64 
MV_Vector
(const MV_Vector<
TYPE
>&);

65 ~
MV_Vector
();

72 
inline
 
	mTYPE
& 
	$operator
()( int 
i
)

74 #ifdef 
MV_VECTOR_BOUNDS_CHECK


75 
	`assert
(
i
 < 
dim_
);

77 return 
p_
[
i
];

79 
inline
 const 
TYPE
& 
	$operator
()( int 
i
) const

81 #ifdef 
MV_VECTOR_BOUNDS_CHECK


82 
	`assert
(
i
 < 
dim_
);

84 return 
p_
[
i
];

85 
	}
}

87 
inline
 
	gTYPE
& 
	goperator
[]( int 
	gi
)

89 #ifdef 
MV_VECTOR_BOUNDS_CHECK


90 
assert
(
i
 < 
dim_
);

92 return 
	gp_
[
i
];

94 
inline
 const 
	gTYPE
& 
	goperator
[]( int 
	gi
) const

96 #ifdef 
MV_VECTOR_BOUNDS_CHECK


97 
assert
(
i
 < 
dim_
);

99 return 
	gp_
[
i
];

104 
inline
 
	gMV_Vector
<
	gTYPE
> 
	$operator
()(const 
MV_VecIndex
 &
I
) ;

105 
inline
 
MV_Vector
<
TYPE
> 
	$operator
()(void);

106 
inline
 const 
MV_Vector
<
TYPE
> 
	$operator
()(void) const;

107 
inline
 const 
MV_Vector
<
TYPE
> 
	$operator
()(const 
MV_VecIndex
 &
I
) const;

109 
inline
 int 
	$size
() const { return 
dim_
;
	}
}

110 
inline
 int 
	$ref
() const { return 
ref_
;
	}
}

111 
inline
 int 
	$null
() const {return 
dim_
== 0;
	}
}

114 
	gMV_Vector
<
	gTYPE
> & 
newsize
( int );

120 
	gMV_Vector
<
	gTYPE
> & 
	goperator
=(const 
MV_Vector
<
TYPE
>&);

121 
	gMV_Vector
<
	gTYPE
> & 
	goperator
=(const 
TYPE
&);

128 
	gtemplate
 <
class
 
	gTYPE
>

129 
	gMV_Vector
<
	gTYPE
>::
	$MV_Vector
() : 
	`p_
(0), 
	`dim_
(0) , 
	$ref_
(0){
	}
};

131 
	gtemplate
 <
class
 
	gTYPE
>

132 
	gMV_Vector
<
	gTYPE
>::
	$MV_Vector
( int 
n
) : 
	`p_
(
new
 
TYPE
[n]), 
	`dim_
(n),

133 
	$ref_
(0)

135 if (
p_
 == 
NULL
)

137 
cerr
 << "Error: NULL pointer in MV_Vector(int) constructor " << 
endl
;

138 
cerr
 << " Most likely out of memory... " << 
endl
;

139 
	`exit
(1);

141 
	}
}

143 
	gtemplate
 <
class
 
	gTYPE
>

144 
	gMV_Vector
<
	gTYPE
>::
	$MV_Vector
( int 
n
, const 
TYPE
& 
v
) :

145 
	`p_
(
new
 
TYPE
[
n
]), 
	`dim_
(n), 
	$ref_
(0)

147 if (
p_
 == 
NULL
)

149 
cerr
 << "Error: NULL pointer in MV_Vector(int) constructor " << 
endl
;

150 
cerr
 << " Most likely out of memory... " << 
endl
;

151 
	`exit
(1);

153 for (int 
i
=0; i<
n
; i++)

154 
p_
[
i
] = 
v
;

155 
	}
}

163 
	gtemplate
 <
class
 
	gTYPE
>

164 
	gMV_Vector
<
	gTYPE
>& MV_Vector<TYPE>::
operator
=(const 
TYPE
 & 
m
)

166 #ifdef 
TRACE_VEC


167 
cout
 << "> MV_Vector<TYPE>::operator=(const TYPE & m) " << 
endl
;

172 int 
	gN
 = 
size
();

174 int 
	gNminus4
 = 
N
-4;

175 int 
	gi
;

177 for (
	gi
=0; i<
	gNminus4
; )

179 
	gp_
[
i
++] = 
m
;

180 
	gp_
[
i
++] = 
m
;

181 
	gp_
[
i
++] = 
m
;

182 
	gp_
[
i
++] = 
m
;

185 for (; 
	gi
<
	gN
; 
	gp_
[
i
++] = 
m
);

187 #ifdef 
TRACE_VEC


188 
	gcout
 << "< MV_Vector<TYPE>::operator=(const TYPE & m) " << 
	gendl
;

190 return *
	gthis
;

193 
	gtemplate
 <
class
 
	gTYPE
>

194 
	gMV_Vector
<
	gTYPE
>& MV_Vector<TYPE>::
	$newsize
( int 
n
)

196 #ifdef 
TRACE_VEC


197 
cout
 << "> MV_Vector<TYPE>::newsize( int n) " << 
endl
;

199 if (
ref_
 )

202 
cerr
 << "MV_Vector::newsize can't operator on references.\n";

203 
	`exit
(1);

207 if (
dim_
 != 
n
 )

209 if (
p_
) 
delete
 [] p_;

210 
p_
 = 
new
 
TYPE
[
n
];

211 if (
p_
 == 
NULL
)

213 
cerr
 << "Error : NULL pointer in operator= " << 
endl
;

214 
	`exit
(1);

216 
dim_
 = 
n
;

219 #ifdef 
TRACE_VEC


220 
cout
 << "< MV_Vector<TYPE>::newsize( int n) " << 
endl
;

223 return *
this
;

224 
	}
}

229 
	gtemplate
 <
class
 
	gTYPE
>

230 
	gMV_Vector
<
	gTYPE
>& MV_Vector<TYPE>::
operator
=(const 
MV_Vector
<
TYPE
> & 
m
)

233 int 
N
 = 
m
.
dim_
;

234 int 
	gi
;

236 if (
	gref_
 )

238 if (
	gdim_
 != 
m
.
dim_
)

240 
cerr
 << "MV_VectorRef::operator= non-conformant assignment.\n";

241 
exit
(1);

245 if ((
	gm
.
	gp_
 + m.
	gdim_
) >= 
p_
)

248 for (
i
= 
N
-1; 
	gi
>=0; i--)

249 
	gp_
[
i
] = 
m
.
p_
[i];

253 for (
	gi
=0; i<
	gN
; i++)

254 
	gp_
[
i
] = 
m
.
p_
[i];

260 
newsize
(
N
);

263 for (
	gi
 =0; i< 
	gN
; i++)

264 
	gp_
[
i
] = 
m
.
p_
[i];

266 return *
	gthis
;

269 
	gtemplate
 <
class
 
	gTYPE
>

270 
	gMV_Vector
<
	gTYPE
>::
MV_Vector
(const MV_Vector<
TYPE
> & 
m
) : 
p_
(
new
 TYPE[m.
dim_
]),

271 
dim_
(
m
.dim_) , 
	$ref_
(0)

273 if (
p_
 == 
NULL
)

275 
cerr
 << "Error: Null pointer in MV_Vector(const MV_Vector&); " << 
endl
;

276 
	`exit
(1);

279 int 
N
 = 
m
.
dim_
;

281 for (int 
i
=0; i<
N
; i++)

282 
p_
[
i
] = 
m
.p_[i];

283 
	}
}

290 
	gtemplate
 <
class
 
	gTYPE
>

291 
	gMV_Vector
<
	gTYPE
>::
MV_Vector
(
TYPE
* 
d
, int 
n
, 
MV_Vector_
::
ref_type
 
i
) :

292 
p_
(
d
), 
dim_
(
n
) , 
	$ref_
(
i
) {
	}
}

294 
	gtemplate
 <
class
 
	gTYPE
>

295 
	gMV_Vector
<
	gTYPE
>::
	$MV_Vector
(
TYPE
* 
d
, int 
n
) : 
	`p_
(
new
 TYPE[n]),

296 
	`dim_
(
n
) , 
	$ref_
(0)

298 if (
p_
 == 
NULL
)

300 
cerr
 << "Error: Null pointer in MV_Vector(TYPE*, int) " << 
endl
;

301 
	`exit
(1);

303 for (int 
i
=0; i<
n
; i++)

304 
p_
[
i
] = 
d
[i];

306 
	}
}

309 
	gtemplate
 <
class
 
	gTYPE
>

310 
	gMV_Vector
<
	gTYPE
>::
	$MV_Vector
(const 
TYPE
* 
d
, int 
n
) : 
	`p_
(
new
 TYPE[n]),

311 
	`dim_
(
n
) , 
	$ref_
(0)

313 if (
p_
 == 
NULL
)

315 
cerr
 << "Error: Null pointer in MV_Vector(TYPE*, int) " << 
endl
;

316 
	`exit
(1);

318 for (int 
i
=0; i<
n
; i++)

319 
p_
[
i
] = 
d
[i];

321 
	}
}

323 
	gtemplate
 <
class
 
	gTYPE
>

324 
	gMV_Vector
<
	gTYPE
> MV_Vector<TYPE>::
	$operator
()(void)

326 return 
MV_Vector
<
TYPE
>(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

327 
	}
}

329 
	gtemplate
 <
class
 
	gTYPE
>

330 const 
	gMV_Vector
<
	gTYPE
> MV_Vector<TYPE>::
	$operator
()(void) const

332 return 
MV_Vector
<
TYPE
>(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

333 
	}
}

335 
	gtemplate
 <
class
 
	gTYPE
>

336 
	gMV_Vector
<
	gTYPE
> MV_Vector<TYPE>::
	$operator
()(const 
MV_VecIndex
 &
I
)

339 if (
I
.
	`all
())

340 return 
MV_Vector
<
TYPE
>(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

345 if ( 
I
.
	`end
() >= 
dim_
)

347 
cerr
 << "MV_VecIndex: (" << 
I
.
	`start
() << ":" << I.
	`end
() <<

348 ") too big for matrix (0:" << 
dim_
 - 1 << ") " << 
endl
;

349 
	`exit
(1);

351 return 
MV_Vector
<
TYPE
>(
p_
+ 
I
.
	`start
(), I.
	`end
() - I.start() + 1,

352 
MV_Vector_
::
ref
);

354 
	}
}

356 
	gtemplate
 <
class
 
	gTYPE
>

357 const 
	gMV_Vector
<
	gTYPE
> MV_Vector<TYPE>::
	$operator
()(const 
MV_VecIndex
 &
I
) const

361 if ( 
I
.
	`end
() >= 
dim_
)

363 
cerr
 << "MV_VecIndex: (" << 
I
.
	`start
() << ":" << I.
	`end
() <<

364 ") too big for matrix (0:" << 
dim_
 - 1 << ") " << 
endl
;

365 
	`exit
(1);

367 return 
MV_Vector
<
TYPE
>(
p_
+ 
I
.
	`start
(), I.
	`end
() - I.start() + 1,

368 
MV_Vector_
::
ref
);

369 
	}
}

371 
	gtemplate
 <
class
 
	gTYPE
>

372 
	gMV_Vector
<
	gTYPE
>::~
	$MV_Vector
()

374 if (
p_
 && !
ref_
 ) 
delete
 [] p_;

375 
	}
}

378 
	gtemplate
 <
class
 
	gTYPE
>

379 
class
 
	gFMV_Vector
 : 
public
 
MV_Vector
<
TYPE
>

381 
public
:

382 
FMV_Vector
( int 
n
) : 
MV_Vector
<
TYPE
>(n) {}

383 
FMV_Vector
<
TYPE
>& 
operator
=(const FMV_Vector<TYPE>& 
m
);

384 
	gFMV_Vector
<
	gTYPE
>& 
	goperator
=(const 
TYPE
& 
m
);

387 
	gtemplate
 <
class
 
	gTYPE
>

388 
	gFMV_Vector
<
	gTYPE
>& FMV_Vector<TYPE>::
operator
=( const 
FMV_Vector
<
TYPE
>& 
m
)

391 #ifdef 
TRACE_VEC


392 
cout
 << "> FMV_Vector<TYPE>::operator=( const FMV_Vector<TYPE>& m)" << 
endl
;

395 int 
	gN
 = 
m
.
dim_
;

399 if (
	gref_
 )

401 if (
	gdim_
 != 
m
.
dim_
)

403 
cerr
 << "MV_VectorRef::operator= non-conformant assignment.\n";

404 
exit
(1);

407 else if ( 
	gdim_
 != 
m
.
dim_
 )

408 
newsize
(
N
);

410 
memmove
(
p_
, 
m
.p_, 
N
 * sizeof(
TYPE
));

412 #ifdef 
TRACE_VEC


413 
	gcout
 << "< FMV_Vector<TYPE>::operator=( const FMV_Vector<TYPE>& m)" << 
	gendl
;

416 return *
	gthis
;

419 
	gtemplate
 <
class
 
	gTYPE
>

420 
	gFMV_Vector
<
	gTYPE
>& FMV_Vector<TYPE>::
operator
=(const 
TYPE
 & 
m
)

422 #ifdef 
TRACE_VEC


423 
cout
 << "> FMV_Vector<TYPE>::operator=(const TYPE & m) " << 
endl
;

428 int 
	gN
 = 
size
();

430 int 
	gNminus4
 = 
N
-4;

431 int 
	gi
;

433 for (
	gi
=0; i<
	gNminus4
; )

435 
	gp_
[
i
++] = 
m
;

436 
	gp_
[
i
++] = 
m
;

437 
	gp_
[
i
++] = 
m
;

438 
	gp_
[
i
++] = 
m
;

441 for (; 
	gi
<
	gN
; 
	gp_
[
i
++] = 
m
);

443 #ifdef 
TRACE_VEC


444 
	gcout
 << "< FMV_Vector<TYPE>::operator=(const TYPE & m) " << 
	gendl
;

446 return *
	gthis
;

449 #include 
	~"mvblas.h
"

	@mv/include/tblas1.h

25 #ifndef 
_MV_BLAS1_TYPE_H_


26 #define 
	#_MV_BLAS1_TYPE_H_


	)

28 #include 
	~<math.h
>

29 #include 
	~<stdlib.h
>

32 
	gMV_Vector_TYPE
& 
	goperator
*=(
MV_Vector_TYPE
 &
x
, const 
	gTYPE
 &
	ga
);

33 
MV_Vector_TYPE
 
	goperator
*(const 
	gTYPE
 &
	ga
, const 
	gMV_Vector_TYPE
 &
	gx
);

34 
MV_Vector_TYPE
 
	goperator
*(const 
	gMV_Vector_TYPE
 &
	gx
, const 
	gTYPE
 &
	ga
);

35 
MV_Vector_TYPE
 
	goperator
+(const 
	gMV_Vector_TYPE
 &
	gx
,

36 const 
	gMV_Vector_TYPE
 &
	gy
);

37 
MV_Vector_TYPE
 
	goperator
-(const 
	gMV_Vector_TYPE
 &
	gx
,

38 const 
	gMV_Vector_TYPE
 &
	gy
);

39 
	gMV_Vector_TYPE
& 
	goperator
+=(
MV_Vector_TYPE
 &
x
, const MV_Vector_TYPE &
	gy
);

40 
	gMV_Vector_TYPE
& 
	goperator
-=(
MV_Vector_TYPE
 &
x
, const MV_Vector_TYPE &
	gy
);

42 
TYPE
 
dot
(const 
MV_Vector_TYPE
 &
x
, const MV_Vector_TYPE &
y
);

43 
TYPE
 
norm
(const 
MV_Vector_TYPE
 &
x
);

	@mv/include/tmvmat.h

33 #ifndef 
_MV_MATRIX_TYPE_H_


34 #define 
	#_MV_MATRIX_TYPE_H_


	)

36 #include 
	~"mv_vector_TYPE.h
"

37 #include 
	~"mvmrf.h
"

41 #include 
	~<sstream
>

42 #ifdef 
MV_MATRIX_BOUNDS_CHECK


43 #include 
	~<assert.h
>

47 class 
	cMV_ColMat_TYPE


49 
	mprivate
:

50 
MV_Vector_TYPE
 
v_
;

51 int 
	mdim0_
;

52 int 
	mdim1_
;

53 int 
	mlda_
;

54 int 
	mref_
;

57 
	mpublic
:

63 
MV_ColMat_TYPE
();

64 
MV_ColMat_TYPE
( int, int);

67 
MV_ColMat_TYPE
( int, int, const 
TYPE
&);

72 
MV_ColMat_TYPE
(
TYPE
*, int 
m
, int 
n
);

73 
MV_ColMat_TYPE
(
TYPE
*, int 
m
, int 
n
, int 
lda
);

78 
MV_ColMat_TYPE
(
TYPE
*, int 
m
, int 
n
, 
MV_Matrix_
::
ref_type
 
i
);

79 
MV_ColMat_TYPE
(
TYPE
*, int 
m
, int 
n
, int 
lda
,

80 
MV_Matrix_
::
ref_type
 
i
);

82 
MV_ColMat_TYPE
(const MV_ColMat_TYPE&);

83 ~
MV_ColMat_TYPE
();

89 
inline
 
	mTYPE
& 
	$operator
()( int, int);

90 
inline
 const 
TYPE
& 
	$operator
()( int, int) const;

91 
MV_ColMat_TYPE
 
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
) ;

92 const 
MV_ColMat_TYPE
 
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
) const;

93 int 
	$size
(int 
i
) const;

94 
MV_ColMat_TYPE
& 
	`newsize
( int, int);

95 int 
	$ref
() const { return 
ref_
;}

101 
MV_ColMat_TYPE
 & 
operator
=(const MV_ColMat_TYPE&);

102 
MV_ColMat_TYPE
 & 
operator
=(const 
TYPE
&);

105 
friend
 
std
::
ostream
& 
operator
<<(std::ostream &
s
, const 
MV_ColMat_TYPE
 &
A
);

107 
	}
};

109 
inline
 
	gTYPE
& 
	gMV_ColMat_TYPE
::
	$operator
()( int 
i
, int 
j
)

111 #ifdef 
MV_MATRIX_BOUNDS_CHECK


112 
	`assert
(0<=
i
 && i<
	`size
(0));

113 
	`assert
(0<=
j
 && j<
	`size
(1));

115 return 
	`v_
(
j
*
lda_
 + 
i
);

117 
	}
}

119 
inline
 const 
	gTYPE
& 
	gMV_ColMat_TYPE
::
	$operator
()

120 ( int 
i
, int 
j
) const

122 #ifdef 
MV_MATRIX_BOUNDS_CHECK


123 
	`assert
(0<=
i
 && i<
	`size
(0));

124 
	`assert
(0<=
j
 && j<
	`size
(1));

126 return 
	`v_
(
j
*
lda_
 + 
i
);

127 
	}
}

129 
inline
 
	gMV_ColMat_TYPE
::
MV_ColMat_TYPE
(
TYPE
* 
d
, int 
m
, int 
n
,

130 
MV_Matrix_
::
ref_type
 
i
 ):

131 
v_
(
d
,
m
*
n
, 
MV_Vector_
::
ref
), 
dim0_
(m), 
dim1_
(n), 
lda_
(m), 
	$ref_
(
i
) {
	}
}

133 
inline
 
	gMV_ColMat_TYPE
::
MV_ColMat_TYPE
(
TYPE
* 
d
, int 
m
, int 
n
,

134 int 
lda
, 
MV_Matrix_
::
ref_type
 
i
) :

135 
v_
(
d
, 
lda
*
n
, 
MV_Vector_
::
ref
), 
dim0_
(
m
), 
dim1_
(n), 
lda_
(lda),

136 
	$ref_
(
i
) {
	}
}

	@mv/include/vecdefs.h

30 #ifndef 
vector_defs_H


31 #define 
	#vector_defs_H


	)

33 #define 
	#VECTOR_H
 "mvv.h"

	)

34 #define 
	#VECTOR_double
 
MV_Vector_double


	)

35 #define 
	#VECTOR_float
 
MV_Vector_float


	)

36 #define 
	#VECTOR_int
 
MV_Vector_int


	)

37 #define 
	#VECTOR_ref
 
MV_Vector_
::
ref


	)

38 #define 
	#MATRIX_H
 "mvm.h"

	)

39 #define 
	#MATRIX_double
 
MV_ColMat_double


	)

40 #define 
	#MATRIX_float
 
MV_ColMat_float


	)

41 #define 
	#MATRIX_int
 
MV_ColMat_int


	)

42 #define 
	#MATRIX_ref
 
MV_Matrix_
::
ref


	)

44 #define 
	#VECTOR_COMPLEX
 
MV_Vector_COMPLEX


	)

45 #define 
	#MATRIX_COMPLEX
 
MV_ColMat_COMPLEX


	)

	@mv/src/mvblasc.cc

25 #include 
	~<iostream
>

26 #include 
	~<math.h
>

27 #include 
	~<stdlib.h
>

29 #include 
	~"mvv.h
"

31 
	gMV_Vector_COMPLEX
& 
	goperator
*=(
MV_Vector_COMPLEX
 &
x
, const 
	gCOMPLEX
 &
	ga
)

33 int 
	gN
 = 
x
.
size
();

34 for (int 
	gi
=0;i<
	gN
;i++)

35 
x
(
i
) *= 
a
;

36 return 
	gx
;

39 
MV_Vector_COMPLEX
 
	goperator
*(const 
	gCOMPLEX
 &
	ga
, const 
	gMV_Vector_COMPLEX
 &
	gx
)

41 int 
	gN
 = 
x
.
size
();

42 
MV_Vector_COMPLEX
 
result
(
N
);

43 for (int 
	gi
=0;i<
	gN
;i++)

44 
result
(
i
) = 
x
(i)*
a
;

45 return 
	gresult
;

48 
MV_Vector_COMPLEX
 
	goperator
*(const 
	gMV_Vector_COMPLEX
 &
	gx
, const 
	gCOMPLEX
 &
	ga
)

58 int 
	gN
 = 
x
.
size
();

59 
MV_Vector_COMPLEX
 
result
(
N
);

60 for (int 
	gi
=0;i<
	gN
;i++)

61 
result
(
i
) = 
x
(i)*
a
;

62 return 
	gresult
;

66 
MV_Vector_COMPLEX
 
	goperator
+(const 
	gMV_Vector_COMPLEX
 &
	gx
, const MV_Vector_COMPLEX &
	gy
)

68 int 
	gN
 = 
x
.
size
();

69 if (
	gN
 != 
y
.
size
())

71 
std
::
cout
 << "Incompatible vector lengths in +." << "\n";

72 
exit
(1);

75 
MV_Vector_COMPLEX
 
result
(
N
);

76 for (int 
	gi
=0;i<
	gN
; i++)

77 
result
(
i
) = 
x
(i) + 
y
(i);

78 return 
	gresult
;

81 
MV_Vector_COMPLEX
 
	goperator
-(const 
	gMV_Vector_COMPLEX
 &
	gx
, const MV_Vector_COMPLEX &
	gy
)

83 int 
	gN
 = 
x
.
size
();

84 if (
	gN
 != 
y
.
size
())

86 
std
::
cout
 << "Incompatible vector lengths in -." << "\n";

87 
exit
(1);

90 
MV_Vector_COMPLEX
 
result
(
N
);

91 for (int 
	gi
=0;i<
	gN
; i++)

92 
result
(
i
) = 
x
(i) - 
y
(i);

93 return 
	gresult
;

97 
	gMV_Vector_COMPLEX
& 
	goperator
+=(
MV_Vector_COMPLEX
 &
x
, const MV_Vector_COMPLEX &
	gy
)

99 int 
	gN
 = 
x
.
size
();

100 if (
	gN
 != 
y
.
size
())

102 
std
::
cout
 << "Incompatible vector lengths in -." << "\n";

103 
exit
(1);

106 for (int 
	gi
=0;i<
	gN
; i++)

107 
x
(
i
) += 
y
(i);

108 return 
	gx
;

112 
	gMV_Vector_COMPLEX
& 
	goperator
-=(
MV_Vector_COMPLEX
 &
x
, const MV_Vector_COMPLEX &
	gy
)

114 int 
	gN
 = 
x
.
size
();

115 if (
	gN
 != 
y
.
size
())

117 
std
::
cout
 << "Incompatible vector lengths in -." << "\n";

118 
exit
(1);

121 for (int 
	gi
=0;i<
	gN
; i++)

122 
x
(
i
) -= 
y
(i);

123 return 
	gx
;

131 
COMPLEX
 
	$dot
(const 
MV_Vector_COMPLEX
 &
x
, const MV_Vector_COMPLEX &
y
)

135 if (
x
.
	`size
() != 
y
.size())

137 
std
::
cout
 << "Incompatible dimensions in dot(). " << "\n";

138 
	`exit
(1);

141 
COMPLEX
 
temp
 = 0;

142 for (int 
i
=0; i<
x
.
	`size
();i++)

143 
temp
 += 
	`x
(
i
)*
	`y
(i);

144 return 
temp
;

145 
	}
}

147 
COMPLEX
 
	$norm
(const 
MV_Vector_COMPLEX
 &
x
)

149 
COMPLEX
 
temp
 = 
	`dot
(
x
,x);

150 return 
	`sqrt
(
temp
);

151 
	}
}

	@mv/src/mvblasd.cc

25 #include 
	~<iostream
>

26 #include 
	~<math.h
>

27 #include 
	~<stdlib.h
>

29 #include 
	~"mvvd.h
"

31 
	gMV_Vector_double
& 
	goperator
*=(
MV_Vector_double
 &
x
, const double &
	ga
)

33 int 
	gN
 = 
x
.
size
();

34 for (int 
	gi
=0;i<
	gN
;i++)

35 
x
(
i
) *= 
a
;

36 return 
	gx
;

39 
MV_Vector_double
 
	goperator
*(const double &
	ga
, const 
	gMV_Vector_double
 &
	gx
)

41 int 
	gN
 = 
x
.
size
();

42 
MV_Vector_double
 
result
(
N
);

43 for (int 
	gi
=0;i<
	gN
;i++)

44 
result
(
i
) = 
x
(i)*
a
;

45 return 
	gresult
;

48 
MV_Vector_double
 
	goperator
*(const 
	gMV_Vector_double
 &
	gx
, const double &
	ga
)

58 int 
	gN
 = 
x
.
size
();

59 
MV_Vector_double
 
result
(
N
);

60 for (int 
	gi
=0;i<
	gN
;i++)

61 
result
(
i
) = 
x
(i)*
a
;

62 return 
	gresult
;

66 
MV_Vector_double
 
	goperator
+(const 
	gMV_Vector_double
 &
	gx
, const MV_Vector_double &
	gy
)

68 int 
	gN
 = 
x
.
size
();

69 if (
	gN
 != 
y
.
size
())

71 
std
::
cout
 << "Incompatible vector lengths in +." << "\n";

72 
exit
(1);

75 
MV_Vector_double
 
result
(
N
);

76 for (int 
	gi
=0;i<
	gN
; i++)

77 
result
(
i
) = 
x
(i) + 
y
(i);

78 return 
	gresult
;

81 
MV_Vector_double
 
	goperator
-(const 
	gMV_Vector_double
 &
	gx
, const MV_Vector_double &
	gy
)

83 int 
	gN
 = 
x
.
size
();

84 if (
	gN
 != 
y
.
size
())

86 
std
::
cout
 << "Incompatible vector lengths in -." << "\n";

87 
exit
(1);

90 
MV_Vector_double
 
result
(
N
);

91 for (int 
	gi
=0;i<
	gN
; i++)

92 
result
(
i
) = 
x
(i) - 
y
(i);

93 return 
	gresult
;

97 
	gMV_Vector_double
& 
	goperator
+=(
MV_Vector_double
 &
x
, const MV_Vector_double &
	gy
)

99 int 
	gN
 = 
x
.
size
();

100 if (
	gN
 != 
y
.
size
())

102 
std
::
cout
 << "Incompatible vector lengths in -." << "\n";

103 
exit
(1);

106 for (int 
	gi
=0;i<
	gN
; i++)

107 
x
(
i
) += 
y
(i);

108 return 
	gx
;

112 
	gMV_Vector_double
& 
	goperator
-=(
MV_Vector_double
 &
x
, const MV_Vector_double &
	gy
)

114 int 
	gN
 = 
x
.
size
();

115 if (
	gN
 != 
y
.
size
())

117 
std
::
cout
 << "Incompatible vector lengths in -." << "\n";

118 
exit
(1);

121 for (int 
	gi
=0;i<
	gN
; i++)

122 
x
(
i
) -= 
y
(i);

123 return 
	gx
;

131 double 
	$dot
(const 
MV_Vector_double
 &
x
, const MV_Vector_double &
y
)

135 if (
x
.
	`size
() != 
y
.size())

137 
std
::
cout
 << "Incompatible dimensions in dot(). " << "\n";

138 
	`exit
(1);

141 double 
temp
 = 0;

142 for (int 
i
=0; i<
x
.
	`size
();i++)

143 
temp
 += 
	`x
(
i
)*
	`y
(i);

144 return 
temp
;

145 
	}
}

147 double 
	$norm
(const 
MV_Vector_double
 &
x
)

149 double 
temp
 = 
	`dot
(
x
,x);

150 return 
	`sqrt
(
temp
);

151 
	}
}

	@mv/src/mvblasf.cc

26 #include 
	~<iostream
>

27 #include 
	~<math.h
>

28 #include 
	~<stdlib.h
>

30 #include 
	~"mvvf.h
"

32 
	gMV_Vector_float
& 
	goperator
*=(
MV_Vector_float
 &
x
, const float &
	ga
)

34 int 
	gN
 = 
x
.
size
();

35 for (int 
	gi
=0;i<
	gN
;i++)

36 
x
(
i
) *= 
a
;

37 return 
	gx
;

40 
MV_Vector_float
 
	goperator
*(const float &
	ga
, const 
	gMV_Vector_float
 &
	gx
)

42 int 
	gN
 = 
x
.
size
();

43 
MV_Vector_float
 
result
(
N
);

44 for (int 
	gi
=0;i<
	gN
;i++)

45 
result
(
i
) = 
x
(i)*
a
;

46 return 
	gresult
;

49 
MV_Vector_float
 
	goperator
*(const 
	gMV_Vector_float
 &
	gx
, const float &
	ga
)

59 int 
	gN
 = 
x
.
size
();

60 
MV_Vector_float
 
result
(
N
);

61 for (int 
	gi
=0;i<
	gN
;i++)

62 
result
(
i
) = 
x
(i)*
a
;

63 return 
	gresult
;

67 
MV_Vector_float
 
	goperator
+(const 
	gMV_Vector_float
 &
	gx
, const MV_Vector_float &
	gy
)

69 int 
	gN
 = 
x
.
size
();

70 if (
	gN
 != 
y
.
size
())

72 
std
::
cout
 << "Incompatible vector lengths in +." << "\n";

73 
exit
(1);

76 
MV_Vector_float
 
result
(
N
);

77 for (int 
	gi
=0;i<
	gN
; i++)

78 
result
(
i
) = 
x
(i) + 
y
(i);

79 return 
	gresult
;

82 
MV_Vector_float
 
	goperator
-(const 
	gMV_Vector_float
 &
	gx
, const MV_Vector_float &
	gy
)

84 int 
	gN
 = 
x
.
size
();

85 if (
	gN
 != 
y
.
size
())

87 
std
::
cout
 << "Incompatible vector lengths in -." << "\n";

88 
exit
(1);

91 
MV_Vector_float
 
result
(
N
);

92 for (int 
	gi
=0;i<
	gN
; i++)

93 
result
(
i
) = 
x
(i) - 
y
(i);

94 return 
	gresult
;

98 
	gMV_Vector_float
& 
	goperator
+=(
MV_Vector_float
 &
x
, const MV_Vector_float &
	gy
)

100 int 
	gN
 = 
x
.
size
();

101 if (
	gN
 != 
y
.
size
())

103 
std
::
cout
 << "Incompatible vector lengths in -." << "\n";

104 
exit
(1);

107 for (int 
	gi
=0;i<
	gN
; i++)

108 
x
(
i
) += 
y
(i);

109 return 
	gx
;

113 
	gMV_Vector_float
& 
	goperator
-=(
MV_Vector_float
 &
x
, const MV_Vector_float &
	gy
)

115 int 
	gN
 = 
x
.
size
();

116 if (
	gN
 != 
y
.
size
())

118 
std
::
cout
 << "Incompatible vector lengths in -." << "\n";

119 
exit
(1);

122 for (int 
	gi
=0;i<
	gN
; i++)

123 
x
(
i
) -= 
y
(i);

124 return 
	gx
;

132 float 
	$dot
(const 
MV_Vector_float
 &
x
, const MV_Vector_float &
y
)

136 if (
x
.
	`size
() != 
y
.size())

138 
std
::
cout
 << "Incompatible dimensions in dot(). " << "\n";

139 
	`exit
(1);

142 float 
temp
 = 0;

143 for (int 
i
=0; i<
x
.
	`size
();i++)

144 
temp
 += 
	`x
(
i
)*
	`y
(i);

145 return 
temp
;

146 
	}
}

148 float 
	$norm
(const 
MV_Vector_float
 &
x
)

150 float 
temp
 = 
	`dot
(
x
,x);

151 return 
	`sqrt
(
temp
);

152 
	}
}

	@mv/src/mvblasi.cc

26 #include 
	~<iostream
>

27 #include 
	~<math.h
>

28 #include 
	~<stdlib.h
>

30 #include 
	~"mvvi.h
"

32 
	gMV_Vector_int
& 
	goperator
*=(
MV_Vector_int
 &
x
, const int &
	ga
)

34 int 
	gN
 = 
x
.
size
();

35 for (int 
	gi
=0;i<
	gN
;i++)

36 
x
(
i
) *= 
a
;

37 return 
	gx
;

40 
MV_Vector_int
 
	goperator
*(const int &
	ga
, const 
	gMV_Vector_int
 &
	gx
)

42 int 
	gN
 = 
x
.
size
();

43 
MV_Vector_int
 
result
(
N
);

44 for (int 
	gi
=0;i<
	gN
;i++)

45 
result
(
i
) = 
x
(i)*
a
;

46 return 
	gresult
;

49 
MV_Vector_int
 
	goperator
*(const 
	gMV_Vector_int
 &
	gx
, const int &
	ga
)

59 int 
	gN
 = 
x
.
size
();

60 
MV_Vector_int
 
result
(
N
);

61 for (int 
	gi
=0;i<
	gN
;i++)

62 
result
(
i
) = 
x
(i)*
a
;

63 return 
	gresult
;

67 
MV_Vector_int
 
	goperator
+(const 
	gMV_Vector_int
 &
	gx
, const MV_Vector_int &
	gy
)

69 int 
	gN
 = 
x
.
size
();

70 if (
	gN
 != 
y
.
size
())

72 
std
::
cout
 << "Incompatible vector lengths in +." << "\n";

73 
exit
(1);

76 
MV_Vector_int
 
result
(
N
);

77 for (int 
	gi
=0;i<
	gN
; i++)

78 
result
(
i
) = 
x
(i) + 
y
(i);

79 return 
	gresult
;

82 
MV_Vector_int
 
	goperator
-(const 
	gMV_Vector_int
 &
	gx
, const MV_Vector_int &
	gy
)

84 int 
	gN
 = 
x
.
size
();

85 if (
	gN
 != 
y
.
size
())

87 
std
::
cout
 << "Incompatible vector lengths in -." << "\n";

88 
exit
(1);

91 
MV_Vector_int
 
result
(
N
);

92 for (int 
	gi
=0;i<
	gN
; i++)

93 
result
(
i
) = 
x
(i) - 
y
(i);

94 return 
	gresult
;

98 
	gMV_Vector_int
& 
	goperator
+=(
MV_Vector_int
 &
x
, const MV_Vector_int &
	gy
)

100 int 
	gN
 = 
x
.
size
();

101 if (
	gN
 != 
y
.
size
())

103 
std
::
cout
 << "Incompatible vector lengths in -." << "\n";

104 
exit
(1);

107 for (int 
	gi
=0;i<
	gN
; i++)

108 
x
(
i
) += 
y
(i);

109 return 
	gx
;

113 
	gMV_Vector_int
& 
	goperator
-=(
MV_Vector_int
 &
x
, const MV_Vector_int &
	gy
)

115 int 
	gN
 = 
x
.
size
();

116 if (
	gN
 != 
y
.
size
())

118 
std
::
cout
 << "Incompatible vector lengths in -." << "\n";

119 
exit
(1);

122 for (int 
	gi
=0;i<
	gN
; i++)

123 
x
(
i
) -= 
y
(i);

124 return 
	gx
;

132 int 
	$dot
(const 
MV_Vector_int
 &
x
, const MV_Vector_int &
y
)

136 if (
x
.
	`size
() != 
y
.size())

138 
std
::
cout
 << "Incompatible dimensions in dot(). " << "\n";

139 
	`exit
(1);

142 int 
temp
 = 0;

143 for (int 
i
=0; i<
x
.
	`size
();i++)

144 
temp
 += 
	`x
(
i
)*
	`y
(i);

145 return 
temp
;

146 
	}
}

148 int 
	$norm
(const 
MV_Vector_int
 &
x
)

150 int 
temp
 = 
	`dot
(
x
,x);

151 return (int) 
	`sqrt
((double) 
temp
);

152 
	}
}

	@mv/src/mvblast.cc

26 #include 
	~<math.h
>

27 #include 
	~<stdlib.h
>

29 #include 
	~"$INCLUDE
"

31 
	gMV_Vector_$TYPE
& 
	goperator
*=(
MV_Vector_$TYPE
 &
x
, const 
	g$TYPE
 &
	ga
)

33 int 
	gN
 = 
x
.
size
();

34 for (int 
	gi
=0;i<
	gN
;i++)

35 
x
(
i
) *= 
a
;

36 return 
	gx
;

39 
MV_Vector_$TYPE
 
	goperator
*(const 
	g$TYPE
 &
	ga
, const 
	gMV_Vector_$TYPE
 &
	gx
)

41 int 
	gN
 = 
x
.
size
();

42 
MV_Vector_$TYPE
 
result
(
N
);

43 for (int 
	gi
=0;i<
	gN
;i++)

44 
result
(
i
) = 
x
(i)*
a
;

45 return 
	gresult
;

48 
MV_Vector_$TYPE
 
	goperator
*(const 
	gMV_Vector_$TYPE
 &
	gx
, const 
	g$TYPE
 &
	ga
)

58 int 
	gN
 = 
x
.
size
();

59 
MV_Vector_$TYPE
 
result
(
N
);

60 for (int 
	gi
=0;i<
	gN
;i++)

61 
result
(
i
) = 
x
(i)*
a
;

62 return 
	gresult
;

66 
MV_Vector_$TYPE
 
	goperator
+(const 
	gMV_Vector_$TYPE
 &
	gx
, const MV_Vector_$TYPE &
	gy
)

68 int 
	gN
 = 
x
.
size
();

69 if (
	gN
 != 
y
.
size
())

71 
cout
 << "Incompatible vector lengths in +." << "\n";

72 
exit
(1);

75 
MV_Vector_$TYPE
 
result
(
N
);

76 for (int 
	gi
=0;i<
	gN
; i++)

77 
result
(
i
) = 
x
(i) + 
y
(i);

78 return 
	gresult
;

81 
MV_Vector_$TYPE
 
	goperator
-(const 
	gMV_Vector_$TYPE
 &
	gx
, const MV_Vector_$TYPE &
	gy
)

83 int 
	gN
 = 
x
.
size
();

84 if (
	gN
 != 
y
.
size
())

86 
cout
 << "Incompatible vector lengths in -." << "\n";

87 
exit
(1);

90 
MV_Vector_$TYPE
 
result
(
N
);

91 for (int 
	gi
=0;i<
	gN
; i++)

92 
result
(
i
) = 
x
(i) - 
y
(i);

93 return 
	gresult
;

97 
	gMV_Vector_$TYPE
& 
	goperator
+=(
MV_Vector_$TYPE
 &
x
, const MV_Vector_$TYPE &
	gy
)

99 int 
	gN
 = 
x
.
size
();

100 if (
	gN
 != 
y
.
size
())

102 
cout
 << "Incompatible vector lengths in -." << "\n";

103 
exit
(1);

106 for (int 
	gi
=0;i<
	gN
; i++)

107 
x
(
i
) += 
y
(i);

108 return 
	gx
;

112 
	gMV_Vector_$TYPE
& 
	goperator
-=(
MV_Vector_$TYPE
 &
x
, const MV_Vector_$TYPE &
	gy
)

114 int 
	gN
 = 
x
.
size
();

115 if (
	gN
 != 
y
.
size
())

117 
cout
 << "Incompatible vector lengths in -." << "\n";

118 
exit
(1);

121 for (int 
	gi
=0;i<
	gN
; i++)

122 
x
(
i
) -= 
y
(i);

123 return 
	gx
;

131 
$TYPE
 
	$dot
(const 
MV_Vector_$TYPE
 &
x
, const MV_Vector_$TYPE &
y
)

135 if (
x
.
	`size
() != 
y
.size())

137 
cout
 << "Incompatible dimensions in dot(). " << "\n";

138 
	`exit
(1);

141 
$TYPE
 
temp
 = 0;

142 for (int 
i
=0; i<
x
.
	`size
();i++)

143 
temp
 += 
	`x
(
i
)*
	`y
(i);

144 return 
temp
;

145 
	}
}

147 
$TYPE
 
	$norm
(const 
MV_Vector_$TYPE
 &
x
)

149 
$TYPE
 
temp
 = 
	`dot
(
x
,x);

150 return 
	`sqrt
(
temp
);

151 
	}
}

	@mv/src/mvmc.cc

29 #include 
	~"mvm.h
"

31 int 
	gMV_ColMat_COMPLEX
::
	$dim
(int 
i
) const

33 if (
i
==0) return 
dim0_
;

34 if (
i
==1) return 
dim1_
;

37 
std
::
cerr
 << "Called MV_ColMat::dim(" << 
i
 << ") must be 0 or 1 " << "\n";

38 
	`exit
(1);

44 
	}
}

48 
	gMV_ColMat_COMPLEX
::
	$MV_ColMat_COMPLEX
() : 
	`v_
(), 
	`dim0_
(0), 
	`dim1_
(0) , 
	`lda_
(0), 
	$ref_
(0){
	}
}

51 
	gMV_ColMat_COMPLEX
::
	$MV_ColMat_COMPLEX
( int 
m
, int 
n
) : 
	`v_
(m*n),

52 
	`dim0_
(
m
), 
	`dim1_
(
n
), 
	`lda_
(m), 
	$ref_
(0) {
	}
}

54 
	gMV_ColMat_COMPLEX
::
	$MV_ColMat_COMPLEX
( int 
m
, int 
n
, const 
COMPLEX
 &
s
) : 
	`v_
(m*n),

55 
	`dim0_
(
m
), 
	`dim1_
(
n
), 
	`lda_
(m), 
	$ref_
(0)

57 
operator
=(
s
);

58 
	}
}

67 
	gMV_ColMat_COMPLEX
& MV_ColMat_COMPLEX::
operator
=(const 
COMPLEX
 & 
s
)

69 int 
M
 = 
dim
(0);

70 int 
	gN
 = 
dim
(1);

72 if (
	glda_
 == 
M
)

73 
v_
 = 
s
;

81 
MV_VecIndex
 
I
(0,
M
-1);

82 for (int 
	gj
=0; j<
	gN
; j++)

84 
v_
(
I
) = 
s
;

85 
	gI
 += 
lda_
;

89 return *
	gthis
;

92 
	gMV_ColMat_COMPLEX
& MV_ColMat_COMPLEX::
	$newsize
( int 
M
, int 
N
)

94 
v_
.
	`newsize
(
M
*
N
);

95 
dim0_
 = 
M
;

96 
dim1_
 = 
N
;

97 
lda_
 = 
M
;

99 return *
this
;

100 
	}
}

102 
	gMV_ColMat_COMPLEX
& MV_ColMat_COMPLEX::
operator
=(const 
MV_ColMat_COMPLEX
 & 
m
)

105 int 
lM
 = 
dim0_
;

106 int 
	glN
 = 
dim1_
;

108 int 
	grM
 = 
m
.
dim0_
;

109 int 
	grN
 = 
m
.
dim1_
;

116 if (
	gref_
)

119 if (
	glM
 != 
rM
 || 
lN
 != 
rN
)

121 
std
::
cerr
 << "MV_ColMatRef::operator= non-conformant assignment.\n";

122 
exit
(1);

127 
newsize
(
rM
,
rN
);

136 if ( 
	glM
 == 
lda_
 && 
rM
 == 
m
.lda_)

138 
MV_VecIndex
 
I
(0,
rM
*
rN
-1);

139 
v_
(
I
) = 
m
.v_(I);

145 
MV_VecIndex
 
I
(0,
rM
-1);

146 
MV_VecIndex
 
K
(0,
rM
-1);

147 for (int 
	gj
=0; j<
	grN
; j++)

149 
v_
(
I
) = 
m
.v_(
K
);

150 
	gI
 += 
lda_
;

151 
	gK
 += 
m
.
lda_
;

155 return *
	gthis
;

158 
	gMV_ColMat_COMPLEX
::
	$MV_ColMat_COMPLEX
(const 
MV_ColMat_COMPLEX
 & 
m
) :

159 
	`v_
(
m
.
dim0_
*m.
dim1_
), 
	`dim0_
(m.dim0_),

160 
	`dim1_
(
m
.
dim1_
), 
	`lda_
(m.
dim0_
), 
	$ref_
(0)

163 int 
M
 = 
m
.
dim0_
;

164 int 
N
 = 
m
.
dim1_
;

169 
MV_VecIndex
 
	`I
(0,
M
-1);

170 
MV_VecIndex
 
	`K
(0,
M
-1);

171 for (int 
j
=0; j<
N
; j++)

173 
	`v_
(
I
) = 
m
.v_(
K
);

174 
I
 += 
lda_
;

175 
K
 += 
m
.
lda_
;

177 
	}
}

181 
	gMV_ColMat_COMPLEX
::
	$MV_ColMat_COMPLEX
(
COMPLEX
* 
d
, int 
m
, int 
n
) :

182 
	`v_
(
m
*
n
), 
	`dim0_
(m), 
	`dim1_
(n), 
	`lda_
(m), 
	$ref_
(0)

184 int 
mn
 = 
m
*
n
;

187 for (int 
i
=0; i< 
mn
; i++)

188 
v_
[
i
] = 
d
[i];

189 
	}
}

192 
	gMV_ColMat_COMPLEX
::
	$MV_ColMat_COMPLEX
(
COMPLEX
* 
d
, int 
m
, int 
n
,

193 int 
lda
) :

194 
	`v_
(
m
*
n
), 
	`dim0_
(m), 
	`dim1_
(n), 
	`lda_
(
lda
), 
	$ref_
(0)

196 for (int 
j
=0; j< 
n
; j++)

197 for (int 
i
=0; i<
m
; i++)

198 
	`operator
()(
i
,
j
) = 
d
[j*
lda
 + i];

199 
	}
}

202 
MV_ColMat_COMPLEX
 
	gMV_ColMat_COMPLEX
::
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
)

206 if (
I
.
	`end
() >= 
dim0_
 || 
J
.end() >= 
dim1_
)

208 
std
::
cerr
 << "Matrix index: (" << 
I
.
	`start
() << ":" << I.
	`end
()

209 << "," << 
J
.
	`start
() << ":" << J.
	`end
()

210 << ") not a subset of (0:" << 
dim0_
 - 1 << ", 0:"

211 << 
dim1_
-1 << ") " << "\n";

212 
	`exit
(1);

217 return 
	`MV_ColMat_COMPLEX
(&
v_
[
J
.
	`start
()*
lda_
 + 
I
.start()],

218 
I
.
	`end
() - I.
	`start
() + 1,

219 
J
.
	`end
() - J.
	`start
() + 1, 
lda_
, 
MV_Matrix_
::
ref
);

220 
	}
}

222 const 
MV_ColMat_COMPLEX
 
	gMV_ColMat_COMPLEX
::
	$operator
()(const 
MV_VecIndex
 &
I
,

223 const 
MV_VecIndex
 &
J
) const

226 
std
::
cerr
 << "Const operator()(MV_VecIndex, MV_VecIndex) called " << "\n";

230 if (
I
.
	`end
() >= 
dim0_
 || 
J
.end() >= 
dim1_
)

232 
std
::
cerr
 << "Matrix index: (" << 
I
.
	`start
() << ":" << I.
	`end
()

233 << "," << 
J
.
	`start
() << ":" << J.
	`end
()

234 << ") not a subset of (0:" << 
dim0_
 - 1 << ", 0:"

235 << 
dim1_
-1 << ") " << "\n";

236 
	`exit
(1);

243 
MV_ColMat_COMPLEX
 *
t
 = (MV_ColMat_COMPLEX*) 
this
;

244 return 
	`MV_ColMat_COMPLEX
(&(
t
->
v_
[
J
.
	`start
()*
lda_
 + 
I
.start()]),

245 
I
.
	`end
() - I.
	`start
() + 1,

246 
J
.
	`end
() - J.
	`start
() + 1, 
lda_
, 
MV_Matrix_
::
ref
);

247 
	}
}

249 
	gMV_ColMat_COMPLEX
::~
	$MV_ColMat_COMPLEX
() {
	}
}

251 
std
::
ostream
& 
operator
<<(std::ostream& 
s
, const 
	gMV_ColMat_COMPLEX
& 
	gV
)

253 int 
	gM
 = 
V
.
dim
(0);

254 int 
	gN
 = 
V
.
dim
(1);

256 for (int 
	gi
=0; i<
	gM
; i++)

258 for (int 
	gj
=0; j<
	gN
; j++)

259 
	gs
 << 
V
(
i
,
j
) << " " ;

260 
	gs
 << "\n";

263 return 
	gs
;

	@mv/src/mvmd.cc

29 #include 
	~<iostream
>

30 #include 
	~"mvmd.h
"

32 int 
	gMV_ColMat_double
::
	$dim
(int 
i
) const

34 if (
i
==0) return 
dim0_
;

35 if (
i
==1) return 
dim1_
;

38 
std
::
cerr
 << "Called MV_ColMat::dim(" << 
i
 << ") must be 0 or 1 " << "\n";

39 
	`exit
(1);

45 
	}
}

49 
	gMV_ColMat_double
::
	$MV_ColMat_double
() : 
	`v_
(), 
	`dim0_
(0), 
	`dim1_
(0) , 
	`lda_
(0), 
	$ref_
(0){
	}
}

52 
	gMV_ColMat_double
::
	$MV_ColMat_double
( int 
m
, int 
n
) : 
	`v_
(m*n),

53 
	`dim0_
(
m
), 
	`dim1_
(
n
), 
	`lda_
(m), 
	$ref_
(0) {
	}
}

55 
	gMV_ColMat_double
::
	$MV_ColMat_double
( int 
m
, int 
n
, const double &
s
) : 
	`v_
(m*n),

56 
	`dim0_
(
m
), 
	`dim1_
(
n
), 
	`lda_
(m), 
	$ref_
(0)

58 
operator
=(
s
);

59 
	}
}

68 
	gMV_ColMat_double
& MV_ColMat_double::
operator
=(const double & 
s
)

70 int 
M
 = 
dim
(0);

71 int 
	gN
 = 
dim
(1);

73 if (
	glda_
 == 
M
)

74 
v_
 = 
s
;

82 
MV_VecIndex
 
I
(0,
M
-1);

83 for (int 
	gj
=0; j<
	gN
; j++)

85 
v_
(
I
) = 
s
;

86 
	gI
 += 
lda_
;

90 return *
	gthis
;

93 
	gMV_ColMat_double
& MV_ColMat_double::
	$newsize
( int 
M
, int 
N
)

95 
v_
.
	`newsize
(
M
*
N
);

96 
dim0_
 = 
M
;

97 
dim1_
 = 
N
;

98 
lda_
 = 
M
;

100 return *
this
;

101 
	}
}

103 
	gMV_ColMat_double
& MV_ColMat_double::
operator
=(const 
MV_ColMat_double
 & 
m
)

106 int 
lM
 = 
dim0_
;

107 int 
	glN
 = 
dim1_
;

109 int 
	grM
 = 
m
.
dim0_
;

110 int 
	grN
 = 
m
.
dim1_
;

117 if (
	gref_
)

120 if (
	glM
 != 
rM
 || 
lN
 != 
rN
)

122 
std
::
cerr
 << "MV_ColMatRef::operator= non-conformant assignment.\n";

123 
exit
(1);

128 
newsize
(
rM
,
rN
);

137 if ( 
	glM
 == 
lda_
 && 
rM
 == 
m
.lda_)

139 
MV_VecIndex
 
I
(0,
rM
*
rN
-1);

140 
v_
(
I
) = 
m
.v_(I);

146 
MV_VecIndex
 
I
(0,
rM
-1);

147 
MV_VecIndex
 
K
(0,
rM
-1);

148 for (int 
	gj
=0; j<
	grN
; j++)

150 
v_
(
I
) = 
m
.v_(
K
);

151 
	gI
 += 
lda_
;

152 
	gK
 += 
m
.
lda_
;

156 return *
	gthis
;

159 
	gMV_ColMat_double
::
	$MV_ColMat_double
(const 
MV_ColMat_double
 & 
m
) :

160 
	`v_
(
m
.
dim0_
*m.
dim1_
), 
	`dim0_
(m.dim0_),

161 
	`dim1_
(
m
.
dim1_
), 
	`lda_
(m.
dim0_
), 
	$ref_
(0)

164 int 
M
 = 
m
.
dim0_
;

165 int 
N
 = 
m
.
dim1_
;

170 
MV_VecIndex
 
	`I
(0,
M
-1);

171 
MV_VecIndex
 
	`K
(0,
M
-1);

172 for (int 
j
=0; j<
N
; j++)

174 
	`v_
(
I
) = 
m
.v_(
K
);

175 
I
 += 
lda_
;

176 
K
 += 
m
.
lda_
;

178 
	}
}

182 
	gMV_ColMat_double
::
	$MV_ColMat_double
(double* 
d
, int 
m
, int 
n
) :

183 
	`v_
(
m
*
n
), 
	`dim0_
(m), 
	`dim1_
(n), 
	`lda_
(m), 
	$ref_
(0)

185 int 
mn
 = 
m
*
n
;

188 for (int 
i
=0; i< 
mn
; i++)

189 
v_
[
i
] = 
d
[i];

190 
	}
}

193 
	gMV_ColMat_double
::
	$MV_ColMat_double
(double* 
d
, int 
m
, int 
n
,

194 int 
lda
) :

195 
	`v_
(
m
*
n
), 
	`dim0_
(m), 
	`dim1_
(n), 
	`lda_
(
lda
), 
	$ref_
(0)

197 for (int 
j
=0; j< 
n
; j++)

198 for (int 
i
=0; i<
m
; i++)

199 
	`operator
()(
i
,
j
) = 
d
[j*
lda
 + i];

200 
	}
}

203 
MV_ColMat_double
 
	gMV_ColMat_double
::
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
)

207 if (
I
.
	`end
() >= 
dim0_
 || 
J
.end() >= 
dim1_
)

209 
std
::
cerr
 << "Matrix index: (" << 
I
.
	`start
() << ":" << I.
	`end
()

210 << "," << 
J
.
	`start
() << ":" << J.
	`end
()

211 << ") not a subset of (0:" << 
dim0_
 - 1 << ", 0:"

212 << 
dim1_
-1 << ") " << "\n";

213 
	`exit
(1);

218 return 
	`MV_ColMat_double
(&
v_
[
J
.
	`start
()*
lda_
 + 
I
.start()],

219 
I
.
	`end
() - I.
	`start
() + 1,

220 
J
.
	`end
() - J.
	`start
() + 1, 
lda_
, 
MV_Matrix_
::
ref
);

221 
	}
}

223 const 
MV_ColMat_double
 
	gMV_ColMat_double
::
	$operator
()(const 
MV_VecIndex
 &
I
,

224 const 
MV_VecIndex
 &
J
) const

227 
std
::
cerr
 << "Const operator()(MV_VecIndex, MV_VecIndex) called " << "\n";

231 if (
I
.
	`end
() >= 
dim0_
 || 
J
.end() >= 
dim1_
)

233 
std
::
cerr
 << "Matrix index: (" << 
I
.
	`start
() << ":" << I.
	`end
()

234 << "," << 
J
.
	`start
() << ":" << J.
	`end
()

235 << ") not a subset of (0:" << 
dim0_
 - 1 << ", 0:"

236 << 
dim1_
-1 << ") " << "\n";

237 
	`exit
(1);

244 
MV_ColMat_double
 *
t
 = (MV_ColMat_double*) 
this
;

245 return 
	`MV_ColMat_double
(&(
t
->
v_
[
J
.
	`start
()*
lda_
 + 
I
.start()]),

246 
I
.
	`end
() - I.
	`start
() + 1,

247 
J
.
	`end
() - J.
	`start
() + 1, 
lda_
, 
MV_Matrix_
::
ref
);

248 
	}
}

250 
	gMV_ColMat_double
::~
	$MV_ColMat_double
() {
	}
}

252 
std
::
ostream
& 
operator
<<(std::ostream& 
s
, const 
	gMV_ColMat_double
& 
	gV
)

254 int 
	gM
 = 
V
.
dim
(0);

255 int 
	gN
 = 
V
.
dim
(1);

257 for (int 
	gi
=0; i<
	gM
; i++)

259 for (int 
	gj
=0; j<
	gN
; j++)

260 
	gs
 << 
V
(
i
,
j
) << " " ;

261 
	gs
 << "\n";

264 return 
	gs
;

	@mv/src/mvmf.cc

29 #include 
	~<iostream
>

30 #include 
	~"mvmf.h
"

32 int 
	gMV_ColMat_float
::
	$dim
(int 
i
) const

34 if (
i
==0) return 
dim0_
;

35 if (
i
==1) return 
dim1_
;

38 
std
::
cerr
 << "Called MV_ColMat::dim(" << 
i
 << ") must be 0 or 1 " << "\n";

39 
	`exit
(1);

45 
	}
}

49 
	gMV_ColMat_float
::
	$MV_ColMat_float
() : 
	`v_
(), 
	`dim0_
(0), 
	`dim1_
(0) , 
	`lda_
(0), 
	$ref_
(0){
	}
}

52 
	gMV_ColMat_float
::
	$MV_ColMat_float
( int 
m
, int 
n
) : 
	`v_
(m*n),

53 
	`dim0_
(
m
), 
	`dim1_
(
n
), 
	`lda_
(m), 
	$ref_
(0) {
	}
}

55 
	gMV_ColMat_float
::
	$MV_ColMat_float
( int 
m
, int 
n
, const float &
s
) : 
	`v_
(m*n),

56 
	`dim0_
(
m
), 
	`dim1_
(
n
), 
	`lda_
(m), 
	$ref_
(0)

58 
operator
=(
s
);

59 
	}
}

68 
	gMV_ColMat_float
& MV_ColMat_float::
operator
=(const float & 
s
)

70 int 
M
 = 
dim
(0);

71 int 
	gN
 = 
dim
(1);

73 if (
	glda_
 == 
M
)

74 
v_
 = 
s
;

82 
MV_VecIndex
 
I
(0,
M
-1);

83 for (int 
	gj
=0; j<
	gN
; j++)

85 
v_
(
I
) = 
s
;

86 
	gI
 += 
lda_
;

90 return *
	gthis
;

93 
	gMV_ColMat_float
& MV_ColMat_float::
	$newsize
( int 
M
, int 
N
)

95 
v_
.
	`newsize
(
M
*
N
);

96 
dim0_
 = 
M
;

97 
dim1_
 = 
N
;

98 
lda_
 = 
M
;

100 return *
this
;

101 
	}
}

103 
	gMV_ColMat_float
& MV_ColMat_float::
operator
=(const 
MV_ColMat_float
 & 
m
)

106 int 
lM
 = 
dim0_
;

107 int 
	glN
 = 
dim1_
;

109 int 
	grM
 = 
m
.
dim0_
;

110 int 
	grN
 = 
m
.
dim1_
;

117 if (
	gref_
)

120 if (
	glM
 != 
rM
 || 
lN
 != 
rN
)

122 
std
::
cerr
 << "MV_ColMatRef::operator= non-conformant assignment.\n";

123 
exit
(1);

128 
newsize
(
rM
,
rN
);

137 if ( 
	glM
 == 
lda_
 && 
rM
 == 
m
.lda_)

139 
MV_VecIndex
 
I
(0,
rM
*
rN
-1);

140 
v_
(
I
) = 
m
.v_(I);

146 
MV_VecIndex
 
I
(0,
rM
-1);

147 
MV_VecIndex
 
K
(0,
rM
-1);

148 for (int 
	gj
=0; j<
	grN
; j++)

150 
v_
(
I
) = 
m
.v_(
K
);

151 
	gI
 += 
lda_
;

152 
	gK
 += 
m
.
lda_
;

156 return *
	gthis
;

159 
	gMV_ColMat_float
::
	$MV_ColMat_float
(const 
MV_ColMat_float
 & 
m
) :

160 
	`v_
(
m
.
dim0_
*m.
dim1_
), 
	`dim0_
(m.dim0_),

161 
	`dim1_
(
m
.
dim1_
), 
	`lda_
(m.
dim0_
), 
	$ref_
(0)

164 int 
M
 = 
m
.
dim0_
;

165 int 
N
 = 
m
.
dim1_
;

170 
MV_VecIndex
 
	`I
(0,
M
-1);

171 
MV_VecIndex
 
	`K
(0,
M
-1);

172 for (int 
j
=0; j<
N
; j++)

174 
	`v_
(
I
) = 
m
.v_(
K
);

175 
I
 += 
lda_
;

176 
K
 += 
m
.
lda_
;

178 
	}
}

182 
	gMV_ColMat_float
::
	$MV_ColMat_float
(float* 
d
, int 
m
, int 
n
) :

183 
	`v_
(
m
*
n
), 
	`dim0_
(m), 
	`dim1_
(n), 
	`lda_
(m), 
	$ref_
(0)

185 int 
mn
 = 
m
*
n
;

188 for (int 
i
=0; i< 
mn
; i++)

189 
v_
[
i
] = 
d
[i];

190 
	}
}

193 
	gMV_ColMat_float
::
	$MV_ColMat_float
(float* 
d
, int 
m
, int 
n
,

194 int 
lda
) :

195 
	`v_
(
m
*
n
), 
	`dim0_
(m), 
	`dim1_
(n), 
	`lda_
(
lda
), 
	$ref_
(0)

197 for (int 
j
=0; j< 
n
; j++)

198 for (int 
i
=0; i<
m
; i++)

199 
	`operator
()(
i
,
j
) = 
d
[j*
lda
 + i];

200 
	}
}

203 
MV_ColMat_float
 
	gMV_ColMat_float
::
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
)

207 if (
I
.
	`end
() >= 
dim0_
 || 
J
.end() >= 
dim1_
)

209 
std
::
cerr
 << "Matrix index: (" << 
I
.
	`start
() << ":" << I.
	`end
()

210 << "," << 
J
.
	`start
() << ":" << J.
	`end
()

211 << ") not a subset of (0:" << 
dim0_
 - 1 << ", 0:"

212 << 
dim1_
-1 << ") " << "\n";

213 
	`exit
(1);

218 return 
	`MV_ColMat_float
(&
v_
[
J
.
	`start
()*
lda_
 + 
I
.start()],

219 
I
.
	`end
() - I.
	`start
() + 1,

220 
J
.
	`end
() - J.
	`start
() + 1, 
lda_
, 
MV_Matrix_
::
ref
);

221 
	}
}

223 const 
MV_ColMat_float
 
	gMV_ColMat_float
::
	$operator
()(const 
MV_VecIndex
 &
I
,

224 const 
MV_VecIndex
 &
J
) const

227 
std
::
cerr
 << "Const operator()(MV_VecIndex, MV_VecIndex) called " << "\n";

231 if (
I
.
	`end
() >= 
dim0_
 || 
J
.end() >= 
dim1_
)

233 
std
::
cerr
 << "Matrix index: (" << 
I
.
	`start
() << ":" << I.
	`end
()

234 << "," << 
J
.
	`start
() << ":" << J.
	`end
()

235 << ") not a subset of (0:" << 
dim0_
 - 1 << ", 0:"

236 << 
dim1_
-1 << ") " << "\n";

237 
	`exit
(1);

244 
MV_ColMat_float
 *
t
 = (MV_ColMat_float*) 
this
;

245 return 
	`MV_ColMat_float
(&(
t
->
v_
[
J
.
	`start
()*
lda_
 + 
I
.start()]),

246 
I
.
	`end
() - I.
	`start
() + 1,

247 
J
.
	`end
() - J.
	`start
() + 1, 
lda_
, 
MV_Matrix_
::
ref
);

248 
	}
}

250 
	gMV_ColMat_float
::~
	$MV_ColMat_float
() {
	}
}

252 
std
::
ostream
& 
operator
<<(std::ostream& 
s
, const 
	gMV_ColMat_float
& 
	gV
)

254 int 
	gM
 = 
V
.
dim
(0);

255 int 
	gN
 = 
V
.
dim
(1);

257 for (int 
	gi
=0; i<
	gM
; i++)

259 for (int 
	gj
=0; j<
	gN
; j++)

260 
	gs
 << 
V
(
i
,
j
) << " " ;

261 
	gs
 << "\n";

264 return 
	gs
;

	@mv/src/mvmi.cc

29 #include 
	~<iostream
>

30 #include 
	~"mvmi.h
"

32 int 
	gMV_ColMat_int
::
	$dim
(int 
i
) const

34 if (
i
==0) return 
dim0_
;

35 if (
i
==1) return 
dim1_
;

38 
std
::
cerr
 << "Called MV_ColMat::dim(" << 
i
 << ") must be 0 or 1 " << "\n";

39 
	`exit
(1);

45 
	}
}

49 
	gMV_ColMat_int
::
	$MV_ColMat_int
() : 
	`v_
(), 
	`dim0_
(0), 
	`dim1_
(0) , 
	`lda_
(0), 
	$ref_
(0){
	}
}

52 
	gMV_ColMat_int
::
	$MV_ColMat_int
( int 
m
, int 
n
) : 
	`v_
(m*n),

53 
	`dim0_
(
m
), 
	`dim1_
(
n
), 
	`lda_
(m), 
	$ref_
(0) {
	}
}

55 
	gMV_ColMat_int
::
	$MV_ColMat_int
( int 
m
, int 
n
, const int &
s
) : 
	`v_
(m*n),

56 
	`dim0_
(
m
), 
	`dim1_
(
n
), 
	`lda_
(m), 
	$ref_
(0)

58 
operator
=(
s
);

59 
	}
}

68 
	gMV_ColMat_int
& MV_ColMat_int::
operator
=(const int & 
s
)

70 int 
M
 = 
dim
(0);

71 int 
	gN
 = 
dim
(1);

73 if (
	glda_
 == 
M
)

74 
v_
 = 
s
;

82 
MV_VecIndex
 
I
(0,
M
-1);

83 for (int 
	gj
=0; j<
	gN
; j++)

85 
v_
(
I
) = 
s
;

86 
	gI
 += 
lda_
;

90 return *
	gthis
;

93 
	gMV_ColMat_int
& MV_ColMat_int::
	$newsize
( int 
M
, int 
N
)

95 
v_
.
	`newsize
(
M
*
N
);

96 
dim0_
 = 
M
;

97 
dim1_
 = 
N
;

98 
lda_
 = 
M
;

100 return *
this
;

101 
	}
}

103 
	gMV_ColMat_int
& MV_ColMat_int::
operator
=(const 
MV_ColMat_int
 & 
m
)

106 int 
lM
 = 
dim0_
;

107 int 
	glN
 = 
dim1_
;

109 int 
	grM
 = 
m
.
dim0_
;

110 int 
	grN
 = 
m
.
dim1_
;

117 if (
	gref_
)

120 if (
	glM
 != 
rM
 || 
lN
 != 
rN
)

122 
std
::
cerr
 << "MV_ColMatRef::operator= non-conformant assignment.\n";

123 
exit
(1);

128 
newsize
(
rM
,
rN
);

137 if ( 
	glM
 == 
lda_
 && 
rM
 == 
m
.lda_)

139 
MV_VecIndex
 
I
(0,
rM
*
rN
-1);

140 
v_
(
I
) = 
m
.v_(I);

146 
MV_VecIndex
 
I
(0,
rM
-1);

147 
MV_VecIndex
 
K
(0,
rM
-1);

148 for (int 
	gj
=0; j<
	grN
; j++)

150 
v_
(
I
) = 
m
.v_(
K
);

151 
	gI
 += 
lda_
;

152 
	gK
 += 
m
.
lda_
;

156 return *
	gthis
;

159 
	gMV_ColMat_int
::
	$MV_ColMat_int
(const 
MV_ColMat_int
 & 
m
) :

160 
	`v_
(
m
.
dim0_
*m.
dim1_
), 
	`dim0_
(m.dim0_),

161 
	`dim1_
(
m
.
dim1_
), 
	`lda_
(m.
dim0_
), 
	$ref_
(0)

164 int 
M
 = 
m
.
dim0_
;

165 int 
N
 = 
m
.
dim1_
;

170 
MV_VecIndex
 
	`I
(0,
M
-1);

171 
MV_VecIndex
 
	`K
(0,
M
-1);

172 for (int 
j
=0; j<
N
; j++)

174 
	`v_
(
I
) = 
m
.v_(
K
);

175 
I
 += 
lda_
;

176 
K
 += 
m
.
lda_
;

178 
	}
}

182 
	gMV_ColMat_int
::
	$MV_ColMat_int
(int* 
d
, int 
m
, int 
n
) :

183 
	`v_
(
m
*
n
), 
	`dim0_
(m), 
	`dim1_
(n), 
	`lda_
(m), 
	$ref_
(0)

185 int 
mn
 = 
m
*
n
;

188 for (int 
i
=0; i< 
mn
; i++)

189 
v_
[
i
] = 
d
[i];

190 
	}
}

193 
	gMV_ColMat_int
::
	$MV_ColMat_int
(int* 
d
, int 
m
, int 
n
,

194 int 
lda
) :

195 
	`v_
(
m
*
n
), 
	`dim0_
(m), 
	`dim1_
(n), 
	`lda_
(
lda
), 
	$ref_
(0)

197 for (int 
j
=0; j< 
n
; j++)

198 for (int 
i
=0; i<
m
; i++)

199 
	`operator
()(
i
,
j
) = 
d
[j*
lda
 + i];

200 
	}
}

203 
MV_ColMat_int
 
	gMV_ColMat_int
::
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
)

207 if (
I
.
	`end
() >= 
dim0_
 || 
J
.end() >= 
dim1_
)

209 
std
::
cerr
 << "Matrix index: (" << 
I
.
	`start
() << ":" << I.
	`end
()

210 << "," << 
J
.
	`start
() << ":" << J.
	`end
()

211 << ") not a subset of (0:" << 
dim0_
 - 1 << ", 0:"

212 << 
dim1_
-1 << ") " << "\n";

213 
	`exit
(1);

218 return 
	`MV_ColMat_int
(&
v_
[
J
.
	`start
()*
lda_
 + 
I
.start()],

219 
I
.
	`end
() - I.
	`start
() + 1,

220 
J
.
	`end
() - J.
	`start
() + 1, 
lda_
, 
MV_Matrix_
::
ref
);

221 
	}
}

223 const 
MV_ColMat_int
 
	gMV_ColMat_int
::
	$operator
()(const 
MV_VecIndex
 &
I
,

224 const 
MV_VecIndex
 &
J
) const

227 
std
::
cerr
 << "Const operator()(MV_VecIndex, MV_VecIndex) called " << "\n";

231 if (
I
.
	`end
() >= 
dim0_
 || 
J
.end() >= 
dim1_
)

233 
std
::
cerr
 << "Matrix index: (" << 
I
.
	`start
() << ":" << I.
	`end
()

234 << "," << 
J
.
	`start
() << ":" << J.
	`end
()

235 << ") not a subset of (0:" << 
dim0_
 - 1 << ", 0:"

236 << 
dim1_
-1 << ") " << "\n";

237 
	`exit
(1);

244 
MV_ColMat_int
 *
t
 = (MV_ColMat_int*) 
this
;

245 return 
	`MV_ColMat_int
(&(
t
->
v_
[
J
.
	`start
()*
lda_
 + 
I
.start()]),

246 
I
.
	`end
() - I.
	`start
() + 1,

247 
J
.
	`end
() - J.
	`start
() + 1, 
lda_
, 
MV_Matrix_
::
ref
);

248 
	}
}

250 
	gMV_ColMat_int
::~
	$MV_ColMat_int
() {
	}
}

252 
std
::
ostream
& 
operator
<<(std::ostream& 
s
, const 
	gMV_ColMat_int
& 
	gV
)

254 int 
	gM
 = 
V
.
dim
(0);

255 int 
	gN
 = 
V
.
dim
(1);

257 for (int 
	gi
=0; i<
	gM
; i++)

259 for (int 
	gj
=0; j<
	gN
; j++)

260 
	gs
 << 
V
(
i
,
j
) << " " ;

261 
	gs
 << "\n";

264 return 
	gs
;

	@mv/src/mvmt.cc

29 #include 
	~"$INCLUDE
"

30 #include 
	~<iostream
>

32 int 
	gMV_ColMat_$TYPE
::
	$dim
(int 
i
) const

34 if (
i
==0) return 
dim0_
;

35 if (
i
==1) return 
dim1_
;

38 
std
::
cerr
 << "Called MV_ColMat::dim(" << 
i
 << ") must be 0 or 1 " << "\n";

39 
	`exit
(1);

45 
	}
}

49 
	gMV_ColMat_$TYPE
::
	$MV_ColMat_$TYPE
() : 
	`v_
(), 
	`dim0_
(0), 
	`dim1_
(0) , 
	`lda_
(0), 
	$ref_
(0){
	}
}

52 
	gMV_ColMat_$TYPE
::
	$MV_ColMat_$TYPE
( int 
m
, int 
n
) : 
	`v_
(m*n),

53 
	`dim0_
(
m
), 
	`dim1_
(
n
), 
	`lda_
(m), 
	$ref_
(0) {
	}
}

55 
	gMV_ColMat_$TYPE
::
	$MV_ColMat_$TYPE
( int 
m
, int 
n
, const 
$TYPE
 &
s
) : 
	`v_
(m*n),

56 
	`dim0_
(
m
), 
	`dim1_
(
n
), 
	`lda_
(m), 
	$ref_
(0)

58 
operator
=(
s
);

59 
	}
}

68 
	gMV_ColMat_$TYPE
& MV_ColMat_$TYPE::
operator
=(const 
$TYPE
 & 
s
)

70 int 
M
 = 
dim
(0);

71 int 
	gN
 = 
dim
(1);

73 if (
	glda_
 == 
M
)

74 
v_
 = 
s
;

82 
MV_VecIndex
 
I
(0,
M
-1);

83 for (int 
	gj
=0; j<
	gN
; j++)

85 
v_
(
I
) = 
s
;

86 
	gI
 += 
lda_
;

90 return *
	gthis
;

93 
	gMV_ColMat_$TYPE
& MV_ColMat_$TYPE::
	$newsize
( int 
M
, int 
N
)

95 
v_
.
	`newsize
(
M
*
N
);

96 
dim0_
 = 
M
;

97 
dim1_
 = 
N
;

98 
lda_
 = 
M
;

100 return *
this
;

101 
	}
}

103 
	gMV_ColMat_$TYPE
& MV_ColMat_$TYPE::
operator
=(const 
MV_ColMat_$TYPE
 & 
m
)

106 int 
lM
 = 
dim0_
;

107 int 
	glN
 = 
dim1_
;

109 int 
	grM
 = 
m
.
dim0_
;

110 int 
	grN
 = 
m
.
dim1_
;

117 if (
	gref_
)

120 if (
	glM
 != 
rM
 || 
lN
 != 
rN
)

122 
std
::
cerr
 << "MV_ColMatRef::operator= non-conformant assignment.\n";

123 
exit
(1);

128 
newsize
(
rM
,
rN
);

137 if ( 
	glM
 == 
lda_
 && 
rM
 == 
m
.lda_)

139 
MV_VecIndex
 
I
(0,
rM
*
rN
-1);

140 
v_
(
I
) = 
m
.v_(I);

146 
MV_VecIndex
 
I
(0,
rM
-1);

147 
MV_VecIndex
 
K
(0,
rM
-1);

148 for (int 
	gj
=0; j<
	grN
; j++)

150 
v_
(
I
) = 
m
.v_(
K
);

151 
	gI
 += 
lda_
;

152 
	gK
 += 
m
.
lda_
;

156 return *
	gthis
;

159 
	gMV_ColMat_$TYPE
::
	$MV_ColMat_$TYPE
(const 
MV_ColMat_$TYPE
 & 
m
) :

160 
	`v_
(
m
.
dim0_
*m.
dim1_
), 
	`dim0_
(m.dim0_),

161 
	`dim1_
(
m
.
dim1_
), 
	`lda_
(m.
dim0_
), 
	$ref_
(0)

164 int 
M
 = 
m
.
dim0_
;

165 int 
N
 = 
m
.
dim1_
;

170 
MV_VecIndex
 
	`I
(0,
M
-1);

171 
MV_VecIndex
 
	`K
(0,
M
-1);

172 for (int 
j
=0; j<
N
; j++)

174 
	`v_
(
I
) = 
m
.v_(
K
);

175 
I
 += 
lda_
;

176 
K
 += 
m
.
lda_
;

178 
	}
}

182 
	gMV_ColMat_$TYPE
::
	$MV_ColMat_$TYPE
(
$TYPE
* 
d
, int 
m
, int 
n
) :

183 
	`v_
(
m
*
n
), 
	`dim0_
(m), 
	`dim1_
(n), 
	`lda_
(m), 
	$ref_
(0)

185 int 
mn
 = 
m
*
n
;

188 for (int 
i
=0; i< 
mn
; i++)

189 
v_
[
i
] = 
d
[i];

190 
	}
}

193 
	gMV_ColMat_$TYPE
::
	$MV_ColMat_$TYPE
(
$TYPE
* 
d
, int 
m
, int 
n
,

194 int 
lda
) :

195 
	`v_
(
m
*
n
), 
	`dim0_
(m), 
	`dim1_
(n), 
	`lda_
(
lda
), 
	$ref_
(0)

197 for (int 
j
=0; j< 
n
; j++)

198 for (int 
i
=0; i<
m
; i++)

199 
	`operator
()(
i
,
j
) = 
d
[j*
lda
 + i];

200 
	}
}

203 
MV_ColMat_$TYPE
 
	gMV_ColMat_$TYPE
::
	$operator
()(const 
MV_VecIndex
 &
I
, const MV_VecIndex &
J
)

207 if (
I
.
	`end
() >= 
dim0_
 || 
J
.end() >= 
dim1_
)

209 
std
::
cerr
 << "Matrix index: (" << 
I
.
	`start
() << ":" << I.
	`end
()

210 << "," << 
J
.
	`start
() << ":" << J.
	`end
()

211 << ") not a subset of (0:" << 
dim0_
 - 1 << ", 0:"

212 << 
dim1_
-1 << ") " << "\n";

213 
	`exit
(1);

218 return 
	`MV_ColMat_$TYPE
(&
v_
[
J
.
	`start
()*
lda_
 + 
I
.start()],

219 
I
.
	`end
() - I.
	`start
() + 1,

220 
J
.
	`end
() - J.
	`start
() + 1, 
lda_
, 
MV_Matrix_
::
ref
);

221 
	}
}

223 const 
MV_ColMat_$TYPE
 
	gMV_ColMat_$TYPE
::
	$operator
()(const 
MV_VecIndex
 &
I
,

224 const 
MV_VecIndex
 &
J
) const

227 
std
::
cerr
 << "Const operator()(MV_VecIndex, MV_VecIndex) called " << "\n";

231 if (
I
.
	`end
() >= 
dim0_
 || 
J
.end() >= 
dim1_
)

233 
std
::
cerr
 << "Matrix index: (" << 
I
.
	`start
() << ":" << I.
	`end
()

234 << "," << 
J
.
	`start
() << ":" << J.
	`end
()

235 << ") not a subset of (0:" << 
dim0_
 - 1 << ", 0:"

236 << 
dim1_
-1 << ") " << "\n";

237 
	`exit
(1);

244 
MV_ColMat_$TYPE
 *
t
 = (MV_ColMat_$TYPE*) 
this
;

245 return 
	`MV_ColMat_$TYPE
(&(
t
->
v_
[
J
.
	`start
()*
lda_
 + 
I
.start()]),

246 
I
.
	`end
() - I.
	`start
() + 1,

247 
J
.
	`end
() - J.
	`start
() + 1, 
lda_
, 
MV_Matrix_
::
ref
);

248 
	}
}

250 
	gMV_ColMat_$TYPE
::~
	$MV_ColMat_$TYPE
() {
	}
}

252 
std
::
ostream
& 
operator
<<(std::ostream& 
s
, const 
	gMV_ColMat_$TYPE
& 
	gV
)

254 int 
	gM
 = 
V
.
dim
(0);

255 int 
	gN
 = 
V
.
dim
(1);

257 for (int 
	gi
=0; i<
	gM
; i++)

259 for (int 
	gj
=0; j<
	gN
; j++)

260 
	gs
 << 
V
(
i
,
j
) << " " ;

261 
	gs
 << "\n";

264 return 
	gs
;

	@mv/src/mvvc.cc

30 #include 
	~<iostream
>

31 #include 
	~"mvv.h
"

34 
	gMV_Vector_COMPLEX
::
	$MV_Vector_COMPLEX
() : 
	`p_
(0), 
	`dim_
(0) , 
	$ref_
(0){
	}
}

36 
	gMV_Vector_COMPLEX
::
	$MV_Vector_COMPLEX
( int 
n
) : 
	`p_
(
new
 
COMPLEX
[n]), 
	`dim_
(n),

37 
	$ref_
(0)

39 if (
p_
 == 
NULL
)

41 
std
::
cerr
 << "Error: NULL pointer in MV_Vector_COMPLEX(int) constructor " << "\n";

42 
std
::
cerr
 << " Most likely out of memory... " << "\n";

43 
	`exit
(1);

45 
	}
}

48 
	gMV_Vector_COMPLEX
::
	$MV_Vector_COMPLEX
( int 
n
, const 
COMPLEX
& 
v
) :

49 
	`p_
(
new
 
COMPLEX
[
n
]), 
	`dim_
(n), 
	$ref_
(0)

51 if (
p_
 == 
NULL
)

53 
std
::
cerr
 << "Error: NULL pointer in MV_Vector_COMPLEX(int) constructor " << "\n";

54 
std
::
cerr
 << " Most likely out of memory... " << "\n";

55 
	`exit
(1);

57 for (int 
i
=0; i<
n
; i++)

58 
p_
[
i
] = 
v
;

59 
	}
}

65 
	gMV_Vector_COMPLEX
& MV_Vector_COMPLEX::
operator
=(const 
COMPLEX
 & 
m
)

67 #ifdef 
TRACE_VEC


68 
cout
 << "> MV_Vector_COMPLEX::operator=(const COMPLEX & m) " << "\n";

73 int 
	gN
 = 
size
();

75 int 
	gNminus4
 = 
N
-4;

76 int 
	gi
;

78 for (
	gi
=0; i<
	gNminus4
; )

80 
	gp_
[
i
++] = 
m
;

81 
	gp_
[
i
++] = 
m
;

82 
	gp_
[
i
++] = 
m
;

83 
	gp_
[
i
++] = 
m
;

86 for (; 
	gi
<
	gN
; 
	gp_
[
i
++] = 
m
);

88 #ifdef 
TRACE_VEC


89 
	gcout
 << "< MV_Vector_COMPLEX::operator=(const COMPLEX & m) " << "\n";

91 return *
	gthis
;

95 
	gMV_Vector_COMPLEX
& MV_Vector_COMPLEX::
	$newsize
( int 
n
)

97 #ifdef 
TRACE_VEC


98 
cout
 << "> MV_Vector_COMPLEX::newsize( int n) " << "\n";

100 if (
ref_
 )

103 
std
::
cerr
 << "MV_Vector::newsize can't operator on references.\n";

104 
	`exit
(1);

108 if (
dim_
 != 
n
 )

110 if (
p_
) 
delete
 [] p_;

111 
p_
 = 
new
 
COMPLEX
[
n
];

112 if (
p_
 == 
NULL
)

114 
std
::
cerr
 << "Error : NULL pointer in operator= " << "\n";

115 
	`exit
(1);

117 
dim_
 = 
n
;

120 #ifdef 
TRACE_VEC


121 
cout
 << "< MV_Vector_COMPLEX::newsize( int n) " << "\n";

124 return *
this
;

125 
	}
}

131 
	gMV_Vector_COMPLEX
& MV_Vector_COMPLEX::
operator
=(const 
MV_Vector_COMPLEX
 & 
m
)

134 int 
N
 = 
m
.
dim_
;

135 int 
	gi
;

137 if (
	gref_
 )

139 if (
	gdim_
 != 
m
.
dim_
)

141 
std
::
cerr
 << "MV_VectorRef::operator= non-conformant assignment.\n";

142 
exit
(1);

146 if ((
	gm
.
	gp_
 + m.
	gdim_
) >= 
p_
)

149 for (
i
= 
N
-1; 
	gi
>=0; i--)

150 
	gp_
[
i
] = 
m
.
p_
[i];

154 for (
	gi
=0; i<
	gN
; i++)

155 
	gp_
[
i
] = 
m
.
p_
[i];

161 
newsize
(
N
);

164 for (
	gi
 =0; i< 
	gN
; i++)

165 
	gp_
[
i
] = 
m
.
p_
[i];

167 return *
	gthis
;

171 
	gMV_Vector_COMPLEX
::
	$MV_Vector_COMPLEX
(const 
MV_Vector_COMPLEX
 & 
m
) : 
	`p_
(
new
 
COMPLEX
[m.
dim_
]),

172 
	`dim_
(
m
.
dim_
) , 
	$ref_
(0)

174 if (
p_
 == 
NULL
)

176 
std
::
cerr
 << "Error: Null pointer in MV_Vector_COMPLEX(const MV_Vector&); " << "\n";

177 
	`exit
(1);

180 int 
N
 = 
m
.
dim_
;

182 for (int 
i
=0; i<
N
; i++)

183 
p_
[
i
] = 
m
.p_[i];

184 
	}
}

186 
	gMV_Vector_COMPLEX
::
	$MV_Vector_COMPLEX
(
COMPLEX
* 
d
, int 
n
) : 
	`p_
(
new
 COMPLEX[n]),

187 
	`dim_
(
n
) , 
	$ref_
(0)

189 if (
p_
 == 
NULL
)

191 
std
::
cerr
 << "Error: Null pointer in MV_Vector_COMPLEX(COMPLEX*, int) " << "\n";

192 
	`exit
(1);

194 for (int 
i
=0; i<
n
; i++)

195 
p_
[
i
] = 
d
[i];

197 
	}
}

201 
	gMV_Vector_COMPLEX
::
	$MV_Vector_COMPLEX
(const 
COMPLEX
* 
d
, int 
n
) : 
	`p_
(
new
 COMPLEX[n]),

202 
	`dim_
(
n
) , 
	$ref_
(0)

204 if (
p_
 == 
NULL
)

206 
std
::
cerr
 << "Error: Null pointer in MV_Vector_COMPLEX(COMPLEX*, int) " << "\n";

207 
	`exit
(1);

209 for (int 
i
=0; i<
n
; i++)

210 
p_
[
i
] = 
d
[i];

212 
	}
}

215 
MV_Vector_COMPLEX
 
	gMV_Vector_COMPLEX
::
	$operator
()(void)

217 return 
	`MV_Vector_COMPLEX
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

218 
	}
}

221 const 
MV_Vector_COMPLEX
 
	gMV_Vector_COMPLEX
::
	$operator
()(void) const

223 return 
	`MV_Vector_COMPLEX
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

224 
	}
}

227 
MV_Vector_COMPLEX
 
	gMV_Vector_COMPLEX
::
	$operator
()(const 
MV_VecIndex
 &
I
)

230 if (
I
.
	`all
())

231 return 
	`MV_Vector_COMPLEX
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

236 if ( 
I
.
	`end
() >= 
dim_
)

238 
std
::
cerr
 << "MV_VecIndex: (" << 
I
.
	`start
() << ":" << I.
	`end
() <<

239 ") too big for matrix (0:" << 
dim_
 - 1 << ") " << "\n";

240 
	`exit
(1);

242 return 
	`MV_Vector_COMPLEX
(
p_
+ 
I
.
	`start
(), I.
	`end
() - I.start() + 1,

243 
MV_Vector_
::
ref
);

245 
	}
}

248 const 
MV_Vector_COMPLEX
 
	gMV_Vector_COMPLEX
::
	$operator
()(const 
MV_VecIndex
 &
I
) const

252 if (
I
.
	`all
())

253 return 
	`MV_Vector_COMPLEX
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

256 if ( 
I
.
	`end
() >= 
dim_
)

258 
std
::
cerr
 << "MV_VecIndex: (" << 
I
.
	`start
() << ":" << I.
	`end
() <<

259 ") too big for matrix (0:" << 
dim_
 - 1 << ") " << "\n";

260 
	`exit
(1);

262 return 
	`MV_Vector_COMPLEX
(
p_
+ 
I
.
	`start
(), I.
	`end
() - I.start() + 1,

263 
MV_Vector_
::
ref
);

265 
	}
}

268 
	gMV_Vector_COMPLEX
::~
	$MV_Vector_COMPLEX
()

270 if (
p_
 && !
ref_
 ) 
delete
 [] p_;

271 
	}
}

274 
	gstd
::
ostream
& 
operator
<<(
std
::ostream& 
s
, const 
	gMV_Vector_COMPLEX
& 
	gV
)

276 int 
	gN
 = 
V
.
size
();

278 for (int 
	gi
=0; i< 
	gN
; i++)

279 
	gs
 << 
V
(
i
) << "\n";

281 return 
	gs
;

	@mv/src/mvvcio.cc

6 #ifdef 
COMPLEX_OSTREAM


7 #include 
	~<complex.h
>

8 #include 
	~<iostream
>

12 
	gstd
::
ostream
& 
operator
<<(
std
::ostream &
s
, 
COMPLEX
 
	gz
)

14 
	gs
 << (double) 
real
(
z
) << " " << (double) 
imag
(z) ;

15 return 
	gs
;

	@mv/src/mvvd.cc

30 #include 
	~<iostream
>

31 #include 
	~"mvvd.h
"

34 
	gMV_Vector_double
::
	$MV_Vector_double
() : 
	`p_
(0), 
	`dim_
(0) , 
	$ref_
(0){
	}
}

36 
	gMV_Vector_double
::
	$MV_Vector_double
( int 
n
) : 
	`p_
(
new
 double[n]), 
	`dim_
(n),

37 
	$ref_
(0)

39 if (
p_
 == 
NULL
)

41 
std
::
cerr
 << "Error: NULL pointer in MV_Vector_double(int) constructor " << "\n";

42 
std
::
cerr
 << " Most likely out of memory... " << "\n";

43 
	`exit
(1);

45 
	}
}

48 
	gMV_Vector_double
::
	$MV_Vector_double
( int 
n
, const double& 
v
) :

49 
	`p_
(
new
 double[
n
]), 
	`dim_
(n), 
	$ref_
(0)

51 if (
p_
 == 
NULL
)

53 
std
::
cerr
 << "Error: NULL pointer in MV_Vector_double(int) constructor " << "\n";

54 
std
::
cerr
 << " Most likely out of memory... " << "\n";

55 
	`exit
(1);

57 for (int 
i
=0; i<
n
; i++)

58 
p_
[
i
] = 
v
;

59 
	}
}

65 
	gMV_Vector_double
& MV_Vector_double::
operator
=(const double & 
m
)

67 #ifdef 
TRACE_VEC


68 
cout
 << "> MV_Vector_double::operator=(const double & m) " << "\n";

73 int 
	gN
 = 
size
();

75 int 
	gNminus4
 = 
N
-4;

76 int 
	gi
;

78 for (
	gi
=0; i<
	gNminus4
; )

80 
	gp_
[
i
++] = 
m
;

81 
	gp_
[
i
++] = 
m
;

82 
	gp_
[
i
++] = 
m
;

83 
	gp_
[
i
++] = 
m
;

86 for (; 
	gi
<
	gN
; 
	gp_
[
i
++] = 
m
);

88 #ifdef 
TRACE_VEC


89 
	gcout
 << "< MV_Vector_double::operator=(const double & m) " << "\n";

91 return *
	gthis
;

95 
	gMV_Vector_double
& MV_Vector_double::
	$newsize
( int 
n
)

97 #ifdef 
TRACE_VEC


98 
cout
 << "> MV_Vector_double::newsize( int n) " << "\n";

100 if (
ref_
 )

103 
std
::
cerr
 << "MV_Vector::newsize can't operator on references.\n";

104 
	`exit
(1);

108 if (
dim_
 != 
n
 )

110 if (
p_
) 
delete
 [] p_;

111 
p_
 = 
new
 double[
n
];

112 if (
p_
 == 
NULL
)

114 
std
::
cerr
 << "Error : NULL pointer in operator= " << "\n";

115 
	`exit
(1);

117 
dim_
 = 
n
;

120 #ifdef 
TRACE_VEC


121 
cout
 << "< MV_Vector_double::newsize( int n) " << "\n";

124 return *
this
;

125 
	}
}

131 
	gMV_Vector_double
& MV_Vector_double::
operator
=(const 
MV_Vector_double
 & 
m
)

134 int 
N
 = 
m
.
dim_
;

135 int 
	gi
;

137 if (
	gref_
 )

139 if (
	gdim_
 != 
m
.
dim_
)

141 
std
::
cerr
 << "MV_VectorRef::operator= non-conformant assignment.\n";

142 
exit
(1);

146 if ((
	gm
.
	gp_
 + m.
	gdim_
) >= 
p_
)

149 for (
i
= 
N
-1; 
	gi
>=0; i--)

150 
	gp_
[
i
] = 
m
.
p_
[i];

154 for (
	gi
=0; i<
	gN
; i++)

155 
	gp_
[
i
] = 
m
.
p_
[i];

161 
newsize
(
N
);

164 for (
	gi
 =0; i< 
	gN
; i++)

165 
	gp_
[
i
] = 
m
.
p_
[i];

167 return *
	gthis
;

171 
	gMV_Vector_double
::
	$MV_Vector_double
(const 
MV_Vector_double
 & 
m
) : 
	`p_
(
new
 double[m.
dim_
]),

172 
	`dim_
(
m
.
dim_
) , 
	$ref_
(0)

174 if (
p_
 == 
NULL
)

176 
std
::
cerr
 << "Error: Null pointer in MV_Vector_double(const MV_Vector&); " << "\n";

177 
	`exit
(1);

180 int 
N
 = 
m
.
dim_
;

182 for (int 
i
=0; i<
N
; i++)

183 
p_
[
i
] = 
m
.p_[i];

184 
	}
}

186 
	gMV_Vector_double
::
	$MV_Vector_double
(double* 
d
, int 
n
) : 
	`p_
(
new
 double[n]),

187 
	`dim_
(
n
) , 
	$ref_
(0)

189 if (
p_
 == 
NULL
)

191 
std
::
cerr
 << "Error: Null pointer in MV_Vector_double(double*, int) " << "\n";

192 
	`exit
(1);

194 for (int 
i
=0; i<
n
; i++)

195 
p_
[
i
] = 
d
[i];

197 
	}
}

201 
	gMV_Vector_double
::
	$MV_Vector_double
(const double* 
d
, int 
n
) : 
	`p_
(
new
 double[n]),

202 
	`dim_
(
n
) , 
	$ref_
(0)

204 if (
p_
 == 
NULL
)

206 
std
::
cerr
 << "Error: Null pointer in MV_Vector_double(double*, int) " << "\n";

207 
	`exit
(1);

209 for (int 
i
=0; i<
n
; i++)

210 
p_
[
i
] = 
d
[i];

212 
	}
}

215 
MV_Vector_double
 
	gMV_Vector_double
::
	$operator
()(void)

217 return 
	`MV_Vector_double
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

218 
	}
}

221 const 
MV_Vector_double
 
	gMV_Vector_double
::
	$operator
()(void) const

223 return 
	`MV_Vector_double
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

224 
	}
}

227 
MV_Vector_double
 
	gMV_Vector_double
::
	$operator
()(const 
MV_VecIndex
 &
I
)

230 if (
I
.
	`all
())

231 return 
	`MV_Vector_double
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

236 if ( 
I
.
	`end
() >= 
dim_
)

238 
std
::
cerr
 << "MV_VecIndex: (" << 
I
.
	`start
() << ":" << I.
	`end
() <<

239 ") too big for matrix (0:" << 
dim_
 - 1 << ") " << "\n";

240 
	`exit
(1);

242 return 
	`MV_Vector_double
(
p_
+ 
I
.
	`start
(), I.
	`end
() - I.start() + 1,

243 
MV_Vector_
::
ref
);

245 
	}
}

248 const 
MV_Vector_double
 
	gMV_Vector_double
::
	$operator
()(const 
MV_VecIndex
 &
I
) const

252 if (
I
.
	`all
())

253 return 
	`MV_Vector_double
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

256 if ( 
I
.
	`end
() >= 
dim_
)

258 
std
::
cerr
 << "MV_VecIndex: (" << 
I
.
	`start
() << ":" << I.
	`end
() <<

259 ") too big for matrix (0:" << 
dim_
 - 1 << ") " << "\n";

260 
	`exit
(1);

262 return 
	`MV_Vector_double
(
p_
+ 
I
.
	`start
(), I.
	`end
() - I.start() + 1,

263 
MV_Vector_
::
ref
);

265 
	}
}

268 
	gMV_Vector_double
::~
	$MV_Vector_double
()

270 if (
p_
 && !
ref_
 ) 
delete
 [] p_;

271 
	}
}

274 
	gstd
::
ostream
& 
operator
<<(
std
::ostream& 
s
, const 
	gMV_Vector_double
& 
	gV
)

276 int 
	gN
 = 
V
.
size
();

278 for (int 
	gi
=0; i< 
	gN
; i++)

279 
	gs
 << 
V
(
i
) << "\n";

281 return 
	gs
;

	@mv/src/mvvdio.cc

1 #include 
	~<iostream
>

2 #include 
	~<stdio.h
>

3 #include 
	~"mvvd.h
"

4 #include 
	~"mvvi.h
"

5 #include 
	~"iotext.h
"

6 #include 
	~<errno.h
>

8 int 
	$writetxtfile_vec
(const char *
filename
, const 
MV_Vector_double
 &
A
)

10 
FILE
 *
in_file
;

12 
in_file
 = 
	`fopen
(
filename
, "w");

13 if (
in_file
 == 
NULL
)

15 
	`fprintf
(
stderr
,"Cannot open file: %s\n", 
filename
 );

16 
	`exit
(1);

18 int 
N
 = 
A
.
	`size
();

20 for (int 
i
=0; i<
N
; i++)

22 
	`fprintf
(
in_file
, "%g\n", 
	`A
(
i
));

25 
	`fclose
(
in_file
);

28 
	}
}

30 int 
	$readtxtfile_vec
(const char *
filename
, 
MV_Vector_double
 *
Aptr
)

32 
FILE
 *
in_file
;

33 char 
line
[82];

34 char *
line_ptr
;

35 int 
count
=0;

36 double 
tmp
;

37 
MV_Vector_double
 &
A
 = *
Aptr
;

39 
in_file
 = 
	`fopen
( 
filename
, "r");

40 if (
in_file
 == 
NULL
)

42 
std
::
cerr
 << "Cannot open file: " << 
filename
 << ", errno=" << 
errno
 << " \n";

43 
	`exit
(1);

47 while ( 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
))

48 if (
	`sscanf
(
line_ptr
, "%lg", &
tmp
) >= 1) 
count
++;

50 
	`rewind
(
in_file
);

52 
A
.
	`newsize
(
count
);

53 for (int 
i
=0; i< 
count
; i++)

55 if (
	`fscanf
(
in_file
, "%lg", &
	`A
(
i
)) < 1)

57 
	`printf
("Error reading %s\n", 
filename
);

58 
	`exit
(1);

62 
	`fclose
(
in_file
);

65 
	}
}

68 int 
	$writetxtfile_vec
(const char *
filename
, const 
MV_Vector_int
 &
A
)

70 
FILE
 *
in_file
;

72 
in_file
 = 
	`fopen
(
filename
, "w");

73 if (
in_file
 == 
NULL
)

75 
	`fprintf
(
stderr
,"Cannot open file: %s\n", 
filename
 );

76 
	`exit
(1);

78 int 
N
 = 
A
.
	`size
();

80 for (int 
i
=0; i<
N
; i++)

82 
	`fprintf
(
in_file
, "%d\n", 
	`A
(
i
));

85 
	`fclose
(
in_file
);

88 
	}
}

90 int 
	$readtxtfile_vec
(const char *
filename
, 
MV_Vector_int
 *
Aptr
)

92 
FILE
 *
in_file
;

93 char 
line
[82];

94 char *
line_ptr
;

95 int 
count
=0;

96 
MV_Vector_int
 &
A
 = *
Aptr
;

97 int 
tmp
;

99 
in_file
 = 
	`fopen
( 
filename
, "r");

100 if (
in_file
 == 
NULL
)

102 
std
::
cerr
 << "Cannot open file: " << 
filename
 << "\n";

103 
	`exit
(1);

107 while ( 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
))

108 if (
	`sscanf
(
line_ptr
, "%d", &
tmp
) >= 1) 
count
++;

110 
	`rewind
(
in_file
);

112 
A
.
	`newsize
(
count
);

113 for (int 
i
=0; i< 
count
; i++)

115 if (
	`fscanf
(
in_file
, "%d", &
	`A
(
i
)) < 1)

117 
	`printf
("Error reading %s\n", 
filename
);

118 
	`exit
(1);

122 
	`fclose
(
in_file
);

125 
	}
}

	@mv/src/mvvf.cc

30 #include 
	~<iostream
>

31 #include 
	~"mvvf.h
"

34 
	gMV_Vector_float
::
	$MV_Vector_float
() : 
	`p_
(0), 
	`dim_
(0) , 
	$ref_
(0){
	}
}

36 
	gMV_Vector_float
::
	$MV_Vector_float
( int 
n
) : 
	`p_
(
new
 float[n]), 
	`dim_
(n),

37 
	$ref_
(0)

39 if (
p_
 == 
NULL
)

41 
std
::
cerr
 << "Error: NULL pointer in MV_Vector_float(int) constructor " << "\n";

42 
std
::
cerr
 << " Most likely out of memory... " << "\n";

43 
	`exit
(1);

45 
	}
}

48 
	gMV_Vector_float
::
	$MV_Vector_float
( int 
n
, const float& 
v
) :

49 
	`p_
(
new
 float[
n
]), 
	`dim_
(n), 
	$ref_
(0)

51 if (
p_
 == 
NULL
)

53 
std
::
cerr
 << "Error: NULL pointer in MV_Vector_float(int) constructor " << "\n";

54 
std
::
cerr
 << " Most likely out of memory... " << "\n";

55 
	`exit
(1);

57 for (int 
i
=0; i<
n
; i++)

58 
p_
[
i
] = 
v
;

59 
	}
}

65 
	gMV_Vector_float
& MV_Vector_float::
operator
=(const float & 
m
)

67 #ifdef 
TRACE_VEC


68 
cout
 << "> MV_Vector_float::operator=(const float & m) " << "\n";

73 int 
	gN
 = 
size
();

75 int 
	gNminus4
 = 
N
-4;

76 int 
	gi
;

78 for (
	gi
=0; i<
	gNminus4
; )

80 
	gp_
[
i
++] = 
m
;

81 
	gp_
[
i
++] = 
m
;

82 
	gp_
[
i
++] = 
m
;

83 
	gp_
[
i
++] = 
m
;

86 for (; 
	gi
<
	gN
; 
	gp_
[
i
++] = 
m
);

88 #ifdef 
TRACE_VEC


89 
	gcout
 << "< MV_Vector_float::operator=(const float & m) " << "\n";

91 return *
	gthis
;

95 
	gMV_Vector_float
& MV_Vector_float::
	$newsize
( int 
n
)

97 #ifdef 
TRACE_VEC


98 
cout
 << "> MV_Vector_float::newsize( int n) " << "\n";

100 if (
ref_
 )

103 
std
::
cerr
 << "MV_Vector::newsize can't operator on references.\n";

104 
	`exit
(1);

108 if (
dim_
 != 
n
 )

110 if (
p_
) 
delete
 [] p_;

111 
p_
 = 
new
 float[
n
];

112 if (
p_
 == 
NULL
)

114 
std
::
cerr
 << "Error : NULL pointer in operator= " << "\n";

115 
	`exit
(1);

117 
dim_
 = 
n
;

120 #ifdef 
TRACE_VEC


121 
cout
 << "< MV_Vector_float::newsize( int n) " << "\n";

124 return *
this
;

125 
	}
}

131 
	gMV_Vector_float
& MV_Vector_float::
operator
=(const 
MV_Vector_float
 & 
m
)

134 int 
N
 = 
m
.
dim_
;

135 int 
	gi
;

137 if (
	gref_
 )

139 if (
	gdim_
 != 
m
.
dim_
)

141 
std
::
cerr
 << "MV_VectorRef::operator= non-conformant assignment.\n";

142 
exit
(1);

146 if ((
	gm
.
	gp_
 + m.
	gdim_
) >= 
p_
)

149 for (
i
= 
N
-1; 
	gi
>=0; i--)

150 
	gp_
[
i
] = 
m
.
p_
[i];

154 for (
	gi
=0; i<
	gN
; i++)

155 
	gp_
[
i
] = 
m
.
p_
[i];

161 
newsize
(
N
);

164 for (
	gi
 =0; i< 
	gN
; i++)

165 
	gp_
[
i
] = 
m
.
p_
[i];

167 return *
	gthis
;

171 
	gMV_Vector_float
::
	$MV_Vector_float
(const 
MV_Vector_float
 & 
m
) : 
	`p_
(
new
 float[m.
dim_
]),

172 
	`dim_
(
m
.
dim_
) , 
	$ref_
(0)

174 if (
p_
 == 
NULL
)

176 
std
::
cerr
 << "Error: Null pointer in MV_Vector_float(const MV_Vector&); " << "\n";

177 
	`exit
(1);

180 int 
N
 = 
m
.
dim_
;

182 for (int 
i
=0; i<
N
; i++)

183 
p_
[
i
] = 
m
.p_[i];

184 
	}
}

186 
	gMV_Vector_float
::
	$MV_Vector_float
(float* 
d
, int 
n
) : 
	`p_
(
new
 float[n]),

187 
	`dim_
(
n
) , 
	$ref_
(0)

189 if (
p_
 == 
NULL
)

191 
std
::
cerr
 << "Error: Null pointer in MV_Vector_float(float*, int) " << "\n";

192 
	`exit
(1);

194 for (int 
i
=0; i<
n
; i++)

195 
p_
[
i
] = 
d
[i];

197 
	}
}

201 
	gMV_Vector_float
::
	$MV_Vector_float
(const float* 
d
, int 
n
) : 
	`p_
(
new
 float[n]),

202 
	`dim_
(
n
) , 
	$ref_
(0)

204 if (
p_
 == 
NULL
)

206 
std
::
cerr
 << "Error: Null pointer in MV_Vector_float(float*, int) " << "\n";

207 
	`exit
(1);

209 for (int 
i
=0; i<
n
; i++)

210 
p_
[
i
] = 
d
[i];

212 
	}
}

215 
MV_Vector_float
 
	gMV_Vector_float
::
	$operator
()(void)

217 return 
	`MV_Vector_float
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

218 
	}
}

221 const 
MV_Vector_float
 
	gMV_Vector_float
::
	$operator
()(void) const

223 return 
	`MV_Vector_float
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

224 
	}
}

227 
MV_Vector_float
 
	gMV_Vector_float
::
	$operator
()(const 
MV_VecIndex
 &
I
)

230 if (
I
.
	`all
())

231 return 
	`MV_Vector_float
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

236 if ( 
I
.
	`end
() >= 
dim_
)

238 
std
::
cerr
 << "MV_VecIndex: (" << 
I
.
	`start
() << ":" << I.
	`end
() <<

239 ") too big for matrix (0:" << 
dim_
 - 1 << ") " << "\n";

240 
	`exit
(1);

242 return 
	`MV_Vector_float
(
p_
+ 
I
.
	`start
(), I.
	`end
() - I.start() + 1,

243 
MV_Vector_
::
ref
);

245 
	}
}

248 const 
MV_Vector_float
 
	gMV_Vector_float
::
	$operator
()(const 
MV_VecIndex
 &
I
) const

252 if (
I
.
	`all
())

253 return 
	`MV_Vector_float
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

256 if ( 
I
.
	`end
() >= 
dim_
)

258 
std
::
cerr
 << "MV_VecIndex: (" << 
I
.
	`start
() << ":" << I.
	`end
() <<

259 ") too big for matrix (0:" << 
dim_
 - 1 << ") " << "\n";

260 
	`exit
(1);

262 return 
	`MV_Vector_float
(
p_
+ 
I
.
	`start
(), I.
	`end
() - I.start() + 1,

263 
MV_Vector_
::
ref
);

265 
	}
}

268 
	gMV_Vector_float
::~
	$MV_Vector_float
()

270 if (
p_
 && !
ref_
 ) 
delete
 [] p_;

271 
	}
}

274 
	gstd
::
ostream
& 
operator
<<(
std
::ostream& 
s
, const 
	gMV_Vector_float
& 
	gV
)

276 int 
	gN
 = 
V
.
size
();

278 for (int 
	gi
=0; i< 
	gN
; i++)

279 
	gs
 << 
V
(
i
) << "\n";

281 return 
	gs
;

	@mv/src/mvvi.cc

31 #include 
	~<iostream
>

32 #include 
	~"mvvi.h
"

35 
	gMV_Vector_int
::
	$MV_Vector_int
() : 
	`p_
(0), 
	`dim_
(0) , 
	$ref_
(0){
	}
}

37 
	gMV_Vector_int
::
	$MV_Vector_int
( int 
n
) : 
	`p_
(
new
 int[n]), 
	`dim_
(n),

38 
	$ref_
(0)

40 if (
p_
 == 
NULL
)

42 
std
::
cerr
 << "Error: NULL pointer in MV_Vector_int(int) constructor " << "\n";

43 
std
::
cerr
 << " Most likely out of memory... " << "\n";

44 
	`exit
(1);

46 
	}
}

49 
	gMV_Vector_int
::
	$MV_Vector_int
( int 
n
, const int& 
v
) :

50 
	`p_
(
new
 int[
n
]), 
	`dim_
(n), 
	$ref_
(0)

52 if (
p_
 == 
NULL
)

54 
std
::
cerr
 << "Error: NULL pointer in MV_Vector_int(int) constructor " << "\n";

55 
std
::
cerr
 << " Most likely out of memory... " << "\n";

56 
	`exit
(1);

58 for (int 
i
=0; i<
n
; i++)

59 
p_
[
i
] = 
v
;

60 
	}
}

66 
	gMV_Vector_int
& MV_Vector_int::
operator
=(const int & 
m
)

68 #ifdef 
TRACE_VEC


69 
cout
 << "> MV_Vector_int::operator=(const int & m) " << "\n";

74 int 
	gN
 = 
size
();

76 int 
	gNminus4
 = 
N
-4;

77 int 
	gi
;

79 for (
	gi
=0; i<
	gNminus4
; )

81 
	gp_
[
i
++] = 
m
;

82 
	gp_
[
i
++] = 
m
;

83 
	gp_
[
i
++] = 
m
;

84 
	gp_
[
i
++] = 
m
;

87 for (; 
	gi
<
	gN
; 
	gp_
[
i
++] = 
m
);

89 #ifdef 
TRACE_VEC


90 
	gcout
 << "< MV_Vector_int::operator=(const int & m) " << "\n";

92 return *
	gthis
;

96 
	gMV_Vector_int
& MV_Vector_int::
	$newsize
( int 
n
)

98 #ifdef 
TRACE_VEC


99 
cout
 << "> MV_Vector_int::newsize( int n) " << "\n";

101 if (
ref_
 )

104 
std
::
cerr
 << "MV_Vector::newsize can't operator on references.\n";

105 
	`exit
(1);

109 if (
dim_
 != 
n
 )

111 if (
p_
) 
delete
 [] p_;

112 
p_
 = 
new
 int[
n
];

113 if (
p_
 == 
NULL
)

115 
std
::
cerr
 << "Error : NULL pointer in operator= " << "\n";

116 
	`exit
(1);

118 
dim_
 = 
n
;

121 #ifdef 
TRACE_VEC


122 
cout
 << "< MV_Vector_int::newsize( int n) " << "\n";

125 return *
this
;

126 
	}
}

132 
	gMV_Vector_int
& MV_Vector_int::
operator
=(const 
MV_Vector_int
 & 
m
)

135 int 
N
 = 
m
.
dim_
;

136 int 
	gi
;

138 if (
	gref_
 )

140 if (
	gdim_
 != 
m
.
dim_
)

142 
std
::
cerr
 << "MV_VectorRef::operator= non-conformant assignment.\n";

143 
exit
(1);

147 if ((
	gm
.
	gp_
 + m.
	gdim_
) >= 
p_
)

150 for (
i
= 
N
-1; 
	gi
>=0; i--)

151 
	gp_
[
i
] = 
m
.
p_
[i];

155 for (
	gi
=0; i<
	gN
; i++)

156 
	gp_
[
i
] = 
m
.
p_
[i];

162 
newsize
(
N
);

165 for (
	gi
 =0; i< 
	gN
; i++)

166 
	gp_
[
i
] = 
m
.
p_
[i];

168 return *
	gthis
;

172 
	gMV_Vector_int
::
	$MV_Vector_int
(const 
MV_Vector_int
 & 
m
) : 
	`p_
(
new
 int[m.
dim_
]),

173 
	`dim_
(
m
.
dim_
) , 
	$ref_
(0)

175 if (
p_
 == 
NULL
)

177 
std
::
cerr
 << "Error: Null pointer in MV_Vector_int(const MV_Vector&); " << "\n";

178 
	`exit
(1);

181 int 
N
 = 
m
.
dim_
;

183 for (int 
i
=0; i<
N
; i++)

184 
p_
[
i
] = 
m
.p_[i];

185 
	}
}

187 
	gMV_Vector_int
::
	$MV_Vector_int
(int* 
d
, int 
n
) : 
	`p_
(
new
 int[n]),

188 
	`dim_
(
n
) , 
	$ref_
(0)

190 if (
p_
 == 
NULL
)

192 
std
::
cerr
 << "Error: Null pointer in MV_Vector_int(int*, int) " << "\n";

193 
	`exit
(1);

195 for (int 
i
=0; i<
n
; i++)

196 
p_
[
i
] = 
d
[i];

198 
	}
}

202 
	gMV_Vector_int
::
	$MV_Vector_int
(const int* 
d
, int 
n
) : 
	`p_
(
new
 int[n]),

203 
	`dim_
(
n
) , 
	$ref_
(0)

205 if (
p_
 == 
NULL
)

207 
std
::
cerr
 << "Error: Null pointer in MV_Vector_int(int*, int) " << "\n";

208 
	`exit
(1);

210 for (int 
i
=0; i<
n
; i++)

211 
p_
[
i
] = 
d
[i];

213 
	}
}

216 
MV_Vector_int
 
	gMV_Vector_int
::
	$operator
()(void)

218 return 
	`MV_Vector_int
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

219 
	}
}

222 const 
MV_Vector_int
 
	gMV_Vector_int
::
	$operator
()(void) const

224 return 
	`MV_Vector_int
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

225 
	}
}

228 
MV_Vector_int
 
	gMV_Vector_int
::
	$operator
()(const 
MV_VecIndex
 &
I
)

231 if (
I
.
	`all
())

232 return 
	`MV_Vector_int
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

237 if ( 
I
.
	`end
() >= 
dim_
)

239 
std
::
cerr
 << "MV_VecIndex: (" << 
I
.
	`start
() << ":" << I.
	`end
() <<

240 ") too big for matrix (0:" << 
dim_
 - 1 << ") " << "\n";

241 
	`exit
(1);

243 return 
	`MV_Vector_int
(
p_
+ 
I
.
	`start
(), I.
	`end
() - I.start() + 1,

244 
MV_Vector_
::
ref
);

246 
	}
}

249 const 
MV_Vector_int
 
	gMV_Vector_int
::
	$operator
()(const 
MV_VecIndex
 &
I
) const

253 if (
I
.
	`all
())

254 return 
	`MV_Vector_int
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

257 if ( 
I
.
	`end
() >= 
dim_
)

259 
std
::
cerr
 << "MV_VecIndex: (" << 
I
.
	`start
() << ":" << I.
	`end
() <<

260 ") too big for matrix (0:" << 
dim_
 - 1 << ") " << "\n";

261 
	`exit
(1);

263 return 
	`MV_Vector_int
(
p_
+ 
I
.
	`start
(), I.
	`end
() - I.start() + 1,

264 
MV_Vector_
::
ref
);

266 
	}
}

269 
	gMV_Vector_int
::~
	$MV_Vector_int
()

271 if (
p_
 && !
ref_
 ) 
delete
 [] p_;

272 
	}
}

275 
	gstd
::
ostream
& 
operator
<<(
std
::ostream& 
s
, const 
	gMV_Vector_int
& 
	gV
)

277 int 
	gN
 = 
V
.
size
();

279 for (int 
	gi
=0; i< 
	gN
; i++)

280 
	gs
 << 
V
(
i
) << "\n";

282 return 
	gs
;

	@mv/src/mvvt.cc

31 #include 
	~"$INCLUDE
"

34 
	gMV_Vector_$TYPE
::
	$MV_Vector_$TYPE
() : 
	`p_
(0), 
	`dim_
(0) , 
	$ref_
(0){
	}
};

36 
	gMV_Vector_$TYPE
::
	$MV_Vector_$TYPE
( int 
n
) : 
	`p_
(
new
 
$TYPE
[n]), 
	`dim_
(n),

37 
	$ref_
(0)

39 if (
p_
 == 
NULL
)

41 
std
::
cerr
 << "Error: NULL pointer in MV_Vector_$TYPE(int) constructor " << "\n";

42 
std
::
cerr
 << " Most likely out of memory... " << "\n";

43 
	`exit
(1);

45 
	}
}

48 
	gMV_Vector_$TYPE
::
	$MV_Vector_$TYPE
( int 
n
, const 
$TYPE
& 
v
) :

49 
	`p_
(
new
 
$TYPE
[
n
]), 
	`dim_
(n), 
	$ref_
(0)

51 if (
p_
 == 
NULL
)

53 
std
::
cerr
 << "Error: NULL pointer in MV_Vector_$TYPE(int) constructor " << "\n";

54 
std
::
cerr
 << " Most likely out of memory... " << "\n";

55 
	`exit
(1);

57 for (int 
i
=0; i<
n
; i++)

58 
p_
[
i
] = 
v
;

59 
	}
}

65 
	gMV_Vector_$TYPE
& MV_Vector_$TYPE::
operator
=(const 
$TYPE
 & 
m
)

67 #ifdef 
TRACE_VEC


68 
cout
 << "> MV_Vector_$TYPE::operator=(const $TYPE & m) " << "\n";

73 int 
	gN
 = 
size
();

75 int 
	gNminus4
 = 
N
-4;

76 int 
	gi
;

78 for (
	gi
=0; i<
	gNminus4
; )

80 
	gp_
[
i
++] = 
m
;

81 
	gp_
[
i
++] = 
m
;

82 
	gp_
[
i
++] = 
m
;

83 
	gp_
[
i
++] = 
m
;

86 for (; 
	gi
<
	gN
; 
	gp_
[
i
++] = 
m
);

88 #ifdef 
TRACE_VEC


89 
	gcout
 << "< MV_Vector_$TYPE::operator=(const $TYPE & m) " << "\n";

91 return *
	gthis
;

95 
	gMV_Vector_$TYPE
& MV_Vector_$TYPE::
	$newsize
( int 
n
)

97 #ifdef 
TRACE_VEC


98 
cout
 << "> MV_Vector_$TYPE::newsize( int n) " << "\n";

100 if (
ref_
 )

103 
std
::
cerr
 << "MV_Vector::newsize can't operator on references.\n";

104 
	`exit
(1);

108 if (
dim_
 != 
n
 )

110 if (
p_
) 
delete
 [] p_;

111 
p_
 = 
new
 
$TYPE
[
n
];

112 if (
p_
 == 
NULL
)

114 
std
::
cerr
 << "Error : NULL pointer in operator= " << "\n";

115 
	`exit
(1);

117 
dim_
 = 
n
;

120 #ifdef 
TRACE_VEC


121 
cout
 << "< MV_Vector_$TYPE::newsize( int n) " << "\n";

124 return *
this
;

125 
	}
}

131 
	gMV_Vector_$TYPE
& MV_Vector_$TYPE::
operator
=(const 
MV_Vector_$TYPE
 & 
m
)

134 int 
N
 = 
m
.
dim_
;

135 int 
	gi
;

137 if (
	gref_
 )

139 if (
	gdim_
 != 
m
.
dim_
)

141 
std
::
cerr
 << "MV_VectorRef::operator= non-conformant assignment.\n";

142 
exit
(1);

146 if ((
	gm
.
	gp_
 + m.
	gdim_
) >= 
p_
)

149 for (
i
= 
N
-1; 
	gi
>=0; i--)

150 
	gp_
[
i
] = 
m
.
p_
[i];

154 for (
	gi
=0; i<
	gN
; i++)

155 
	gp_
[
i
] = 
m
.
p_
[i];

161 
newsize
(
N
);

164 for (
	gi
 =0; i< 
	gN
; i++)

165 
	gp_
[
i
] = 
m
.
p_
[i];

167 return *
	gthis
;

171 
	gMV_Vector_$TYPE
::
	$MV_Vector_$TYPE
(const 
MV_Vector_$TYPE
 & 
m
) : 
	`p_
(
new
 
$TYPE
[m.
dim_
]),

172 
	`dim_
(
m
.
dim_
) , 
	$ref_
(0)

174 if (
p_
 == 
NULL
)

176 
std
::
cerr
 << "Error: Null pointer in MV_Vector_$TYPE(const MV_Vector&); " << "\n";

177 
	`exit
(1);

180 int 
N
 = 
m
.
dim_
;

182 for (int 
i
=0; i<
N
; i++)

183 
p_
[
i
] = 
m
.p_[i];

184 
	}
}

186 
	gMV_Vector_$TYPE
::
	$MV_Vector_$TYPE
(
$TYPE
* 
d
, int 
n
) : 
	`p_
(
new
 $TYPE[n]),

187 
	`dim_
(
n
) , 
	$ref_
(0)

189 if (
p_
 == 
NULL
)

191 
std
::
cerr
 << "Error: Null pointer in MV_Vector_$TYPE($TYPE*, int) " << "\n";

192 
	`exit
(1);

194 for (int 
i
=0; i<
n
; i++)

195 
p_
[
i
] = 
d
[i];

197 
	}
}

201 
	gMV_Vector_$TYPE
::
	$MV_Vector_$TYPE
(const 
$TYPE
* 
d
, int 
n
) : 
	`p_
(
new
 $TYPE[n]),

202 
	`dim_
(
n
) , 
	$ref_
(0)

204 if (
p_
 == 
NULL
)

206 
std
::
cerr
 << "Error: Null pointer in MV_Vector_$TYPE($TYPE*, int) " << "\n";

207 
	`exit
(1);

209 for (int 
i
=0; i<
n
; i++)

210 
p_
[
i
] = 
d
[i];

212 
	}
}

215 
MV_Vector_$TYPE
 
	gMV_Vector_$TYPE
::
	$operator
()(void)

217 return 
	`MV_Vector_$TYPE
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

218 
	}
}

221 const 
MV_Vector_$TYPE
 
	gMV_Vector_$TYPE
::
	$operator
()(void) const

223 return 
	`MV_Vector_$TYPE
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

224 
	}
}

227 
MV_Vector_$TYPE
 
	gMV_Vector_$TYPE
::
	$operator
()(const 
MV_VecIndex
 &
I
)

230 if (
I
.
	`all
())

231 return 
	`MV_Vector_$TYPE
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

236 if ( 
I
.
	`end
() >= 
dim_
)

238 
std
::
cerr
 << "MV_VecIndex: (" << 
I
.
	`start
() << ":" << I.
	`end
() <<

239 ") too big for matrix (0:" << 
dim_
 - 1 << ") " << "\n";

240 
	`exit
(1);

242 return 
	`MV_Vector_$TYPE
(
p_
+ 
I
.
	`start
(), I.
	`end
() - I.start() + 1,

243 
MV_Vector_
::
ref
);

245 
	}
}

248 const 
MV_Vector_$TYPE
 
	gMV_Vector_$TYPE
::
	$operator
()(const 
MV_VecIndex
 &
I
) const

252 if (
I
.
	`all
())

253 return 
	`MV_Vector_$TYPE
(
p_
, 
dim_
, 
MV_Vector_
::
ref
);

256 if ( 
I
.
	`end
() >= 
dim_
)

258 
std
::
cerr
 << "MV_VecIndex: (" << 
I
.
	`start
() << ":" << I.
	`end
() <<

259 ") too big for matrix (0:" << 
dim_
 - 1 << ") " << "\n";

260 
	`exit
(1);

262 return 
	`MV_Vector_$TYPE
(
p_
+ 
I
.
	`start
(), I.
	`end
() - I.start() + 1,

263 
MV_Vector_
::
ref
);

265 
	}
}

268 
	gMV_Vector_$TYPE
::~
	$MV_Vector_$TYPE
()

270 if (
p_
 && !
ref_
 ) 
delete
 [] p_;

271 
	}
}

274 
	gstd
::
ostream
& 
operator
<<(
std
::ostream& 
s
, const 
	gMV_Vector_$TYPE
& 
	gV
)

276 int 
	gN
 = 
V
.
size
();

278 for (int 
	gi
=0; i< 
	gN
; i++)

279 
	gs
 << 
V
(
i
) << "\n";

281 return 
	gs
;

	@spblas/spmm.cc

41 #include 
	~<stdlib.h
>

42 #include 
	~<iostream
>

43 #include 
	~"spblas.h
"

45 #define 
	#_SpMatVal
(
_a
,
_lda
,
_row
,
_col
) ((_a)[(_lda)*(_col)+(_row)])

	)

47 static void 
	$CoordMatVec_float
(int 
m
, int 
n
, int 
k
, const float &
alpha
,

48 const float *
val
, const int *
indx
, const int *
jndx
,

49 const int &
nnz
,

50 const float *
b
, int 
ldb
, float *
c
, int 
ldc
)

52 int 
i
, 
j
;

55 if (
k
 && 
m
)

59 
b
 -= 1;

60 
c
 -= 1;

62 if (
alpha
 == 1.0) {

63 if (
n
 == 1)

64 for (
j
 = 0; j < 
nnz
; j++)

65 
c
[
indx
[
j
]] += 
b
[
jndx
[j]] * 
val
[j];

67 for (
i
 = 0; i < 
n
; i++)

68 for (
j
 = 0; j < 
nnz
; j++)

69 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
i
) += _SpMatVal(
b
, 
ldb
, indx[j], i) * 
val
[j];

71 if (
n
 == 1)

72 for (
j
 = 0; j < 
nnz
; j++)

73 
c
[
indx
[
j
]] += 
alpha
 * 
b
[
jndx
[j]] * 
val
[j];

75 for (
i
 = 0; i < 
n
; i++)

76 for (
j
 = 0; j < 
nnz
; j++)

77 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
i
) +=

78 
alpha
 * 
	`_SpMatVal
(
b
, 
ldb
, 
indx
[
j
], 
i
) * 
val
[j];

80 
	}
}

82 static void 
	$CoordMatVec_double
(int 
m
, int 
n
, int 
k
, const double &
alpha
,

83 const double *
val
, const int *
indx
, const int *
jndx
,

84 const int &
nnz
,

85 const double *
b
, int 
ldb
, double *
c
, int 
ldc
)

87 int 
i
, 
j
;

90 if (
k
 && 
m
)

94 
b
 -= 1;

95 
c
 -= 1;

97 if (
alpha
 == 1.0) {

98 if (
n
 == 1)

99 for (
j
 = 0; j < 
nnz
; j++)

100 
c
[
indx
[
j
]] += 
b
[
jndx
[j]] * 
val
[j];

102 for (
i
 = 0; i < 
n
; i++)

103 for (
j
 = 0; j < 
nnz
; j++)

104 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
i
) += _SpMatVal(
b
, 
ldb
, indx[j], i) * 
val
[j];

106 if (
n
 == 1)

107 for (
j
 = 0; j < 
nnz
; j++)

108 
c
[
indx
[
j
]] += 
alpha
 * 
b
[
jndx
[j]] * 
val
[j];

110 for (
i
 = 0; i < 
n
; i++)

111 for (
j
 = 0; j < 
nnz
; j++)

112 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
i
) +=

113 
alpha
 * 
	`_SpMatVal
(
b
, 
ldb
, 
indx
[
j
], 
i
) * 
val
[j];

115 
	}
}

118 
	$CompColMatVec_double
(int 
m
, int 
n
, int 
k
, const double &
alpha
,

119 const double *
val
, const int *
indx
, const int *
pntr
,

120 const double *
b
, int 
ldb
, double *
c
, int 
ldc
)

122 int 
i
, 
j
, 
l
;

124 if (
alpha
 == 0.0)

128 if (
m
)

132 
c
 -= 1;

133 
val
 -= 
pntr
[0];

134 
indx
 -= 
pntr
[0];

136 if (
alpha
 == 1.0) {

137 if (
n
 == 1)

138 for (
i
 = 0; i < 
k
; i++)

139 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

140 
c
[
indx
[
j
]] += 
b
[
i
] * 
val
[j];

142 for (
l
 = 0; l < 
n
; l++)

143 for (
i
 = 0; i < 
k
; i++)

144 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

145 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) += _SpMatVal(
b
, 
ldb
, 
i
, l) * 
val
[j];

147 if (
n
 == 1)

148 for (
i
 = 0; i < 
k
; i++)

149 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

150 
c
[
indx
[
j
]] += 
alpha
 * 
b
[
i
] * 
val
[j];

152 for (
l
 = 0; l < 
n
; l++)

153 for (
i
 = 0; i < 
k
; i++)

154 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

155 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) +=

156 
alpha
 * 
	`_SpMatVal
(
b
, 
ldb
, 
i
, 
l
) * 
val
[
j
];

158 
	}
}

160 static void 
	$CompColMatVec_float
(int 
m
, int 
n
, int 
k
, const float &
alpha
,

161 const float *
val
, const int *
indx
, const int *
pntr
,

162 const float *
b
, int 
ldb
, float *
c
, int 
ldc
)

164 int 
i
, 
j
, 
l
;

166 if (
alpha
 == 0.0)

170 if (
m
)

174 
c
 -= 1;

175 
val
 -= 
pntr
[0];

176 
indx
 -= 
pntr
[0];

178 if (
alpha
 == 1.0) {

179 if (
n
 == 1)

180 for (
i
 = 0; i < 
k
; i++)

181 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

182 
c
[
indx
[
j
]] += 
b
[
i
] * 
val
[j];

184 for (
l
 = 0; l < 
n
; l++)

185 for (
i
 = 0; i < 
k
; i++)

186 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

187 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) += _SpMatVal(
b
, 
ldb
, 
i
, l) * 
val
[j];

189 if (
n
 == 1)

190 for (
i
 = 0; i < 
k
; i++)

191 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

192 
c
[
indx
[
j
]] += 
alpha
 * 
b
[
i
] * 
val
[j];

194 for (
l
 = 0; l < 
n
; l++)

195 for (
i
 = 0; i < 
k
; i++)

196 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

197 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) +=

198 
alpha
 * 
	`_SpMatVal
(
b
, 
ldb
, 
i
, 
l
) * 
val
[
j
];

200 
	}
}

204 
	$CompRowMatVec_double
(int 
m
, int 
n
, int 
k
, const double &
alpha
,

205 const double *
val
, const int *
indx
, const int *
pntr
,

206 const double *
b
, int 
ldb
, double *
c
, int 
ldc
)

208 int 
i
, 
j
, 
l
;

210 if (
alpha
 == 0.0)

214 if (
m
 || 
k
)

218 
b
 -= 1;

219 
val
 -= 
pntr
[0];

220 
indx
 -= 
pntr
[0];

222 if (
alpha
 == 1.0) {

223 if (
n
 == 1)

224 for (
i
 = 0; i < 
m
; i++)

225 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

226 
c
[
i
] += 
b
[
indx
[
j
]] * 
val
[j];

228 for (
l
 = 0; l < 
n
; l++)

229 for (
i
 = 0; i < 
m
; i++)

230 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

231 
	`_SpMatVal
(
c
, 
ldc
, 
i
, 
l
) += _SpMatVal(
b
, 
ldb
, 
indx
[
j
], l) * 
val
[j];

233 if (
n
 == 1)

234 for (
i
 = 0; i < 
m
; i++)

235 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

236 
c
[
i
] += 
alpha
 * 
b
[
indx
[
j
]] * 
val
[j];

238 for (
l
 = 0; l < 
n
; l++)

239 for (
i
 = 0; i < 
m
; i++)

240 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

241 
	`_SpMatVal
(
c
, 
ldc
, 
i
, 
l
) +=

242 
alpha
 * 
	`_SpMatVal
(
b
, 
ldb
, 
indx
[
j
], 
l
) * 
val
[j];

244 
	}
}

248 
	$CompRowMatVec_float
(int 
m
, int 
n
, int 
k
, const float &
alpha
,

249 const float *
val
, const int *
indx
, const int *
pntr
,

250 const float *
b
, int 
ldb
, float *
c
, int 
ldc
)

252 int 
i
, 
j
, 
l
;

254 if (
alpha
 == 0.0)

258 if (
m
 || 
k
)

262 
b
 -= 1;

263 
val
 -= 
pntr
[0];

264 
indx
 -= 
pntr
[0];

266 if (
alpha
 == 1.0) {

267 if (
n
 == 1)

268 for (
i
 = 0; i < 
m
; i++)

269 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

270 
c
[
i
] += 
b
[
indx
[
j
]] * 
val
[j];

272 for (
l
 = 0; l < 
n
; l++)

273 for (
i
 = 0; i < 
m
; i++)

274 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

275 
	`_SpMatVal
(
c
, 
ldc
, 
i
, 
l
) += _SpMatVal(
b
, 
ldb
, 
indx
[
j
], l) * 
val
[j];

277 if (
n
 == 1)

278 for (
i
 = 0; i < 
m
; i++)

279 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

280 
c
[
i
] += 
alpha
 * 
b
[
indx
[
j
]] * 
val
[j];

282 for (
l
 = 0; l < 
n
; l++)

283 for (
i
 = 0; i < 
m
; i++)

284 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

285 
	`_SpMatVal
(
c
, 
ldc
, 
i
, 
l
) +=

286 
alpha
 * 
	`_SpMatVal
(
b
, 
ldb
, 
indx
[
j
], 
l
) * 
val
[j];

288 
	}
}

291 
	$ScaleRectangularArray_double
(int 
m
, int 
n
, double *
c
, int 
ldc
,

292 const double &
beta
)

294 int 
i
, 
j
;

296 if (
beta
 == 1.0)

299 if (
beta
 == 0.0) {

300 if (
n
 == 1)

301 for (
j
 = 0; j < 
m
; j++)

302 
c
[
j
] = 0.0;

304 for (
i
 = 0; i < 
n
; i++)

305 for (
j
 = 0; j < 
m
; j++)

306 
	`_SpMatVal
(
c
, 
ldc
, 
j
, 
i
) = 0.0;

308 if (
n
 == 1)

309 for (
j
 = 0; j < 
m
; j++)

310 
c
[
j
] *= 
beta
;

312 for (
i
 = 0; i < 
n
; i++)

313 for (
j
 = 0; j < 
m
; j++)

314 
	`_SpMatVal
(
c
, 
ldc
, 
j
, 
i
) *= 
beta
;

316 
	}
}

319 
	$ScaleRectangularArray_float
(int 
m
, int 
n
, float *
c
, int 
ldc
,

320 const double &
beta
)

322 int 
i
, 
j
;

324 if (
beta
 == 1.0)

327 if (
beta
 == 0.0) {

328 if (
n
 == 1)

329 for (
j
 = 0; j < 
m
; j++)

330 
c
[
j
] = 0.0;

332 for (
i
 = 0; i < 
n
; i++)

333 for (
j
 = 0; j < 
m
; j++)

334 
	`_SpMatVal
(
c
, 
ldc
, 
j
, 
i
) = 0.0;

336 if (
n
 == 1)

337 for (
j
 = 0; j < 
m
; j++)

338 
c
[
j
] *= 
beta
;

340 for (
i
 = 0; i < 
n
; i++)

341 for (
j
 = 0; j < 
m
; j++)

342 
	`_SpMatVal
(
c
, 
ldc
, 
j
, 
i
) *= 
beta
;

344 
	}
}

401 void 
	$F77NAME
(
scoomm
)

402 (const int &
transa
, const int &
m
, const int &
n
, const int &
k
,

403 const float &
alpha
,

404 const int 
descra
[], const float *
val
,

405 const int *
indx
, const int *
jndx
, const int &
nnz
,

406 const float *
b
, const int &
ldb
,

407 const float &
beta
, float *
c
, const int &
ldc
,

408 float *
work
, const int &
lwork
)

410 if (
descra
[0] != 0) {

411 
std
::
cerr
 << "Must have general matrix" << "\n";

412 
	`exit
(1);

416 if (
work
 && 
lwork
)

419 
	`ScaleRectangularArray_float
(
m
, 
n
, 
c
, 
ldc
, 
beta
);

421 if (
alpha
 == 0.0)

425 if (
transa
 == 1 || transa == 2) {

426 const int *
itmp
 = 
indx
;

427 
indx
 = 
jndx
;

428 
jndx
 = 
itmp
;

430 
	`CoordMatVec_float
(
m
, 
n
, 
k
, 
alpha
, 
val
, 
indx
, 
jndx
, 
nnz
, 
b
, 
ldb
, 
c
, 
ldc
);

431 
	}
}

434 void 
	$F77NAME
(
dcoomm
)

435 (const int &
transa
, const int &
m
, const int &
n
, const int &
k
,

436 const double &
alpha
,

437 const int 
descra
[], const double *
val
,

438 const int *
indx
, const int *
jndx
, const int &
nnz
,

439 const double *
b
, const int &
ldb
,

440 const double &
beta
, double *
c
, const int &
ldc
,

441 double *
work
, const int &
lwork
)

443 if (
descra
[0] != 0) {

444 
std
::
cerr
 << "Must have general matrix" << "\n";

445 
	`exit
(1);

449 if (
work
 && 
lwork
)

452 
	`ScaleRectangularArray_double
(
m
, 
n
, 
c
, 
ldc
, 
beta
);

454 if (
alpha
 == 0.0)

458 if (
transa
 == 1 || transa == 2) {

459 const int *
itmp
 = 
indx
;

460 
indx
 = 
jndx
;

461 
jndx
 = 
itmp
;

463 
	`CoordMatVec_double
(
m
, 
n
, 
k
, 
alpha
, 
val
, 
indx
, 
jndx
, 
nnz
, 
b
, 
ldb
, 
c
, 
ldc
);

464 
	}
}

519 void 
	$F77NAME
(
scscmm
)

520 (const int &
transa
, const int &
m
, const int &
n
, const int &
k
,

521 const float &
alpha
,

522 const int 
descra
[], const float *
val
,

523 const int *
indx
, const int *
pntr
, const float *
b
, int &
ldb
,

524 const float &
beta
, float *
c
, const int &
ldc
,

525 float *
work
, const int &
lwork
)

527 if (
descra
[0] != 0) {

528 
std
::
cerr
 << "Must have general matrix" << "\n";

529 
	`exit
(1);

533 if (
work
 && 
lwork
)

536 
	`ScaleRectangularArray_float
(
m
, 
n
, 
c
, 
ldc
, 
beta
);

538 if (
transa
 == 1 || transa == 2)

539 
	`CompRowMatVec_float
(
m
, 
n
, 
k
, 
alpha
, 
val
, 
indx
, 
pntr
, 
b
, 
ldb
, 
c
, 
ldc
);

541 
	`CompColMatVec_float
(
m
, 
n
, 
k
, 
alpha
, 
val
, 
indx
, 
pntr
, 
b
, 
ldb
, 
c
, 
ldc
);

542 
	}
}

545 void 
	$F77NAME
(
dcscmm
)

546 (const int &
transa
, const int &
m
, const int &
n
, const int &
k
,

547 const double &
alpha
,

548 const int 
descra
[], const double *
val
,

549 const int *
indx
, const int *
pntr
, const double *
b
, int &
ldb
,

550 const double &
beta
, double *
c
, const int &
ldc
,

551 double *
work
, const int &
lwork
)

553 if (
descra
[0] != 0) {

554 
std
::
cerr
 << "Must have general matrix" << "\n";

555 
	`exit
(1);

559 if (
work
 && 
lwork
)

562 
	`ScaleRectangularArray_double
(
m
, 
n
, 
c
, 
ldc
, 
beta
);

564 if (
transa
 == 1 || transa == 2)

565 
	`CompRowMatVec_double
(
m
, 
n
, 
k
, 
alpha
, 
val
, 
indx
, 
pntr
, 
b
, 
ldb
, 
c
, 
ldc
);

567 
	`CompColMatVec_double
(
m
, 
n
, 
k
, 
alpha
, 
val
, 
indx
, 
pntr
, 
b
, 
ldb
, 
c
, 
ldc
);

568 
	}
}

623 void 
	$F77NAME
(
scsrmm
)

624 (const int &
transa
, const int &
m
, const int &
n
, const int &
k
,

625 const float &
alpha
,

626 const int 
descra
[], const float *
val
,

627 const int *
indx
, const int *
pntr
, const float *
b
, int &
ldb
,

628 const float &
beta
, float *
c
, const int &
ldc
,

629 float *
work
, const int &
lwork
)

631 if (
descra
[0] != 0) {

632 
std
::
cerr
 << "Must have general matrix" << "\n";

633 
	`exit
(1);

637 if (
work
 && 
lwork
)

640 
	`ScaleRectangularArray_float
(
m
, 
n
, 
c
, 
ldc
, 
beta
);

642 if (
transa
 == 1 || transa == 2)

643 
	`CompColMatVec_float
(
m
, 
n
, 
k
, 
alpha
, 
val
, 
indx
, 
pntr
, 
b
, 
ldb
, 
c
, 
ldc
);

645 
	`CompRowMatVec_float
(
m
, 
n
, 
k
, 
alpha
, 
val
, 
indx
, 
pntr
, 
b
, 
ldb
, 
c
, 
ldc
);

646 
	}
}

649 void 
	$F77NAME
(
dcsrmm
)

650 (const int &
transa
, const int &
m
, const int &
n
, const int &
k
,

651 const double &
alpha
,

652 const int 
descra
[], const double *
val
,

653 const int *
indx
, const int *
pntr
, const double *
b
, int &
ldb
,

654 const double &
beta
, double *
c
, const int &
ldc
,

655 double *
work
, const int &
lwork
)

657 if (
descra
[0] != 0) {

658 
std
::
cerr
 << "Must have general matrix" << "\n";

659 
	`exit
(1);

663 if (
work
 && 
lwork
)

666 
	`ScaleRectangularArray_double
(
m
, 
n
, 
c
, 
ldc
, 
beta
);

668 if (
transa
 == 1 || transa == 2)

669 
	`CompColMatVec_double
(
m
, 
n
, 
k
, 
alpha
, 
val
, 
indx
, 
pntr
, 
b
, 
ldb
, 
c
, 
ldc
);

671 
	`CompRowMatVec_double
(
m
, 
n
, 
k
, 
alpha
, 
val
, 
indx
, 
pntr
, 
b
, 
ldb
, 
c
, 
ldc
);

672 
	}
}

	@spblas/spsm.cc

41 #include 
	~<stdlib.h
>

42 #include 
	~<iostream
>

43 #include 
	~"spblas.h
"

45 #define 
	#_SpMatVal
(
_a
,
_lda
,
_row
,
_col
) ((_a)[(_lda)*(_col)+(_row)])

	)

63 
	$CopyRectangularArray_double
(int 
m
, int 
n
,

64 const double *
b
, int 
ldb
, double *
c
, int 
ldc
)

66 int 
i
, 
l
;

68 if (
b
 == 
c
)

71 if (
n
 == 1)

72 for (
i
 = 0; i < 
m
; i++)

73 
c
[
i
] = 
b
[i];

75 for (
l
 = 0; l < 
n
; l++)

76 for (
i
 = 0; i < 
m
; i++)

77 
	`_SpMatVal
(
c
, 
ldc
, 
i
, 
l
) = _SpMatVal(
b
, 
ldb
, i, l);

78 
	}
}

82 
	$CopyRectangularArray_float
(int 
m
, int 
n
,

83 const float *
b
, int 
ldb
, float *
c
, int 
ldc
)

85 int 
i
, 
l
;

87 if (
b
 == 
c
)

90 if (
n
 == 1)

91 for (
i
 = 0; i < 
m
; i++)

92 
c
[
i
] = 
b
[i];

94 for (
l
 = 0; l < 
n
; l++)

95 for (
i
 = 0; i < 
m
; i++)

96 
	`_SpMatVal
(
c
, 
ldc
, 
i
, 
l
) = _SpMatVal(
b
, 
ldb
, i, l);

97 
	}
}

100 
	$CompCol_LowerUnitSolve_double
(int 
m
, int 
n
, int 
unitd
, const double *
dv
,

101 double 
alpha
, const double *
val
, const int *
indx
, const int *
pntr
,

102 const double *
b
, int 
ldb
, double *
c
, int 
ldc
)

104 int 
i
, 
j
, 
l
;

105 double 
z
;

108 if (
dv
)

111 if (
unitd
 != 1) {

112 
std
::
cerr
 << "unitd != 1 not implemented" << "\n";

113 
	`exit
(1);

116 if (
alpha
 == 0.0)

119 
	`CopyRectangularArray_double
(
m
, 
n
, 
b
, 
ldb
, &
c
[
pntr
[0]-1], 
ldc
);

121 
c
 -= 1;

122 
val
 -= 
pntr
[0];

123 
indx
 -= 
pntr
[0];

125 if (
alpha
 == 1.0) {

126 if (
n
 == 1)

127 for (
i
 = 0; i < 
m
; i++) {

128 
z
 = 
c
[
i
+
pntr
[0]];

129 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

130 
c
[
indx
[
j
]] -= 
z
 * 
val
[j];

133 for (
l
 = 0; l < 
n
; l++)

134 for (
i
 = 0; i < 
m
; i++) {

135 
z
 = 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
);

136 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

137 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) -= 
z
 * 
val
[j];

140 if (
n
 == 1)

141 for (
i
 = 0; i < 
m
; i++) {

142 
z
 = 
alpha
 * 
c
[
i
+
pntr
[0]];

143 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

144 
c
[
indx
[
j
]] -= 
z
 * 
val
[j];

147 for (
l
 = 0; l < 
n
; l++)

148 for (
i
 = 0; i < 
m
; i++) {

149 
z
 = 
alpha
 * 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
);

150 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

151 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) -= 
z
 * 
val
[j];

154 
	}
}

158 
	$CompCol_LowerUnitSolve_float
(int 
m
, int 
n
, int 
unitd
, const float *
dv
,

159 float 
alpha
, const float *
val
, const int *
indx
, const int *
pntr
,

160 const float *
b
, int 
ldb
, float *
c
, int 
ldc
)

162 int 
i
, 
j
, 
l
;

163 float 
z
;

166 if (
dv
)

169 if (
unitd
 != 1) {

170 
std
::
cerr
 << "unitd != 1 not implemented" << "\n";

171 
	`exit
(1);

174 if (
alpha
 == 0.0)

177 
	`CopyRectangularArray_float
(
m
, 
n
, 
b
, 
ldb
, &
c
[
pntr
[0]-1], 
ldc
);

179 
c
 -= 1;

180 
val
 -= 
pntr
[0];

181 
indx
 -= 
pntr
[0];

183 if (
alpha
 == 1.0) {

184 if (
n
 == 1)

185 for (
i
 = 0; i < 
m
; i++) {

186 
z
 = 
c
[
i
+
pntr
[0]];

187 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

188 
c
[
indx
[
j
]] -= 
z
 * 
val
[j];

191 for (
l
 = 0; l < 
n
; l++)

192 for (
i
 = 0; i < 
m
; i++) {

193 
z
 = 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
);

194 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

195 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) -= 
z
 * 
val
[j];

198 if (
n
 == 1)

199 for (
i
 = 0; i < 
m
; i++) {

200 
z
 = 
alpha
 * 
c
[
i
+
pntr
[0]];

201 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

202 
c
[
indx
[
j
]] -= 
z
 * 
val
[j];

205 for (
l
 = 0; l < 
n
; l++)

206 for (
i
 = 0; i < 
m
; i++) {

207 
z
 = 
alpha
 * 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
);

208 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

209 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) -= 
z
 * 
val
[j];

212 
	}
}

216 
	$CompCol_LowerDiagSolve_double
(int 
m
, int 
n
, int 
unitd
, const double *
dv
, double 
alpha
,

217 const double *
val
, const int *
indx
, const int *
pntr
,

218 const double *
b
, int 
ldb
, double *
c
, int 
ldc
)

220 int 
i
, 
j
, 
l
;

221 double 
z
;

224 if (
dv
)

227 if (
unitd
 != 1) {

228 
std
::
cerr
 << "unitd != 1 not implemented" << "\n";

229 
	`exit
(1);

232 if (
alpha
 == 0.0)

235 
	`CopyRectangularArray_double
(
m
, 
n
, 
b
, 
ldb
, &
c
[
pntr
[0]-1], 
ldc
);

237 
c
 -= 1;

238 
val
 -= 
pntr
[0];

239 
indx
 -= 
pntr
[0];

241 if (
alpha
 == 1.0) {

242 if (
n
 == 1)

243 for (
i
 = 0; i < 
m
; i++) {

244 
z
 = 
c
[
i
+
pntr
[0]] / 
val
[pntr[i]];

245 
c
[
i
+
pntr
[0]] = 
z
;

246 for (
j
 = 
pntr
[
i
] + 1; j < pntr[i+1]; j++)

247 
c
[
indx
[
j
]] -= 
z
 * 
val
[j];

250 for (
l
 = 0; l < 
n
; l++)

251 for (
i
 = 0; i < 
m
; i++) {

252 
z
 = 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) / 
val
[pntr[i]];

253 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) = 
z
;

254 for (
j
 = 
pntr
[
i
] + 1; j < pntr[i+1]; j++)

255 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) -= 
z
 * 
val
[j];

258 if (
n
 == 1)

259 for (
i
 = 0; i < 
m
; i++) {

260 
z
 = 
alpha
 * 
c
[
i
+
pntr
[0]] / 
val
[pntr[i]];

261 
c
[
i
+
pntr
[0]] = 
z
;

262 for (
j
 = 
pntr
[
i
] + 1; j < pntr[i+1]; j++)

263 
c
[
indx
[
j
]] -= 
z
 * 
val
[j];

266 for (
l
 = 0; l < 
n
; l++)

267 for (
i
 = 0; i < 
m
; i++) {

268 
z
 = 
alpha
 * 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) / 
val
[pntr[i]];

269 
	`_SpMatVal
(
c
, 
ldc
, 
i
, 
l
) = 
z
;

270 for (
j
 = 
pntr
[
i
] + 1; j < pntr[i+1]; j++)

271 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) -= 
z
 * 
val
[j];

274 
	}
}

277 
	$CompCol_LowerDiagSolve_float
(int 
m
, int 
n
, int 
unitd
, const float *
dv
,

278 float 
alpha
,

279 const float *
val
, const int *
indx
, const int *
pntr
,

280 const float *
b
, int 
ldb
, float *
c
, int 
ldc
)

282 int 
i
, 
j
, 
l
;

283 float 
z
;

286 if (
dv
)

289 if (
unitd
 != 1) {

290 
std
::
cerr
 << "unitd != 1 not implemented" << "\n";

291 
	`exit
(1);

294 if (
alpha
 == 0.0)

297 
	`CopyRectangularArray_float
(
m
, 
n
, 
b
, 
ldb
, &
c
[
pntr
[0]-1], 
ldc
);

299 
c
 -= 1;

300 
val
 -= 
pntr
[0];

301 
indx
 -= 
pntr
[0];

303 if (
alpha
 == 1.0) {

304 if (
n
 == 1)

305 for (
i
 = 0; i < 
m
; i++) {

306 
z
 = 
c
[
i
+
pntr
[0]] / 
val
[pntr[i]];

307 
c
[
i
+
pntr
[0]] = 
z
;

308 for (
j
 = 
pntr
[
i
] + 1; j < pntr[i+1]; j++)

309 
c
[
indx
[
j
]] -= 
z
 * 
val
[j];

312 for (
l
 = 0; l < 
n
; l++)

313 for (
i
 = 0; i < 
m
; i++) {

314 
z
 = 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) / 
val
[pntr[i]];

315 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) = 
z
;

316 for (
j
 = 
pntr
[
i
] + 1; j < pntr[i+1]; j++)

317 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) -= 
z
 * 
val
[j];

320 if (
n
 == 1)

321 for (
i
 = 0; i < 
m
; i++) {

322 
z
 = 
alpha
 * 
c
[
i
+
pntr
[0]] / 
val
[pntr[i]];

323 
c
[
i
+
pntr
[0]] = 
z
;

324 for (
j
 = 
pntr
[
i
] + 1; j < pntr[i+1]; j++)

325 
c
[
indx
[
j
]] -= 
z
 * 
val
[j];

328 for (
l
 = 0; l < 
n
; l++)

329 for (
i
 = 0; i < 
m
; i++) {

330 
z
 = 
alpha
 * 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) / 
val
[pntr[i]];

331 
	`_SpMatVal
(
c
, 
ldc
, 
i
, 
l
) = 
z
;

332 for (
j
 = 
pntr
[
i
] + 1; j < pntr[i+1]; j++)

333 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) -= 
z
 * 
val
[j];

336 
	}
}

340 
	$CompCol_UpperUnitSolve_double
(int 
m
, int 
n
, int 
unitd
, const double *
dv
,

341 double 
alpha
,

342 const double *
val
, const int *
indx
, const int *
pntr
,

343 const double *
b
, int 
ldb
, double *
c
, int 
ldc
)

345 int 
i
, 
j
, 
l
;

346 double 
z
;

349 if (
dv
)

352 if (
unitd
 != 1) {

353 
std
::
cerr
 << "unitd != 1 not implemented" << "\n";

354 
	`exit
(1);

357 if (
alpha
 == 0.0)

360 
	`CopyRectangularArray_double
(
m
, 
n
, 
b
, 
ldb
, &
c
[
pntr
[0]-1], 
ldc
);

362 
c
 -= 1;

363 
val
 -= 
pntr
[0];

364 
indx
 -= 
pntr
[0];

366 if (
alpha
 == 1.0) {

367 if (
n
 == 1)

368 for (
i
 = 
m
 - 1; i >= 0; i--) {

369 
z
 = 
c
[
i
+
pntr
[0]];

370 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

371 
c
[
indx
[
j
]] -= 
z
 * 
val
[j];

374 for (
l
 = 0; l < 
n
; l++)

375 for (
i
 = 
m
 - 1; i >= 0; i--) {

376 
z
 = 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
);

377 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

378 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) -= 
z
 * 
val
[j];

381 if (
n
 == 1)

382 for (
i
 = 
m
 - 1; i >= 0; i--) {

383 
z
 = 
alpha
 * 
c
[
i
+
pntr
[0]];

384 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

385 
c
[
indx
[
j
]] -= 
z
 * 
val
[j];

388 for (
l
 = 0; l < 
n
; l++)

389 for (
i
 = 
m
 - 1; i >= 0; i--) {

390 
z
 = 
alpha
 * 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
);

391 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

392 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) -= 
z
 * 
val
[j];

395 
	}
}

399 
	$CompCol_UpperUnitSolve_float
(int 
m
, int 
n
, int 
unitd
, const float *
dv
,

400 float 
alpha
,

401 const float *
val
, const int *
indx
, const int *
pntr
,

402 const float *
b
, int 
ldb
, float *
c
, int 
ldc
)

404 int 
i
, 
j
, 
l
;

405 float 
z
;

408 if (
dv
)

411 if (
unitd
 != 1) {

412 
std
::
cerr
 << "unitd != 1 not implemented" << "\n";

413 
	`exit
(1);

416 if (
alpha
 == 0.0)

419 
	`CopyRectangularArray_float
(
m
, 
n
, 
b
, 
ldb
, &
c
[
pntr
[0]-1], 
ldc
);

421 
c
 -= 1;

422 
val
 -= 
pntr
[0];

423 
indx
 -= 
pntr
[0];

425 if (
alpha
 == 1.0) {

426 if (
n
 == 1)

427 for (
i
 = 
m
 - 1; i >= 0; i--) {

428 
z
 = 
c
[
i
+
pntr
[0]];

429 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

430 
c
[
indx
[
j
]] -= 
z
 * 
val
[j];

433 for (
l
 = 0; l < 
n
; l++)

434 for (
i
 = 
m
 - 1; i >= 0; i--) {

435 
z
 = 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
);

436 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

437 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) -= 
z
 * 
val
[j];

440 if (
n
 == 1)

441 for (
i
 = 
m
 - 1; i >= 0; i--) {

442 
z
 = 
alpha
 * 
c
[
i
+
pntr
[0]];

443 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

444 
c
[
indx
[
j
]] -= 
z
 * 
val
[j];

447 for (
l
 = 0; l < 
n
; l++)

448 for (
i
 = 
m
 - 1; i >= 0; i--) {

449 
z
 = 
alpha
 * 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
);

450 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

451 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) -= 
z
 * 
val
[j];

454 
	}
}

458 
	$CompCol_UpperDiagSolve_double
(int 
m
, int 
n
, int 
unitd
, const double *
dv
,

459 double 
alpha
,

460 const double *
val
, const int *
indx
, const int *
pntr
,

461 const double *
b
, int 
ldb
, double *
c
, int 
ldc
)

463 int 
i
, 
j
, 
l
;

464 double 
z
;

467 if (
dv
)

470 if (
unitd
 != 1) {

471 
std
::
cerr
 << "unitd != 1 not implemented" << "\n";

472 
	`exit
(1);

475 if (
alpha
 == 0.0)

478 
	`CopyRectangularArray_double
(
m
, 
n
, 
b
, 
ldb
, &
c
[
pntr
[0]-1], 
ldc
);

480 
c
 -= 1;

481 
val
 -= 
pntr
[0];

482 
indx
 -= 
pntr
[0];

484 if (
alpha
 == 1.0) {

485 if (
n
 == 1)

486 for (
i
 = 
m
 - 1; i >= 0; i--) {

487 
z
 = 
c
[
i
+
pntr
[0]] / 
val
[pntr[i+1]-1];

488 
c
[
i
+
pntr
[0]] = 
z
;

489 for (
j
 = 
pntr
[
i
]; j < pntr[i+1] - 1; j++)

490 
c
[
indx
[
j
]] -= 
z
 * 
val
[j];

493 for (
l
 = 0; l < 
n
; l++)

494 for (
i
 = 
m
 - 1; i >= 0; i--) {

495 
z
 = 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) / 
val
[pntr[i+1]-1];

496 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) = 
z
;

497 for (
j
 = 
pntr
[
i
]; j < pntr[i+1] - 1; j++)

498 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) -= 
z
 * 
val
[j];

501 if (
n
 == 1)

502 for (
i
 = 
m
 - 1; i >= 0; i--) {

503 
z
 = 
alpha
 * 
c
[
i
+
pntr
[0]] / 
val
[pntr[i+1]-1];

504 
c
[
i
+
pntr
[0]] = 
z
;

505 for (
j
 = 
pntr
[
i
]; j < pntr[i+1] - 1; j++)

506 
c
[
indx
[
j
]] -= 
z
 * 
val
[j];

509 for (
l
 = 0; l < 
n
; l++)

510 for (
i
 = 
m
 - 1; i >= 0; i--) {

511 
z
 = 
alpha
 * 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) / 
val
[pntr[i+1]-1];

512 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) = 
z
;

513 for (
j
 = 
pntr
[
i
]; j < pntr[i+1] - 1; j++)

514 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) -= 
z
 * 
val
[j];

517 
	}
}

521 
	$CompCol_UpperDiagSolve_float
(int 
m
, int 
n
, int 
unitd
, const float *
dv
,

522 float 
alpha
,

523 const float *
val
, const int *
indx
, const int *
pntr
,

524 const float *
b
, int 
ldb
, float *
c
, int 
ldc
)

526 int 
i
, 
j
, 
l
;

527 float 
z
;

530 if (
dv
)

533 if (
unitd
 != 1) {

534 
std
::
cerr
 << "unitd != 1 not implemented" << "\n";

535 
	`exit
(1);

538 if (
alpha
 == 0.0)

541 
	`CopyRectangularArray_float
(
m
, 
n
, 
b
, 
ldb
, &
c
[
pntr
[0]-1], 
ldc
);

543 
c
 -= 1;

544 
val
 -= 
pntr
[0];

545 
indx
 -= 
pntr
[0];

547 if (
alpha
 == 1.0) {

548 if (
n
 == 1)

549 for (
i
 = 
m
 - 1; i >= 0; i--) {

550 
z
 = 
c
[
i
+
pntr
[0]] / 
val
[pntr[i+1]-1];

551 
c
[
i
+
pntr
[0]] = 
z
;

552 for (
j
 = 
pntr
[
i
]; j < pntr[i+1] - 1; j++)

553 
c
[
indx
[
j
]] -= 
z
 * 
val
[j];

556 for (
l
 = 0; l < 
n
; l++)

557 for (
i
 = 
m
 - 1; i >= 0; i--) {

558 
z
 = 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) / 
val
[pntr[i+1]-1];

559 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) = 
z
;

560 for (
j
 = 
pntr
[
i
]; j < pntr[i+1] - 1; j++)

561 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) -= 
z
 * 
val
[j];

564 if (
n
 == 1)

565 for (
i
 = 
m
 - 1; i >= 0; i--) {

566 
z
 = 
alpha
 * 
c
[
i
+
pntr
[0]] / 
val
[pntr[i+1]-1];

567 
c
[
i
+
pntr
[0]] = 
z
;

568 for (
j
 = 
pntr
[
i
]; j < pntr[i+1] - 1; j++)

569 
c
[
indx
[
j
]] -= 
z
 * 
val
[j];

572 for (
l
 = 0; l < 
n
; l++)

573 for (
i
 = 
m
 - 1; i >= 0; i--) {

574 
z
 = 
alpha
 * 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) / 
val
[pntr[i+1]-1];

575 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) = 
z
;

576 for (
j
 = 
pntr
[
i
]; j < pntr[i+1] - 1; j++)

577 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) -= 
z
 * 
val
[j];

580 
	}
}

584 
	$CompRow_LowerUnitSolve_double
(int 
m
, int 
n
, int 
unitd
, const double *
dv
,

585 double 
alpha
,

586 const double *
val
, const int *
indx
, const int *
pntr
,

587 const double *
b
, int 
ldb
, double *
c
, int 
ldc
)

589 int 
i
, 
j
, 
l
;

590 double 
z
;

593 if (
dv
)

596 if (
unitd
 != 1) {

597 
std
::
cerr
 << "unitd != 1 not implemented" << "\n";

598 
	`exit
(1);

601 if (
alpha
 == 0.0)

604 
c
 -= 1;

605 
val
 -= 
pntr
[0];

606 
indx
 -= 
pntr
[0];

608 if (
alpha
 == 1.0) {

609 if (
n
 == 1)

610 for (
i
 = 0; i < 
m
; i++) {

611 
z
 = 0;

612 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

613 
z
 += 
c
[
indx
[
j
]] * 
val
[j];

614 
c
[
i
+
pntr
[0]] = 
b
[i] - 
z
;

617 for (
l
 = 0; l < 
n
; l++)

618 for (
i
 = 0; i < 
m
; i++) {

619 
z
 = 0;

620 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

621 
z
 += 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) * 
val
[j];

622 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) = (_SpMatVal(
b
, 
ldb
, i, l) - 
z
);

625 if (
n
 == 1)

626 for (
i
 = 0; i < 
m
; i++) {

627 
z
 = 0;

628 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

629 
z
 += 
c
[
indx
[
j
]] * 
val
[j];

630 
c
[
i
+1] = 
alpha
 * (
b
[i] - 
z
);

633 for (
l
 = 0; l < 
n
; l++)

634 for (
i
 = 0; i < 
m
; i++) {

635 
z
 = 0;

636 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

637 
z
 += 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) * 
val
[j];

638 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) = 
alpha
 * (_SpMatVal(
b
, 
ldb
, i, l) - 
z
);

641 
	}
}

645 
	$CompRow_LowerUnitSolve_float
(int 
m
, int 
n
, int 
unitd
, const float *
dv
,

646 float 
alpha
,

647 const float *
val
, const int *
indx
, const int *
pntr
,

648 const float *
b
, int 
ldb
, float *
c
, int 
ldc
)

650 int 
i
, 
j
, 
l
;

651 float 
z
;

654 if (
dv
)

657 if (
unitd
 != 1) {

658 
std
::
cerr
 << "unitd != 1 not implemented" << "\n";

659 
	`exit
(1);

662 if (
alpha
 == 0.0)

665 
c
 -= 1;

666 
val
 -= 
pntr
[0];

667 
indx
 -= 
pntr
[0];

669 if (
alpha
 == 1.0) {

670 if (
n
 == 1)

671 for (
i
 = 0; i < 
m
; i++) {

672 
z
 = 0;

673 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

674 
z
 += 
c
[
indx
[
j
]] * 
val
[j];

675 
c
[
i
+
pntr
[0]] = 
b
[i] - 
z
;

678 for (
l
 = 0; l < 
n
; l++)

679 for (
i
 = 0; i < 
m
; i++) {

680 
z
 = 0;

681 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

682 
z
 += 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) * 
val
[j];

683 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) = (_SpMatVal(
b
, 
ldb
, i, l) - 
z
);

686 if (
n
 == 1)

687 for (
i
 = 0; i < 
m
; i++) {

688 
z
 = 0;

689 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

690 
z
 += 
c
[
indx
[
j
]] * 
val
[j];

691 
c
[
i
+1] = 
alpha
 * (
b
[i] - 
z
);

694 for (
l
 = 0; l < 
n
; l++)

695 for (
i
 = 0; i < 
m
; i++) {

696 
z
 = 0;

697 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

698 
z
 += 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) * 
val
[j];

699 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) = 
alpha
 * (_SpMatVal(
b
, 
ldb
, i, l) - 
z
);

702 
	}
}

706 
	$CompRow_LowerDiagSolve_double
(int 
m
, int 
n
, int 
unitd
, const double *
dv
,

707 double 
alpha
,

708 const double *
val
, const int *
indx
, const int *
pntr
,

709 const double *
b
, int 
ldb
, double *
c
, int 
ldc
)

711 int 
i
, 
j
, 
l
;

712 double 
z
;

715 if (
dv
)

718 if (
unitd
 != 1) {

719 
std
::
cerr
 << "unitd != 1 not implemented" << "\n";

720 
	`exit
(1);

723 if (
alpha
 == 0.0)

726 
c
 -= 1;

727 
val
 -= 
pntr
[0];

728 
indx
 -= 
pntr
[0];

730 if (
alpha
 == 1.0) {

731 if (
n
 == 1)

732 for (
i
 = 0; i < 
m
; i++) {

733 
z
 = 0;

734 for (
j
 = 
pntr
[
i
]; j < pntr[i+1] - 1; j++)

735 
z
 += 
c
[
indx
[
j
]] * 
val
[j];

736 
c
[
i
+
pntr
[0]] = (
b
[i] - 
z
) / 
val
[pntr[i+1]-1];

739 for (
l
 = 0; l < 
n
; l++)

740 for (
i
 = 0; i < 
m
; i++) {

741 
z
 = 0;

742 for (
j
 = 
pntr
[
i
]; j < pntr[i+1] - 1; j++)

743 
z
 += 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) * 
val
[j];

744 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) =

745 (
	`_SpMatVal
(
b
, 
ldb
, 
i
, 
l
) - 
z
) / 
val
[
pntr
[i+1]-1];

748 if (
n
 == 1)

749 for (
i
 = 0; i < 
m
; i++) {

750 
z
 = 0;

751 for (
j
 = 
pntr
[
i
]; j < pntr[i+1] - 1; j++)

752 
z
 += 
c
[
indx
[
j
]] * 
val
[j];

753 
c
[
i
+
pntr
[0]] = 
alpha
 * (
b
[i] - 
z
) / 
val
[pntr[i+1]-1];

756 for (
l
 = 0; l < 
n
; l++)

757 for (
i
 = 0; i < 
m
; i++) {

758 
z
 = 0;

759 for (
j
 = 
pntr
[
i
]; j < pntr[i+1] - 1; j++)

760 
z
 += 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) * 
val
[j];

761 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) =

762 
alpha
 * (
	`_SpMatVal
(
b
, 
ldb
, 
i
, 
l
) - 
z
) / 
val
[
pntr
[i+1]-1];

765 
	}
}

769 
	$CompRow_LowerDiagSolve_float
(int 
m
, int 
n
, int 
unitd
, const float *
dv
,

770 float 
alpha
,

771 const float *
val
, const int *
indx
, const int *
pntr
,

772 const float *
b
, int 
ldb
, float *
c
, int 
ldc
)

774 int 
i
, 
j
, 
l
;

775 float 
z
;

778 if (
dv
)

781 if (
unitd
 != 1) {

782 
std
::
cerr
 << "unitd != 1 not implemented" << "\n";

783 
	`exit
(1);

786 if (
alpha
 == 0.0)

789 
c
 -= 1;

790 
val
 -= 
pntr
[0];

791 
indx
 -= 
pntr
[0];

793 if (
alpha
 == 1.0) {

794 if (
n
 == 1)

795 for (
i
 = 0; i < 
m
; i++) {

796 
z
 = 0;

797 for (
j
 = 
pntr
[
i
]; j < pntr[i+1] - 1; j++)

798 
z
 += 
c
[
indx
[
j
]] * 
val
[j];

799 
c
[
i
+
pntr
[0]] = (
b
[i] - 
z
) / 
val
[pntr[i+1]-1];

802 for (
l
 = 0; l < 
n
; l++)

803 for (
i
 = 0; i < 
m
; i++) {

804 
z
 = 0;

805 for (
j
 = 
pntr
[
i
]; j < pntr[i+1] - 1; j++)

806 
z
 += 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) * 
val
[j];

807 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) =

808 (
	`_SpMatVal
(
b
, 
ldb
, 
i
, 
l
) - 
z
) / 
val
[
pntr
[i+1]-1];

811 if (
n
 == 1)

812 for (
i
 = 0; i < 
m
; i++) {

813 
z
 = 0;

814 for (
j
 = 
pntr
[
i
]; j < pntr[i+1] - 1; j++)

815 
z
 += 
c
[
indx
[
j
]] * 
val
[j];

816 
c
[
i
+
pntr
[0]] = 
alpha
 * (
b
[i] - 
z
) / 
val
[pntr[i+1]-1];

819 for (
l
 = 0; l < 
n
; l++)

820 for (
i
 = 0; i < 
m
; i++) {

821 
z
 = 0;

822 for (
j
 = 
pntr
[
i
]; j < pntr[i+1] - 1; j++)

823 
z
 += 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) * 
val
[j];

824 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) =

825 
alpha
 * (
	`_SpMatVal
(
b
, 
ldb
, 
i
, 
l
) - 
z
) / 
val
[
pntr
[i+1]-1];

828 
	}
}

832 
	$CompRow_UpperUnitSolve_double
(int 
m
, int 
n
, int 
unitd
, const double *
dv
, double 
alpha
,

833 const double *
val
, const int *
indx
, const int *
pntr
,

834 const double *
b
, int 
ldb
, double *
c
, int 
ldc
)

837 int 
i
, 
j
, 
l
;

838 double 
z
;

841 if (
dv
)

844 if (
unitd
 != 1) {

845 
std
::
cerr
 << "unitd != 1 not implemented" << "\n";

846 
	`exit
(1);

849 if (
alpha
 == 0.0)

852 
c
 -= 1;

853 
val
 -= 
pntr
[0];

854 
indx
 -= 
pntr
[0];

856 if (
alpha
 == 1.0) {

857 if (
n
 == 1)

858 for (
i
 = 
m
 - 1; i >= 0; i--) {

859 
z
 = 0;

860 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

861 
z
 += 
c
[
indx
[
j
]] * 
val
[j];

862 
c
[
i
+
pntr
[0]] = 
b
[i] - 
z
;

865 for (
l
 = 0; l < 
n
; l++)

866 for (
i
 = 
m
 - 1; i >= 0; i--) {

867 
z
 = 0;

868 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

869 
z
 += 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) * 
val
[j];

870 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) = (_SpMatVal(
b
, 
ldb
, i, l) - 
z
);

873 if (
n
 == 1)

874 for (
i
 = 
m
 - 1; i >= 0; i--) {

875 
z
 = 0;

876 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

877 
z
 += 
c
[
indx
[
j
]] * 
val
[j];

878 
c
[
i
+
pntr
[0]] = 
alpha
 * (
b
[i] - 
z
);

881 for (
l
 = 0; l < 
n
; l++)

882 for (
i
 = 
m
 - 1; i >= 0; i--) {

883 
z
 = 0;

884 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

885 
z
 += 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) * 
val
[j];

886 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) = 
alpha
 * (_SpMatVal(
b
, 
ldb
, i, l) - 
z
);

889 
	}
}

893 
	$CompRow_UpperUnitSolve_float
(int 
m
, int 
n
, int 
unitd
, const float *
dv
, float 
alpha
,

894 const float *
val
, const int *
indx
, const int *
pntr
,

895 const float *
b
, int 
ldb
, float *
c
, int 
ldc
)

898 int 
i
, 
j
, 
l
;

899 float 
z
;

902 if (
dv
)

905 if (
unitd
 != 1) {

906 
std
::
cerr
 << "unitd != 1 not implemented" << "\n";

907 
	`exit
(1);

910 if (
alpha
 == 0.0)

913 
c
 -= 1;

914 
val
 -= 
pntr
[0];

915 
indx
 -= 
pntr
[0];

917 if (
alpha
 == 1.0) {

918 if (
n
 == 1)

919 for (
i
 = 
m
 - 1; i >= 0; i--) {

920 
z
 = 0;

921 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

922 
z
 += 
c
[
indx
[
j
]] * 
val
[j];

923 
c
[
i
+
pntr
[0]] = 
b
[i] - 
z
;

926 for (
l
 = 0; l < 
n
; l++)

927 for (
i
 = 
m
 - 1; i >= 0; i--) {

928 
z
 = 0;

929 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

930 
z
 += 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) * 
val
[j];

931 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) = (_SpMatVal(
b
, 
ldb
, i, l) - 
z
);

934 if (
n
 == 1)

935 for (
i
 = 
m
 - 1; i >= 0; i--) {

936 
z
 = 0;

937 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

938 
z
 += 
c
[
indx
[
j
]] * 
val
[j];

939 
c
[
i
+
pntr
[0]] = 
alpha
 * (
b
[i] - 
z
);

942 for (
l
 = 0; l < 
n
; l++)

943 for (
i
 = 
m
 - 1; i >= 0; i--) {

944 
z
 = 0;

945 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++)

946 
z
 += 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) * 
val
[j];

947 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) = 
alpha
 * (_SpMatVal(
b
, 
ldb
, i, l) - 
z
);

950 
	}
}

954 
	$CompRow_UpperDiagSolve_double
(int 
m
, int 
n
, int 
unitd
, const double *
dv
, double 
alpha
,

955 const double *
val
, const int *
indx
, const int *
pntr
,

956 const double *
b
, int 
ldb
, double *
c
, int 
ldc
)

958 int 
i
, 
j
, 
l
;

959 double 
z
;

962 if (
dv
)

965 if (
unitd
 != 1) {

966 
std
::
cerr
 << "unitd != 1 not implemented" << "\n";

967 
	`exit
(1);

970 if (
alpha
 == 0.0)

973 
c
 -= 1;

974 
val
 -= 
pntr
[0];

975 
indx
 -= 
pntr
[0];

977 if (
alpha
 == 1.0) {

978 if (
n
 == 1)

979 for (
i
 = 
m
 - 1; i >= 0; i--) {

980 
z
 = 0;

981 for (
j
 = 
pntr
[
i
] + 1; j < pntr[i+1]; j++)

982 
z
 += 
c
[
indx
[
j
]] * 
val
[j];

983 
c
[
i
+
pntr
[0]] = (
b
[i] - 
z
) / 
val
[pntr[i]];

986 for (
l
 = 0; l < 
n
; l++)

987 for (
i
 = 
m
 - 1; i >= 0; i--) {

988 
z
 = 0;

989 for (
j
 = 
pntr
[
i
] + 1; j < pntr[i+1]; j++)

990 
z
 += 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) * 
val
[j];

991 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) =

992 (
	`_SpMatVal
(
b
, 
ldb
, 
i
, 
l
) - 
z
) / 
val
[
pntr
[i]];

995 if (
n
 == 1)

996 for (
i
 = 
m
 - 1; i >= 0; i--) {

997 
z
 = 0;

998 for (
j
 = 
pntr
[
i
] + 1; j < pntr[i+1]; j++)

999 
z
 += 
c
[
indx
[
j
]] * 
val
[j];

1000 
c
[
i
+
pntr
[0]] = 
alpha
 * (
b
[i] - 
z
) / 
val
[pntr[i]];

1003 for (
l
 = 0; l < 
n
; l++)

1004 for (
i
 = 
m
 - 1; i >= 0; i--) {

1005 
z
 = 0;

1006 for (
j
 = 
pntr
[
i
] + 1; j < pntr[i+1]; j++)

1007 
z
 += 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) * 
val
[j];

1008 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) =

1009 
alpha
 * (
	`_SpMatVal
(
b
, 
ldb
, 
i
, 
l
) - 
z
) / 
val
[
pntr
[i]];

1012 
	}
}

1016 
	$CompRow_UpperDiagSolve_float
(int 
m
, int 
n
, int 
unitd
, const float *
dv
, float 
alpha
,

1017 const float *
val
, const int *
indx
, const int *
pntr
,

1018 const float *
b
, int 
ldb
, float *
c
, int 
ldc
)

1020 int 
i
, 
j
, 
l
;

1021 float 
z
;

1024 if (
dv
)

1027 if (
unitd
 != 1) {

1028 
std
::
cerr
 << "unitd != 1 not implemented" << "\n";

1029 
	`exit
(1);

1032 if (
alpha
 == 0.0)

1035 
c
 -= 1;

1036 
val
 -= 
pntr
[0];

1037 
indx
 -= 
pntr
[0];

1039 if (
alpha
 == 1.0) {

1040 if (
n
 == 1)

1041 for (
i
 = 
m
 - 1; i >= 0; i--) {

1042 
z
 = 0;

1043 for (
j
 = 
pntr
[
i
] + 1; j < pntr[i+1]; j++)

1044 
z
 += 
c
[
indx
[
j
]] * 
val
[j];

1045 
c
[
i
+
pntr
[0]] = (
b
[i] - 
z
) / 
val
[pntr[i]];

1048 for (
l
 = 0; l < 
n
; l++)

1049 for (
i
 = 
m
 - 1; i >= 0; i--) {

1050 
z
 = 0;

1051 for (
j
 = 
pntr
[
i
] + 1; j < pntr[i+1]; j++)

1052 
z
 += 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) * 
val
[j];

1053 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) =

1054 (
	`_SpMatVal
(
b
, 
ldb
, 
i
, 
l
) - 
z
) / 
val
[
pntr
[i]];

1057 if (
n
 == 1)

1058 for (
i
 = 
m
 - 1; i >= 0; i--) {

1059 
z
 = 0;

1060 for (
j
 = 
pntr
[
i
] + 1; j < pntr[i+1]; j++)

1061 
z
 += 
c
[
indx
[
j
]] * 
val
[j];

1062 
c
[
i
+
pntr
[0]] = 
alpha
 * (
b
[i] - 
z
) / 
val
[pntr[i]];

1065 for (
l
 = 0; l < 
n
; l++)

1066 for (
i
 = 
m
 - 1; i >= 0; i--) {

1067 
z
 = 0;

1068 for (
j
 = 
pntr
[
i
] + 1; j < pntr[i+1]; j++)

1069 
z
 += 
	`_SpMatVal
(
c
, 
ldc
, 
indx
[
j
], 
l
) * 
val
[j];

1070 
	`_SpMatVal
(
c
, 
ldc
, 
i
+
pntr
[0], 
l
) =

1071 
alpha
 * (
	`_SpMatVal
(
b
, 
ldb
, 
i
, 
l
) - 
z
) / 
val
[
pntr
[i]];

1074 
	}
}

1086 void 
	$F77NAME
(
scscsm
)

1087 (const int &
transa
, const int &
m
, const int &
n
,

1088 const int &
unitd
, const float *
dv
, const float &
alpha
,

1089 const int 
descra
[], const float *
val
,

1090 const int *
indx
, const int *
pntr
, const float *
b
, int &
ldb
,

1091 const float &
beta
, float *
c
, const int &
ldc
,

1092 float *
work
, const int &
lwork
)

1094 if (
descra
[0] != 0) {

1095 
std
::
cerr
 << "Must have general matrix" << "\n";

1096 
	`exit
(1);

1099 if (
beta
 != 0.0) {

1100 
std
::
cerr
 << "beta != 0 not implemented" << "\n";

1101 
	`exit
(1);

1105 if (
work
 && 
lwork
)

1108 if (
transa
 == 0) {

1109 if (
descra
[1] == 1) {

1110 if (
descra
[2] == 0)

1111 
	`CompCol_LowerDiagSolve_float
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1112 
b
, 
ldb
, 
c
, 
ldc
);

1113 else if (
descra
[2] == 1)

1114 
	`CompCol_LowerUnitSolve_float
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1115 
b
, 
ldb
, 
c
, 
ldc
);

1117 
std
::
cerr
 << "Bad descra[2]" << "\n";

1118 
	`exit
(1);

1120 } else if (
descra
[1] == 2) {

1121 if (
descra
[2] == 0)

1122 
	`CompCol_UpperDiagSolve_float
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1123 
b
, 
ldb
, 
c
, 
ldc
);

1124 else if (
descra
[2] == 1)

1125 
	`CompCol_UpperUnitSolve_float
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1126 
b
, 
ldb
, 
c
, 
ldc
);

1128 
std
::
cerr
 << "Bad descra[2]" << "\n";

1129 
	`exit
(1);

1132 } else if (
transa
 == 1 || transa == 2) {

1133 if (
descra
[1] == 1) {

1134 if (
descra
[2] == 0)

1135 
	`CompRow_UpperDiagSolve_float
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1136 
b
, 
ldb
, 
c
, 
ldc
);

1137 else if (
descra
[2] == 1)

1138 
	`CompRow_UpperUnitSolve_float
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1139 
b
, 
ldb
, 
c
, 
ldc
);

1141 
std
::
cerr
 << "Bad descra[2]" << "\n";

1142 
	`exit
(1);

1144 } else if (
descra
[1] == 2) {

1145 if (
descra
[2] == 0)

1146 
	`CompRow_LowerDiagSolve_float
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1147 
b
, 
ldb
, 
c
, 
ldc
);

1148 else if (
descra
[2] == 1)

1149 
	`CompRow_LowerUnitSolve_float
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1150 
b
, 
ldb
, 
c
, 
ldc
);

1152 
std
::
cerr
 << "Bad descra[2]" << "\n";

1153 
	`exit
(1);

1156 
std
::
cerr
 << "Bad descra[1]" << "\n";

1157 
	`exit
(1);

1160 
std
::
cerr
 << "Bad transa" << "\n";

1161 
	`exit
(1);

1163 
	}
}

1166 void 
	$F77NAME
(
scsrsm
)

1167 (const int &
transa
, const int &
m
, const int &
n
,

1168 const int &
unitd
, const float *
dv
, const float &
alpha
,

1169 const int 
descra
[], const float *
val
,

1170 const int *
indx
, const int *
pntr
, const float *
b
, int &
ldb
,

1171 const float &
beta
, float *
c
, const int &
ldc
,

1172 float *
work
, const int &
lwork
)

1174 if (
descra
[0] != 0) {

1175 
std
::
cerr
 << "Must have general matrix" << "\n";

1176 
	`exit
(1);

1179 if (
beta
 != 0.0) {

1180 
std
::
cerr
 << "beta != 0 not implemented" << "\n";

1181 
	`exit
(1);

1185 if (
work
 && 
lwork
)

1188 if (
transa
 == 0) {

1189 if (
descra
[1] == 1) {

1190 if (
descra
[2] == 0)

1191 
	`CompRow_LowerDiagSolve_float
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1192 
b
, 
ldb
, 
c
, 
ldc
);

1193 else if (
descra
[2] == 1)

1194 
	`CompRow_LowerUnitSolve_float
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1195 
b
, 
ldb
, 
c
, 
ldc
);

1197 
std
::
cerr
 << "Bad descra[2]" << "\n";

1198 
	`exit
(1);

1200 } else if (
descra
[1] == 2) {

1201 if (
descra
[2] == 0)

1202 
	`CompRow_UpperDiagSolve_float
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1203 
b
, 
ldb
, 
c
, 
ldc
);

1204 else if (
descra
[2] == 1)

1205 
	`CompRow_UpperUnitSolve_float
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1206 
b
, 
ldb
, 
c
, 
ldc
);

1208 
std
::
cerr
 << "Bad descra[2]" << "\n";

1209 
	`exit
(1);

1212 } else if (
transa
 == 1 || transa == 2) {

1213 if (
descra
[1] == 1) {

1214 if (
descra
[2] == 0)

1215 
	`CompCol_UpperDiagSolve_float
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1216 
b
, 
ldb
, 
c
, 
ldc
);

1217 else if (
descra
[2] == 1)

1218 
	`CompCol_UpperUnitSolve_float
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1219 
b
, 
ldb
, 
c
, 
ldc
);

1221 
std
::
cerr
 << "Bad descra[2]" << "\n";

1222 
	`exit
(1);

1224 } else if (
descra
[1] == 2) {

1225 if (
descra
[2] == 0)

1226 
	`CompCol_LowerDiagSolve_float
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1227 
b
, 
ldb
, 
c
, 
ldc
);

1228 else if (
descra
[2] == 1)

1229 
	`CompCol_LowerUnitSolve_float
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1230 
b
, 
ldb
, 
c
, 
ldc
);

1232 
std
::
cerr
 << "Bad descra[2]" << "\n";

1233 
	`exit
(1);

1236 
std
::
cerr
 << "Bad descra[1]" << "\n";

1237 
	`exit
(1);

1240 
std
::
cerr
 << "Bad transa" << "\n";

1241 
	`exit
(1);

1243 
	}
}

1246 void 
	$F77NAME
(
dcscsm
)

1247 (const int &
transa
, const int &
m
, const int &
n
,

1248 const int &
unitd
, const double *
dv
, const double &
alpha
,

1249 const int 
descra
[], const double *
val
,

1250 const int *
indx
, const int *
pntr
, const double *
b
, int &
ldb
,

1251 const double &
beta
, double *
c
, const int &
ldc
,

1252 double *
work
, const int &
lwork
)

1254 if (
descra
[0] != 0) {

1255 
std
::
cerr
 << "Must have general matrix" << "\n";

1256 
	`exit
(1);

1259 if (
beta
 != 0.0) {

1260 
std
::
cerr
 << "beta != 0 not implemented" << "\n";

1261 
	`exit
(1);

1265 if (
work
 && 
lwork
)

1268 if (
transa
 == 0) {

1269 if (
descra
[1] == 1) {

1270 if (
descra
[2] == 0)

1271 
	`CompCol_LowerDiagSolve_double
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1272 
b
, 
ldb
, 
c
, 
ldc
);

1273 else if (
descra
[2] == 1)

1274 
	`CompCol_LowerUnitSolve_double
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1275 
b
, 
ldb
, 
c
, 
ldc
);

1277 
std
::
cerr
 << "Bad descra[2]" << "\n";

1278 
	`exit
(1);

1280 } else if (
descra
[1] == 2) {

1281 if (
descra
[2] == 0)

1282 
	`CompCol_UpperDiagSolve_double
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1283 
b
, 
ldb
, 
c
, 
ldc
);

1284 else if (
descra
[2] == 1)

1285 
	`CompCol_UpperUnitSolve_double
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1286 
b
, 
ldb
, 
c
, 
ldc
);

1288 
std
::
cerr
 << "Bad descra[2]" << "\n";

1289 
	`exit
(1);

1292 } else if (
transa
 == 1 || transa == 2) {

1293 if (
descra
[1] == 1) {

1294 if (
descra
[2] == 0)

1295 
	`CompRow_UpperDiagSolve_double
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1296 
b
, 
ldb
, 
c
, 
ldc
);

1297 else if (
descra
[2] == 1)

1298 
	`CompRow_UpperUnitSolve_double
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1299 
b
, 
ldb
, 
c
, 
ldc
);

1301 
std
::
cerr
 << "Bad descra[2]" << "\n";

1302 
	`exit
(1);

1304 } else if (
descra
[1] == 2) {

1305 if (
descra
[2] == 0)

1306 
	`CompRow_LowerDiagSolve_double
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1307 
b
, 
ldb
, 
c
, 
ldc
);

1308 else if (
descra
[2] == 1)

1309 
	`CompRow_LowerUnitSolve_double
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1310 
b
, 
ldb
, 
c
, 
ldc
);

1312 
std
::
cerr
 << "Bad descra[2]" << "\n";

1313 
	`exit
(1);

1316 
std
::
cerr
 << "Bad descra[1]" << "\n";

1317 
	`exit
(1);

1320 
std
::
cerr
 << "Bad transa" << "\n";

1321 
	`exit
(1);

1323 
	}
}

1328 void 
	$F77NAME
(
dcsrsm
)

1329 (const int &
transa
, const int &
m
, const int &
n
,

1330 const int &
unitd
, const double *
dv
, const double &
alpha
,

1331 const int 
descra
[], const double *
val
,

1332 const int *
indx
, const int *
pntr
, const double *
b
, int &
ldb
,

1333 const double &
beta
, double *
c
, const int &
ldc
,

1334 double *
work
, const int &
lwork
)

1336 if (
descra
[0] != 0) {

1337 
std
::
cerr
 << "Must have general matrix" << "\n";

1338 
	`exit
(1);

1341 if (
beta
 != 0.0) {

1342 
std
::
cerr
 << "beta != 0 not implemented" << "\n";

1343 
	`exit
(1);

1347 if (
work
 && 
lwork
)

1350 if (
transa
 == 0) {

1351 if (
descra
[1] == 1) {

1352 if (
descra
[2] == 0)

1353 
	`CompRow_LowerDiagSolve_double
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1354 
b
, 
ldb
, 
c
, 
ldc
);

1355 else if (
descra
[2] == 1)

1356 
	`CompRow_LowerUnitSolve_double
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1357 
b
, 
ldb
, 
c
, 
ldc
);

1359 
std
::
cerr
 << "Bad descra[2]" << "\n";

1360 
	`exit
(1);

1362 } else if (
descra
[1] == 2) {

1363 if (
descra
[2] == 0)

1364 
	`CompRow_UpperDiagSolve_double
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1365 
b
, 
ldb
, 
c
, 
ldc
);

1366 else if (
descra
[2] == 1)

1367 
	`CompRow_UpperUnitSolve_double
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1368 
b
, 
ldb
, 
c
, 
ldc
);

1370 
std
::
cerr
 << "Bad descra[2]" << "\n";

1371 
	`exit
(1);

1374 } else if (
transa
 == 1 || transa == 2) {

1375 if (
descra
[1] == 1) {

1376 if (
descra
[2] == 0)

1377 
	`CompCol_UpperDiagSolve_double
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1378 
b
, 
ldb
, 
c
, 
ldc
);

1379 else if (
descra
[2] == 1)

1380 
	`CompCol_UpperUnitSolve_double
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1381 
b
, 
ldb
, 
c
, 
ldc
);

1383 
std
::
cerr
 << "Bad descra[2]" << "\n";

1384 
	`exit
(1);

1386 } else if (
descra
[1] == 2) {

1387 if (
descra
[2] == 0)

1388 
	`CompCol_LowerDiagSolve_double
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1389 
b
, 
ldb
, 
c
, 
ldc
);

1390 else if (
descra
[2] == 1)

1391 
	`CompCol_LowerUnitSolve_double
(
m
, 
n
, 
unitd
, 
dv
, 
alpha
, 
val
, 
indx
, 
pntr
,

1392 
b
, 
ldb
, 
c
, 
ldc
);

1394 
std
::
cerr
 << "Bad descra[2]" << "\n";

1395 
	`exit
(1);

1398 
std
::
cerr
 << "Bad descra[1]" << "\n";

1399 
	`exit
(1);

1402 
std
::
cerr
 << "Bad transa" << "\n";

1403 
	`exit
(1);

1405 
	}
}

	@src/compcol_double.cc

36 #include 
	~<iostream
>

37 #include 
	~<sstream
>

38 #include 
	~<stdlib.h
>

39 #include 
	~"compcol_double.h
"

40 #include 
	~"comprow_double.h
"

41 #include 
	~"coord_double.h
"

43 #include 
	~"spblas.h
"

49 
	gCompCol_Mat_double
::
	$CompCol_Mat_double
(void)

50 : 
	`val_
(0), 
	`rowind_
(0), 
	`colptr_
(0), 
	`base_
(0), 
	$nz_
(0)

52 
dim_
[0] = 0;

53 
dim_
[1] = 0;

54 
	}
}

60 
	gCompCol_Mat_double
::
	$CompCol_Mat_double
(const 
CompCol_Mat_double
 &
S
) :

61 
	`val_
(
S
.
val_
), 
	`rowind_
(S.
rowind_
), 
	`colptr_
(S.
colptr_
),

62 
	`base_
(
S
.
base_
), 
	$nz_
(
S
.
nz_
)

64 
dim_
[0] = 
S
.dim_[0];

65 
dim_
[1] = 
S
.dim_[1];

66 
	}
}

72 
	gCompCol_Mat_double
::
	$CompCol_Mat_double
(int 
M
, int 
N
, int 
nz
, double *
val
,

73 int *
r
, int *
c
, int 
base
) :

74 
	`val_
(
val
, 
nz
), 
	`rowind_
(
r
, nz), 
	`colptr_
(
c
, 
N
+1), 
	`base_
(
base
), 
	$nz_
(
nz
)

76 
dim_
[0] = 
M
;

77 
dim_
[1] = 
N
;

78 
	}
}

80 
	gCompCol_Mat_double
::
	$CompCol_Mat_double
(int 
M
, int 
N
, int 
nz
,

81 const 
VECTOR_double
 &
val
, const 
VECTOR_int
 &
r
,

82 const 
VECTOR_int
 &
c
, int 
base
) :

83 
	`val_
(
val
), 
	`rowind_
(
r
), 
	`colptr_
(
c
), 
	`base_
(
base
), 
	$nz_
(
nz
)

85 
dim_
[0] = 
M
;

86 
dim_
[1] = 
N
;

87 
	}
}

93 
	gCompCol_Mat_double
::
	$CompCol_Mat_double
(const 
CompRow_Mat_double
 &
R
) :

94 
	`val_
(
R
.
	`NumNonzeros
()), 
	`rowind_
(R.NumNonzeros()), 
	`colptr_
(R.
	`dim
(1) +1),

95 
	`base_
(
R
.
	`base
()), 
	`nz_
(R.
	$NumNonzeros
())

98 
dim_
[0] = 
R
.
	`dim
(0);

99 
dim_
[1] = 
R
.
	`dim
(1);

101 int 
i
,
j
;

102 
VECTOR_int
 
	`tally
(
R
.
	`dim
(1)+1, 0);

105 for (
i
=0;i<
nz_
;i++) 
	`tally
(
R
.
	`col_ind
(i))++;

106 
	`colptr_
(0) = 0;

107 for (
j
=0;j<
dim_
[1];j++) 
	`colptr_
(j+1) = colptr_(j)+
	`tally
(j);

109 
tally
 = 
colptr_
;

111 int 
count
 = 0;

112 for (
i
=1;i<=
dim_
[0];i++)

114 for (
j
=
count
;j<
R
.
	`row_ptr
(
i
);j++)

116 
	`val_
(
	`tally
(
R
.
	`col_ind
(
j
))) = R.
	`val
(j);

117 
	`rowind_
(
	`tally
(
R
.
	`col_ind
(
j
))) = 
i
-1;

118 
	`tally
(
R
.
	`col_ind
(
count
))++;

119 
count
++;

122 
	}
}

129 
	gCompCol_Mat_double
::
	$CompCol_Mat_double
(const 
Coord_Mat_double
 &
CO
) :

130 
	`val_
(
CO
.
	`NumNonzeros
()), 
	`rowind_
(CO.NumNonzeros()),

131 
	`colptr_
(
CO
.
	`dim
(1) +1), 
	`base_
(CO.
	`base
()), 
	`nz_
(CO.
	$NumNonzeros
())

134 
dim_
[0] = 
CO
.
	`dim
(0);

135 
dim_
[1] = 
CO
.
	`dim
(1);

137 int 
i
,
j
;

138 
VECTOR_int
 
	`tally
(
CO
.
	`dim
(1)+1, 0);

141 for (
i
=0;i<
nz_
;i++) 
	`tally
(
CO
.
	`col_ind
(i))++;

142 
	`colptr_
(0) = 0;

143 for (
j
=0;j<
dim_
[1];j++) 
	`colptr_
(j+1) = colptr_(j)+
	`tally
(j);

145 
tally
 = 
colptr_
;

147 for (
i
=0;i<
nz_
;i++)

149 
	`val_
(
	`tally
(
CO
.
	`col_ind
(
i
))) = CO.
	`val
(i);

150 
	`rowind_
(
	`tally
(
CO
.
	`col_ind
(
i
))) = CO.
	`row_ind
(i);

151 
	`tally
(
CO
.
	`col_ind
(
i
))++;

153 
	}
}

159 
	gCompCol_Mat_double
& CompCol_Mat_double::
operator
=(const 
CompCol_Mat_double
 &
C
)

161 
dim_
[0] = 
C
.dim_[0];

162 
	gdim_
[1] = 
C
.
dim_
[1];

163 
	gbase_
 = 
C
.
base_
;

164 
	gnz_
 = 
C
.
nz_
;

165 
	gval_
 = 
C
.
val_
;

166 
	growind_
 = 
C
.
rowind_
;

167 
	gcolptr_
 = 
C
.
colptr_
;

168 return *
	gthis
;

175 
	gCompCol_Mat_double
& CompCol_Mat_double::
	$newsize
(int 
M
, int 
N
, int 
nz
)

177 
dim_
[0] = 
M
;

178 
dim_
[1] = 
N
;

180 
nz_
 = 
nz
;

181 
val_
.
	`newsize
(
nz
);

182 
rowind_
.
	`newsize
(
nz
);

183 
colptr_
.
	`newsize
(
N
+1);

184 return *
this
;

185 
	}
}

191 double 
	gCompCol_Mat_double
::
	$operator
()(int 
i
, int 
j
) const

193 for (int 
t
=
	`colptr_
(
j
); t<colptr_(j+1); t++)

194 if (
	`rowind_
(
t
) == 
i
) return 
	`val_
(t);

195 if (
i
 < 
dim_
[0] && 
j
 < dim_[1]) return 0.0;

198 
std
::
cerr
 << "Array accessing exception -- out of bounds." << "\n";

199 
	`exit
(1);

202 
	}
}

204 double& 
	gCompCol_Mat_double
::
	$set
(int 
i
, int 
j
)

206 for (int 
t
=
	`colptr_
(
j
); t<colptr_(j+1); t++)

207 if (
	`rowind_
(
t
) == 
i
) return 
	`val_
(t);

208 
std
::
cerr
 << "Array element (" << 
i
 << "," << 
j
 ;

209 
std
::
cerr
 << ") not in sparse structure -- cannot assign." << "\n";

210 
	`exit
(1);

211 return 
	`val_
(0);

212 
	}
}

218 
using
 
namespace
 
	gstd
;

220 
	gstd
::
ostream
& 
operator
 << (
std
::ostream & 
os
, const 
	gCompCol_Mat_double
 & 
	gmat
)

222 int 
	gM
 = 
mat
.
dim
(0);

223 int 
	gN
 = 
mat
.
dim
(1);

224 int 
	growp1
, 
	gcolp1
;

225 int 
	gflag
 = 0;

227 
	gstd
::
ios
::
fmtflags
 
olda
 = 
os
.
setf
(ios::
right
,ios::
adjustfield
);

228 
	gstd
::
ios
::
fmtflags
 
oldf
 = 
os
.
setf
(ios::
scientific
,ios::
floatfield
);

230 int 
	goldp
 = 
os
.
precision
(12);

233 for (int 
	gj
 = 0; j < 
	gN
 ; j++)

234 for (int 
	gi
=
mat
.
col_ptr
(
j
);i<
	gmat
.col_ptr(j+1);i++)

236 
	growp1
 = 
mat
.
row_ind
(
i
)+1;

237 
	gcolp1
 = 
j
 + 1;

238 if ( 
	growp1
 == 
M
 && 
colp1
 == 
N
 ) 
flag
 = 1;

239 
	gos
.
width
(14);

240 
	gos
 << 
	growp1
 ; os << " " ;

241 
	gos
.
width
(14);

242 
	gos
 << 
	gcolp1
 ; os << " " ;

243 
	gos
.
width
(20);

244 
	gos
 << 
	gmat
.
val
(
i
) << "\n";

247 if (
	gflag
 == 0)

249 
os
.
width
(14);

250 
	gos
 << 
	gM
 ; os << " " ;

251 
	gos
.
width
(14);

252 
	gos
 << 
	gN
 ; os << " " ;

253 
	gos
.
width
(20);

254 
	gos
 << 
mat
(
M
-1,
N
-1) << "\n";

256 
	gos
.
setf
(
olda
,
ios
::
adjustfield
);

257 
	gos
.
setf
(
oldf
,
ios
::
floatfield
);

258 
	gos
.
precision
(
oldp
);

260 return 
	gos
;

268 
VECTOR_double
 
	gCompCol_Mat_double
::
operator
*(const VECTOR_double &
x
)

271 int 
M
 = 
dim_
[0];

272 int 
	gN
 = 
dim_
[1];

275 if (
	gx
.
size
() != 
N
)

277 
std
::
cerr
 << "Error in CompCol Matvec -- incompatible dimensions."

279 
exit
(1);

280 return 
	gx
;

283 
VECTOR_double
 
result
(
M
, 0.0);

284 
VECTOR_double
 
work
(
M
);

286 int 
	gdescra
[9];

287 
	gdescra
[0] = 0;

288 
	gdescra
[1] = 0;

289 
	gdescra
[2] = 0;

291 
F77NAME
(
dcscmm
) (0, 
	gM
, 1, 
	gN
, 1.0,

292 
	gdescra
, &
val_
(0), &
rowind_
(0), &
colptr_
(0),

293 &
x
(0), 
	gN
, 1.0, &
result
(1), 
	gM
,

294 &
work
(1), 
	gM
);

296 return 
	gresult
;

303 
VECTOR_double
 
	gCompCol_Mat_double
::
	$trans_mult
(const 
VECTOR_double
 &
x
)

306 int 
M
 = 
dim_
[0];

307 int 
N
 = 
dim_
[1];

310 if (
x
.
	`size
() != 
M
)

312 
std
::
cerr
 <<

314 
	`exit
(1);

315 return 
x
;

318 
VECTOR_double
 
	`result
(
N
, 0.0);

319 
VECTOR_double
 
	`work
(
N
);

321 int 
descra
[9];

322 
descra
[0] = 0;

323 
descra
[1] = 0;

324 
descra
[2] = 0;

326 
	`F77NAME
(
dcscmm
) (1, 
N
, 1, 
M
, 1.0,

327 
descra
, &
	`val_
(0), &
	`rowind_
(0), &
	`colptr_
(0),

328 &
	`x
(1), 
M
, 1.0, &
	`result
(0), 
N
,

329 &
	`work
(0), 
N
);

331 return 
result
;

332 
	}
}

	@src/comprow_double.cc

35 #include 
	~<iostream
>

36 #include 
	~<stdlib.h
>

37 #include 
	~"compcol_double.h
"

38 #include 
	~"comprow_double.h
"

39 #include 
	~"coord_double.h
"

41 #include 
	~"spblas.h
"

47 
	gCompRow_Mat_double
::
	$CompRow_Mat_double
(void)

48 : 
	`val_
(0), 
	`rowptr_
(0), 
	`colind_
(0), 
	`base_
(0), 
	$nz_
(0)

50 
dim_
[0] = 0;

51 
dim_
[1] = 0;

52 
	}
}

58 
	gCompRow_Mat_double
::
	$CompRow_Mat_double
(const 
CompRow_Mat_double
 &
S
) :

59 
	`val_
(
S
.
val_
), 
	`rowptr_
(S.
rowptr_
), 
	`colind_
(S.
colind_
), 
	`base_
(S.
base_
),

60 
	$nz_
(
S
.
nz_
)

62 
dim_
[0] = 
S
.dim_[0];

63 
dim_
[1] = 
S
.dim_[1];

64 
	}
}

70 
	gCompRow_Mat_double
::
	$CompRow_Mat_double
(int 
M
, int 
N
, int 
nz
, double *
val
,

71 int *
r
, int *
c
, int 
base
) :

72 
	`val_
(
val
, 
nz
), 
	`rowptr_
(
r
, 
M
+1), 
	`colind_
(
c
, nz), 
	`base_
(
base
), 
	$nz_
(
nz
)

74 
dim_
[0] = 
M
;

75 
dim_
[1] = 
N
;

76 
	}
}

78 
	gCompRow_Mat_double
::
	$CompRow_Mat_double
(int 
M
, int 
N
, int 
nz
,

79 const 
VECTOR_double
 &
val
, const 
VECTOR_int
 &
r
,

80 const 
VECTOR_int
 &
c
, int 
base
) :

81 
	`val_
(
val
), 
	`rowptr_
(
r
), 
	`colind_
(
c
), 
	`base_
(
base
), 
	$nz_
(
nz
)

83 
dim_
[0] = 
M
;

84 
dim_
[1] = 
N
;

85 
	}
}

92 
	gCompRow_Mat_double
::
	$CompRow_Mat_double
(const 
CompCol_Mat_double
 &
C
) :

93 
	`val_
(
C
.
	`NumNonzeros
()), 
	`rowptr_
(C.
	`dim
(0) +1),

94 
	`colind_
(
C
.
	`NumNonzeros
()), 
	`base_
(C.
	`base
()), 
	`nz_
(C.
	$NumNonzeros
())

97 
dim_
[0] = 
C
.
	`dim
(0);

98 
dim_
[1] = 
C
.
	`dim
(1);

100 int 
i
,
j
;

102 
VECTOR_int
 
	`tally
(
C
.
	`dim
(0)+1, 0);

105 for (
i
=0;i<
nz_
;i++) 
	`tally
(
C
.
	`row_ind
(i))++;

106 
	`rowptr_
(0) = 0;

107 for (
j
=0;j<
dim_
[0];j++) 
	`rowptr_
(j+1) = rowptr_(j)+
	`tally
(j);

109 
tally
 = 
rowptr_
;

112 int 
count
 = 0;

113 for (
i
=1;i<=
dim_
[1];i++)

115 for (
j
=
count
;j<
C
.
	`col_ptr
(
i
);j++)

117 
	`val_
(
	`tally
(
C
.
	`row_ind
(
j
))) = C.
	`val
(j);

118 
	`colind_
(
	`tally
(
C
.
	`row_ind
(
j
))) = 
i
-1;

119 
	`tally
(
C
.
	`row_ind
(
count
))++;

120 
count
++;

123 
	}
}

130 
	gCompRow_Mat_double
::
	$CompRow_Mat_double
(const 
Coord_Mat_double
 &
CO
) :

131 
	`val_
(
CO
.
	`NumNonzeros
()), 
	`rowptr_
(CO.
	`dim
(0)+1),

132 
	`colind_
(
CO
.
	`NumNonzeros
()), 
	`base_
(CO.
	`base
()), 
	`nz_
(CO.
	$NumNonzeros
())

135 
dim_
[0] = 
CO
.
	`dim
(0);

136 
dim_
[1] = 
CO
.
	`dim
(1);

138 int 
i
;

139 
VECTOR_int
 
	`tally
(
CO
.
	`dim
(0)+1, 0);

142 for (
i
=0;i<
nz_
;i++) 
	`tally
(
CO
.
	`row_ind
(i))++;

143 
	`rowptr_
(0) = 0;

144 for (
i
=0;i<
dim_
[0];i++) 
	`rowptr_
(i+1) = rowptr_(i)+
	`tally
(i);

146 
tally
 = 
rowptr_
;

148 for (
i
=0;i<
nz_
;i++)

150 
	`val_
(
	`tally
(
CO
.
	`row_ind
(
i
))) = CO.
	`val
(i);

151 
	`colind_
(
	`tally
(
CO
.
	`row_ind
(
i
))) = CO.
	`col_ind
(i);

152 
	`tally
(
CO
.
	`row_ind
(
i
))++;

154 
	}
}

161 
	gCompRow_Mat_double
& CompRow_Mat_double::
operator
=(const 
CompRow_Mat_double
 &
R
)

163 
dim_
[0] = 
R
.dim_[0];

164 
	gdim_
[1] = 
R
.
dim_
[1];

165 
	gbase_
 = 
R
.
base_
;

166 
	gnz_
 = 
R
.
nz_
;

167 
	gval_
 = 
R
.
val_
;

168 
	growptr_
 = 
R
.
rowptr_
;

169 
	gcolind_
 = 
R
.
colind_
;

170 return *
	gthis
;

177 
	gCompRow_Mat_double
& CompRow_Mat_double::
	$newsize
(int 
M
, int 
N
, int 
nz
)

179 
dim_
[0] = 
M
;

180 
dim_
[1] = 
N
;

181 
nz_
 = 
nz
;

182 
val_
.
	`newsize
(
nz
);

183 
rowptr_
.
	`newsize
(
M
+1);

184 
colind_
.
	`newsize
(
nz
);

185 return *
this
;

186 
	}
}

193 double 
	gCompRow_Mat_double
::
	$operator
()(int 
i
, int 
j
) const

195 for (int 
t
=
	`rowptr_
(
i
); t<rowptr_(i+1); t++)

196 if (
	`colind_
(
t
) == 
j
) return 
	`val_
(t);

197 if (
i
 < 
dim_
[0] && 
j
 < dim_[1]) return 0.0;

200 
std
::
cerr
 << "Array accessing exception -- out of bounds." << "\n";

203 
	}
}

206 double& 
	gCompRow_Mat_double
::
	$set
(int 
i
, int 
j
)

208 for (int 
t
=
	`rowptr_
(
i
); t<rowptr_(i+1); t++)

209 if (
	`colind_
(
t
) == 
j
) return 
	`val_
(t);

210 
std
::
cerr
 << "Array element (" << 
i
 << "," << 
j
 <<

213 
	`exit
(1);

214 return 
	`val_
(0);

215 
	}
}

220 
using
 
namespace
 
	gstd
;

222 
	gstd
::
ostream
& 
operator
 << (
std
::ostream & 
os
, const 
	gCompRow_Mat_double
 & 
	gmat
)

225 int 
	gM
 = 
mat
.
dim
(0);

226 int 
	gN
 = 
mat
.
dim
(1);

227 int 
	growp1
, 
	gcolp1
;

228 int 
	gflag
 = 0;

231 
	gstd
::
ios
::
fmtflags
 
olda
 = 
os
.
setf
(ios::
right
,ios::
adjustfield
);

232 
	gstd
::
ios
::
fmtflags
 
oldf
 = 
os
.
setf
(ios::
scientific
,ios::
floatfield
);

234 int 
	goldp
 = 
os
.
precision
(12);

238 for (int 
	gi
 = 0; i < 
	gM
 ; i++)

239 for (int 
	gj
=
mat
.
row_ptr
(
i
);j<
	gmat
.row_ptr(i+1);j++)

241 
	growp1
 = 
i
 + 1;

242 
	gcolp1
 = 
mat
.
col_ind
(
j
) + 1;

243 if ( 
	growp1
 == 
M
 && 
colp1
 == 
N
 ) 
flag
 = 1;

244 
	gos
.
width
(14);

245 
	gos
 << 
	growp1
 ; os << " " ;

246 
	gos
.
width
(14);

247 
	gos
 << 
	gcolp1
 ; os << " " ;

248 
	gos
.
width
(20);

249 
	gos
 << 
	gmat
.
val
(
j
) << "\n";

252 if (
	gflag
 == 0)

254 
os
.
width
(14);

255 
	gos
 << 
	gM
 ; os << " " ;

256 
	gos
.
width
(14);

257 
	gos
 << 
	gN
 ; os << " " ;

258 
	gos
.
width
(20);

259 
	gos
 << 
mat
(
M
-1,
N
-1) << "\n";

262 
	gos
.
setf
(
olda
,
ios
::
adjustfield
);

263 
	gos
.
setf
(
oldf
,
ios
::
floatfield
);

264 
	gos
.
precision
(
oldp
);

266 return 
	gos
;

273 
VECTOR_double
 
	gCompRow_Mat_double
::
operator
*(const VECTOR_double &
x
)

276 int 
M
 = 
dim_
[0];

277 int 
	gN
 = 
dim_
[1];

280 if (
	gx
.
size
() != 
N
)

282 
std
::
cerr
 << "Error in CompCol Matvec -- incompatible dimensions."

284 
exit
(1);

285 return 
	gx
;

288 
VECTOR_double
 
result
(
M
, 0.0);

289 
VECTOR_double
 
work
(
M
);

291 int 
	gdescra
[9];

292 
	gdescra
[0] = 0;

293 
	gdescra
[1] = 0;

294 
	gdescra
[2] = 0;

296 
F77NAME
(
dcsrmm
) (0, 
	gM
, 1, 
	gN
, 1.0,

297 
	gdescra
, &
val_
(0), &
colind_
(0), &
rowptr_
(0),

298 &
x
(1), 
	gN
, 1.0, &
result
(0), 
	gM
,

299 &
work
(0), 
	gM
);

301 return 
	gresult
;

309 
VECTOR_double
 
	gCompRow_Mat_double
::
	$trans_mult
(const 
VECTOR_double
 &
x
)

312 int 
M
 = 
dim_
[0];

313 int 
N
 = 
dim_
[1];

316 if (
x
.
	`size
() != 
M
)

318 
std
::
cerr
 << "Error in CompCol Matvec -- incompatible dimensions."

320 
	`exit
(1);

321 return 
x
;

324 
VECTOR_double
 
	`result
(
N
, 0.0);

325 
VECTOR_double
 
	`work
(
N
);

327 int 
descra
[9];

328 
descra
[0] = 0;

329 
descra
[1] = 0;

330 
descra
[2] = 0;

332 
	`F77NAME
(
dcsrmm
) (1, 
N
, 1, 
M
, 1.0,

333 
descra
, &
	`val_
(0), &
	`colind_
(0), &
	`rowptr_
(0),

334 &
	`x
(0), 
M
, 1.0, &
	`result
(1), 
N
,

335 &
	`work
(1), 
N
);

337 return 
result
;

338 
	}
}

	@src/coord_double.cc

35 #include 
	~<iostream
>

36 #include 
	~<stdlib.h
>

37 #include 
	~"compcol_double.h
"

38 #include 
	~"comprow_double.h
"

39 #include 
	~"coord_double.h
"

41 #include 
	~"spblas.h
"

47 
	gCoord_Mat_double
::
	$Coord_Mat_double
(void) :

48 
	`val_
(0), 
	`rowind_
(0), 
	`colind_
(0), 
	`base_
(0), 
	$nz_
(0)

50 
dim_
[0] = 0;

51 
dim_
[1] = 0;

52 
	}
}

58 
	gCoord_Mat_double
::
	$Coord_Mat_double
(const 
Coord_Mat_double
 &
S
) :

59 
	`val_
(
S
.
val_
), 
	`rowind_
(S.
rowind_
), 
	`colind_
(S.
colind_
), 
	`base_
(S.
base_
),

60 
	$nz_
(
S
.
nz_
)

62 
dim_
[0] = 
S
.dim_[0];

63 
dim_
[1] = 
S
.dim_[1];

64 
	}
}

70 
	gCoord_Mat_double
::
	$Coord_Mat_double
(int 
M
, int 
N
, int 
nz
, double *
val
, int *
r
,

71 int *
c
, int 
base
) :

72 
	`val_
(
val
, 
nz
), 
	`rowind_
(
r
, nz), 
	`colind_
(
c
, nz), 
	`base_
(
base
), 
	$nz_
(
nz
)

74 
dim_
[0] = 
M
;

75 
dim_
[1] = 
N
;

76 
	}
}

84 
	gCoord_Mat_double
::
	$Coord_Mat_double
(const 
CompRow_Mat_double
 &
R
) :

85 
	`val_
(
R
.
	`NumNonzeros
()), 
	`rowind_
(R.NumNonzeros()),

86 
	`colind_
(
R
.
	`NumNonzeros
()), 
	`base_
(R.
	`base
()), 
	`nz_
(R.
	$NumNonzeros
())

90 
dim_
[0] = 
R
.
	`dim
(0);

91 
dim_
[1] = 
R
.
	`dim
(1);

94 int 
count
 = 0;

95 int 
i
, 
j
;

97 for (
i
=1;i<=
dim_
[0];i++)

99 for (
j
=
count
;j<
R
.
	`row_ptr
(
i
);j++)

101 
val_
[
count
] = 
R
.
	`val
(count);

102 
colind_
[
count
] = 
R
.
	`col_ind
(count);

103 
rowind_
[
count
] = 
i
-1;

104 
count
++;

107 
	}
}

115 
	gCoord_Mat_double
::
	$Coord_Mat_double
(const 
CompCol_Mat_double
 &
C
) :

116 
	`val_
(
C
.
	`NumNonzeros
()), 
	`rowind_
(C.NumNonzeros()),

117 
	`colind_
(
C
.
	`NumNonzeros
()), 
	`base_
(C.
	`base
()), 
	`nz_
(C.
	$NumNonzeros
())

120 
dim_
[0] = 
C
.
	`dim
(0);

121 
dim_
[1] = 
C
.
	`dim
(1);

123 int 
count
 = 0;

124 int 
i
, 
j
;

126 for (
j
=1;j<=
dim_
[1];j++)

128 for (
i
=
count
;i<
C
.
	`col_ptr
(
j
);i++)

130 
val_
[
count
] = 
C
.
	`val
(count);

131 
rowind_
[
count
] = 
C
.
	`row_ind
(count);

132 
colind_
[
count
] = 
j
-1;

133 
count
++;

136 
	}
}

143 
	gCoord_Mat_double
& Coord_Mat_double::
operator
=(const 
Coord_Mat_double
 &
C
)

145 
dim_
[0] = 
C
.dim_[0];

146 
	gdim_
[1] = 
C
.
dim_
[1];

147 
	gbase_
 = 
C
.
base_
;

148 
	gnz_
 = 
C
.
nz_
;

149 
	gval_
 = 
C
.
val_
;

150 
	growind_
 = 
C
.
rowind_
;

151 
	gcolind_
 = 
C
.
colind_
;

152 return *
	gthis
;

159 
	gCoord_Mat_double
& Coord_Mat_double::
	$newsize
(int 
M
, int 
N
, int 
nz
)

161 
dim_
[0] = 
M
;

162 
dim_
[1] = 
N
;

163 
nz_
 = 
nz
;

164 
val_
.
	`newsize
(
nz
);

165 
rowind_
.
	`newsize
(
nz
);

166 
colind_
.
	`newsize
(
nz
);

167 return *
this
;

168 
	}
}

175 double 
	gCoord_Mat_double
::
	$operator
()(int 
i
, int 
j
) const

177 for (int 
t
=0; t<
nz_
; t++)

178 if (
	`rowind_
(
t
) == 
i
 && 
	`colind_
(t) == 
j
) return 
	`val_
(t);

179 if (
i
 < 
dim_
[0] && 
j
 < dim_[1]) return 0.0;

180 
std
::
cerr
 << "Array accessing exception -- out of bounds." << "\n";

181 
	`exit
(1);

183 
	}
}

186 double& 
	gCoord_Mat_double
::
	$set
(int 
i
, int 
j
)

188 for (int 
t
=0; t<
nz_
; t++)

189 if (
	`rowind_
(
t
) == 
i
 && 
	`colind_
(t) == 
j
) return 
	`val_
(t);

190 
std
::
cerr
 << "Array element (" << 
i
 << "," << 
j
 ;

191 
std
::
cerr
 << ") not in sparse structure -- cannot assign." << "\n";

192 
	`exit
(1);

193 return 
	`val_
(0);

194 
	}
}

199 
using
 
namespace
 
	gstd
;

200 
	gostream
& 
	goperator
 << (ostream & 
	gos
, const 
	gCoord_Mat_double
 & 
	gmat
)

202 int 
	gnnz
 = 
mat
.
NumNonzeros
();

203 int 
	growp1
, 
	gcolp1
;

204 int 
	gM
 = 
mat
.
dim
(0);

205 int 
	gN
 = 
mat
.
dim
(1);

206 int 
	gflag
 = 0;

209 
	gstd
::
ios
::
fmtflags
 
olda
 = 
os
.
setf
(ios::
right
,ios::
adjustfield
);

210 
	gstd
::
ios
::
fmtflags
 
oldf
 = 
os
.
setf
(ios::
scientific
,ios::
floatfield
);

212 int 
	goldp
 = 
os
.
precision
(12);

215 for (int 
	gj
 = 0; j < 
	gnnz
 ; j++)

217 
	growp1
 = 
mat
.
row_ind
(
j
) +1;

218 
	gcolp1
 = 
mat
.
col_ind
(
j
) +1;

219 if ( 
	growp1
 == 
M
 && 
colp1
 == 
N
 ) 
flag
 = 1;

220 
	gos
.
width
(14);

221 
	gos
 << 
	growp1
 ; os << " " ;

222 
	gos
.
width
(14);

223 
	gos
 << 
	gcolp1
 ; os << " " ;

224 
	gos
.
width
(20);

225 
	gos
 << 
	gmat
.
val
(
j
) << "\n";

227 if (
	gflag
 == 0)

229 
os
.
width
(14);

230 
	gos
 << 
	gM
 ; os << " " ;

231 
	gos
.
width
(14);

232 
	gos
 << 
	gN
 ; os << " " ;

233 
	gos
.
width
(20);

234 
	gos
 << 
mat
(
M
-1,
N
-1) << "\n";

236 
	gos
.
setf
(
olda
,
ios
::
adjustfield
);

237 
	gos
.
setf
(
oldf
,
ios
::
floatfield
);

238 
	gos
.
precision
(
oldp
);

239 return 
	gos
;

246 
VECTOR_double
 
	gCoord_Mat_double
::
operator
*(const VECTOR_double &
x
) const

248 int 
M
 = 
dim
(0);

249 int 
	gN
 = 
dim
(1);

252 if (
	gx
.
size
() != 
N
)

254 
std
::
cerr
 << "Error in Coord Matvec -- incompatible dimensions."

256 
exit
(1);

257 return 
	gx
;

260 
VECTOR_double
 
result
(
M
, 0.0);

261 
VECTOR_double
 
work
(
M
);

263 int 
	gdescra
[9];

264 
	gdescra
[0] = 0;

265 
	gdescra
[1] = 0;

266 
	gdescra
[2] = 0;

267 
	gdescra
[4] = 0;

269 
F77NAME
(
dcoomm
) (0, 
	gM
, 1, 
	gN
, 1.0,

270 
	gdescra
, &
val_
(0), &
rowind_
(0), &
colind_
(0), 
	gnz_
,

271 &
x
(1), 
	gN
, 1.0, &
result
(1), 
	gM
,

272 &
work
(0), 
	gM
);

274 return 
	gresult
;

281 
VECTOR_double
 
	gCoord_Mat_double
::
	$trans_mult
(const 
VECTOR_double
 &
x
) const

283 int 
M
 = 
	`dim
(0);

284 int 
N
 = 
	`dim
(1);

287 if (
x
.
	`size
() != 
M
)

289 
std
::
cerr
 << "Error in Coord trans_mult -- incompatible dimensions."

291 
	`exit
(1);

292 return 
x
;

295 
VECTOR_double
 
	`result
(
N
, 0.0);

296 
VECTOR_double
 
	`work
(
N
);

298 int 
descra
[9];

299 
descra
[0] = 0;

300 
descra
[1] = 0;

301 
descra
[2] = 0;

302 
descra
[4] = 0;

304 
	`F77NAME
(
dcoomm
) (1, 
N
, 1, 
M
, 1.0,

305 
descra
, &
	`val_
(0), &
	`rowind_
(0), &
	`colind_
(0), 
nz_
,

306 &
	`x
(1), 
M
, 1.0, &
	`result
(1), 
N
,

307 &
	`work
(0), 
N
);

308 return 
result
;

309 
	}
}

	@src/diagpre.cc

31 #include 
	~<stdlib.h
>

32 #include 
	~"diagpre.h
"

35 
	$CopyInvDiagonals
(int 
n
, const int *
pntr
, const int *
indx
,

36 const double *
sa
, double *
diag
)

38 int 
i
, 
j
;

40 for (
i
 = 0; i < 
n
; i++)

41 
diag
[
i
] = 0;

44 for (
i
 = 0; i < 
n
; i++) {

45 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++) {

46 if (
indx
[
j
] == 
i
) {

47 if (
sa
[
j
] == 0)

48 return 
i
;

49 
diag
[
i
] = 1. / 
sa
[
j
];

53 if (
diag
[
i
] == 0)

54 return -
i
;

58 
	}
}

61 
	gDiagPreconditioner
::
	$DiagPreconditioner
(const 
CompRow_MatDouble
 &
C
)

62 : 
	`diag_
(
C
.
	$dim
(0))

64 int 
i
;

66 if ((
i
 = 
	`CopyInvDiagonals
(
C
.
	`dim
(0), &C.
	`row_ptr
(0), &C.
	`col_ind
(0),

67 &
C
.
	`val
(0), &
	`diag
(0))) != 0) {

68 
std
::
cerr
 << "Diagonal preconditioner failure.";

69 
std
::
cerr
 << " Zero detected in element " << 
i
 << "\n";

70 
	`exit
(1);

72 
	}
}

75 
	gDiagPreconditioner
::
	$DiagPreconditioner
(const 
CompCol_MatDouble
 &
C
)

76 : 
	`diag_
 (
C
.
	$dim
 (0))

78 int 
i
;

80 if ((
i
 = 
	`CopyInvDiagonals
(
C
.
	`dim
(0), &C.
	`col_ptr
(0), &C.
	`row_ind
(0),

81 &
C
.
	`val
(0), &
	`diag
(0))) != 0) {

82 
std
::
cerr
 << "Diagonal preconditioner failure.";

83 
std
::
cerr
 << " Zero detected in element " << 
i
 << "\n";

84 
	`exit
(1);

86 
	}
}

89 
	gMV_Vector
<double>

90 
	gDiagPreconditioner
::
solve
 (const 
MV_Vector
<double> &
x
) const

92 
MV_Vector
<double> 
y
(
x
.
size
());

94 for (int 
	gi
 = 0; i < 
	gx
.
size
(); i++)

95 
y
(
i
) = 
x
(i) * 
diag
(i);

97 return 
	gy
;

101 
	gMV_Vector
<double>

102 
	gDiagPreconditioner
::
trans_solve
 (const 
MV_Vector
<double> &
x
) const

104 
MV_Vector
<double> 
y
(
x
.
size
());

106 for (int 
	gi
 = 0; i < 
	gx
.
size
(); i++)

107 
y
(
i
) = 
x
(i) * 
diag
(i);

109 return 
	gy
;

	@src/diagpre_double.cc

31 #include 
	~<iostream
>

32 #include 
	~<stdlib.h
>

33 #include 
	~"diagpre_double.h
"

36 
	$CopyInvDiagonals
(int 
n
, const int *
pntr
, const int *
indx
,

37 const double *
sa
, double *
diag
)

39 int 
i
, 
j
;

41 for (
i
 = 0; i < 
n
; i++)

42 
diag
[
i
] = 0;

45 for (
i
 = 0; i < 
n
; i++) {

46 for (
j
 = 
pntr
[
i
]; j < pntr[i+1]; j++) {

47 if (
indx
[
j
] == 
i
) {

48 if (
sa
[
j
] == 0)

49 return 
i
;

50 
diag
[
i
] = 1. / 
sa
[
j
];

54 if (
diag
[
i
] == 0)

55 return -
i
;

59 
	}
}

62 
	gDiagPreconditioner_double
::
	$DiagPreconditioner_double
(const 
CompRow_Mat_double
 &
C
)

63 : 
	`diag_
(
C
.
	$dim
(0))

65 int 
i
;

67 if ((
i
 = 
	`CopyInvDiagonals
(
C
.
	`dim
(0), &C.
	`row_ptr
(0), &C.
	`col_ind
(0),

68 &
C
.
	`val
(0), &
	`diag
(0))) != 0) {

69 
std
::
cerr
 << "Diagonal preconditioner failure.";

70 
std
::
cerr
 << " Zero detected in element " << 
i
 << "\n";

71 
	`exit
(1);

73 
	}
}

76 
	gDiagPreconditioner_double
::
	$DiagPreconditioner_double
(const 
CompCol_Mat_double
 &
C
)

77 : 
	`diag_
 (
C
.
	$dim
 (0))

79 int 
i
;

81 if ((
i
 = 
	`CopyInvDiagonals
(
C
.
	`dim
(0), &C.
	`col_ptr
(0), &C.
	`row_ind
(0),

82 &
C
.
	`val
(0), &
	`diag
(0))) != 0) {

83 
std
::
cerr
 << "Diagonal preconditioner failure.";

84 
std
::
cerr
 << " Zero detected in element " << 
i
 << "\n";

85 
	`exit
(1);

87 
	}
}

90 
VECTOR_double


91 
	gDiagPreconditioner_double
::
	$solve
 (const 
VECTOR_double
 &
x
) const

93 
VECTOR_double
 
	`y
(
x
.
	`size
());

95 for (int 
i
 = 0; i < 
x
.
	`size
(); i++)

96 
	`y
(
i
) = 
	`x
(i) * 
	`diag
(i);

98 return 
y
;

99 
	}
}

102 
VECTOR_double


103 
	gDiagPreconditioner_double
::
	$trans_solve
 (const 
VECTOR_double
 &
x
) const

105 
VECTOR_double
 
	`y
(
x
.
	`size
());

107 for (int 
i
 = 0; i < 
x
.
	`size
(); i++)

108 
	`y
(
i
) = 
	`x
(i) * 
	`diag
(i);

110 return 
y
;

111 
	}
}

	@src/icpre.cc

31 #include 
	~<iostream
>

32 #include 
	~<stdlib.h
>

33 #include 
	~<math.h
>

34 #include 
	~"icpre.h
"

35 #include 
	~"qsort.h
"

37 #include 
	~"spblas.h
"

40 
ICFactor
(const 
MV_Vector
<int> &
ia
, const MV_Vector<int> &
ja
, MV_Vector<double> &
sa
);

42 
ICSolve
(const 
MV_Vector
<int> &
ia
, const MV_Vector<int> &
ja
,

43 const 
MV_Vector
<double> &
sa
, MV_Vector<double> &
dest
);

46 
	gICPreconditioner
::
	$ICPreconditioner
(const 
CompCol_MatDouble
 &
A
)

47 : 
	`nz_
(0), 
	`pntr_
(
A
.
	`dim
(1)+1), 
	`indx_
(0), 
	$val_
(0)

49 
dim_
[0] = 
A
.
	`dim
(0);

50 
dim_
[1] = 
A
.
	`dim
(1);

52 int 
i
, 
j
, 
k
;

54 for (
k
 = 0; k < 
dim_
[1]; k++)

55 for (
j
 = 
A
.
	`col_ptr
(
k
); j < A.col_ptr(k+1); j++)

56 if (
A
.
	`row_ind
(
j
) >= 
k
)

57 
nz_
++;

59 
val_
.
	`newsize
(
nz_
);

60 
indx_
.
	`newsize
(
nz_
);

63 
	`pntr_
(0) = 0;

64 for (
k
 = 0; k < 
dim_
[1]; k++) {

65 
	`pntr_
(
k
+1) = pntr_(k);

66 for (
j
 = 
A
.
	`col_ptr
(
k
); j < A.col_ptr(k+1); j++) {

67 if (
A
.
	`row_ind
(
j
) >= 
k
) {

68 
i
 = 
	`pntr_
(
k
+1)++;

69 
	`val_
(
i
) = 
A
.
	`val
(
j
);

70 
	`indx_
(
i
) = 
A
.
	`row_ind
(
j
);

75 for (
i
 = 0; i < 
dim_
[1]; i++)

76 
	`QSort
(
indx_
, 
val_
, 
pntr_
[
i
], pntr_[i+1] - pntr_[i]);

78 for (
i
 = 0; i < 
dim_
[1]; i++)

79 if (
indx_
[
	`pntr_
(
i
)] != i) {

80 
std
::
cerr
 << "IC Preconditioner: diagonal not found!" << 
i
 << "\n";

81 
	`exit
(1);

84 
	`ICFactor
(
pntr_
, 
indx_
, 
val_
);

85 
	}
}

88 
	gICPreconditioner
::
	$ICPreconditioner
(const 
CompRow_MatDouble
 &
A
)

89 : 
	`nz_
(0), 
	`pntr_
(
A
.
	`dim
(0)+1), 
	`indx_
(0), 
	$val_
(0)

91 
dim_
[0] = 
A
.
	`dim
(0);

92 
dim_
[1] = 
A
.
	`dim
(1);

94 int 
i
, 
j
, 
k
;

96 for (
k
 = 0; k < 
dim_
[0]; k++)

97 for (
j
 = 
A
.
	`row_ptr
(
k
); j < A.row_ptr(k+1); j++)

98 if (
A
.
	`col_ind
(
j
) >= 
k
)

99 
nz_
++;

101 
val_
.
	`newsize
(
nz_
);

102 
indx_
.
	`newsize
(
nz_
);

105 
	`pntr_
(0) = 0;

106 for (
k
 = 0; k < 
dim_
[0]; k++) {

107 
	`pntr_
(
k
+1) = pntr_(k);

108 for (
j
 = 
A
.
	`row_ptr
(
k
); j < A.row_ptr(k+1); j++) {

109 if (
A
.
	`col_ind
(
j
) >= 
k
) {

110 
i
 = 
	`pntr_
(
k
+1)++;

111 
	`val_
(
i
) = 
A
.
	`val
(
j
);

112 
	`indx_
(
i
) = 
A
.
	`col_ind
(
j
);

117 for (
i
 = 0; i < 
dim_
[0]; i++)

118 
	`QSort
(
indx_
, 
val_
, 
pntr_
[
i
], pntr_[i+1] - pntr_[i]);

120 for (
i
 = 0; i < 
dim_
[0]; i++)

121 if (
indx_
[
	`pntr_
(
i
)] != i) {

122 
std
::
cerr
 << "IC Preconditioner: diagonal not found!" << 
i
 << "\n";

123 
	`exit
(1);

126 
	`ICFactor
(
pntr_
, 
indx_
, 
val_
);

127 
	}
}

130 
	gMV_Vector
<double>

131 
	gICPreconditioner
::
solve
(const 
MV_Vector
<double> &
x
) const

133 
MV_Vector
<double> 
y
(
x
);

135 
ICSolve
(
pntr_
, 
indx_
, 
val_
, 
y
);

137 return 
	gy
;

141 
	gMV_Vector
<double>

142 
	gICPreconditioner
::
trans_solve
(const 
MV_Vector
<double> &
x
) const

144 
MV_Vector
<double> 
y
(
x
);

146 
ICSolve
(
pntr_
, 
indx_
, 
val_
, 
y
);

148 return 
	gy
;

153 
ICFactor
(const 
MV_Vector
<int> &
pntr
, const MV_Vector<int> &
indx
,

154 
MV_Vector
<double> &
val
)

156 int 
	gd
, 
	gg
, 
	gh
, 
	gi
, 
	gj
, 
	gk
, 
	gn
 = 
pntr
.
size
() - 1;

157 double 
	gz
;

159 for (
	gk
 = 0; k < 
	gn
 - 1; k++) {

160 
	gd
 = 
pntr
[
k
];

161 
	gz
 = 
val
[
d
] = 
sqrt
(val[d]);

163 for (
	gi
 = 
d
 + 1; i < 
	gpntr
[
k
+1]; i++)

164 
	gval
[
i
] /= 
z
;

166 for (
	gi
 = 
d
 + 1; i < 
	gpntr
[
k
+1]; i++) {

167 
	gz
 = 
val
[
i
];

168 
	gh
 = 
indx
[
i
];

169 
	gg
 = 
i
;

171 for (
	gj
 = 
pntr
[
h
] ; j < 
	gpntr
[h+1]; j++)

172 for ( ; 
	gg
 < 
	gpntr
[
k
+1] && 
	gindx
[
g
+1] <= 
indx
[
j
]; g++)

173 if (
	gindx
[
g
] == 
indx
[
j
])

174 
val
[
j
] -= 
z
 * val[
g
];

177 
	gd
 = 
pntr
[
n
-1];

178 
	gval
[
d
] = 
sqrt
(
val
[d]);

183 
ICSolve
(const 
MV_Vector
<int> &
pntr
, const MV_Vector<int> &
indx
,

184 const 
MV_Vector
<double> &
val
, MV_Vector<double> &
dest
)

186 int 
	gM
 = 
dest
.
size
();

187 
	gMV_Vector
<double> 
work
(
M
);

189 int 
	gdescra
[9];

191 
	gdescra
[0] = 0;

194 
	gdescra
[1] = 1;

195 
	gdescra
[2] = 0;

197 
F77NAME
(
dcscsm
) (0, 
	gM
, 1, 1, 
	gNULL
, 1.0,

198 
	gdescra
, &
val
(0), &
indx
(0), &
pntr
(0),

199 &
dest
(0), 
	gM
, 0.0, &dest(1), M,

200 &
work
(0), 
	gM
);

203 
F77NAME
(
dcscsm
) (1, 
	gM
, 1, 1, 
	gNULL
, 1.0,

204 
	gdescra
, &
val
(0), &
indx
(0), &
pntr
(0),

205 &
dest
(0), 
	gM
, 0.0, &dest(1), M,

206 &
work
(0), 
	gM
);

	@src/icpre_double.cc

31 #include 
	~<iostream
>

32 #include 
	~<stdlib.h
>

33 #include 
	~<math.h
>

34 #include 
	~"icpre_double.h
"

35 #include 
	~"qsort_double.h
"

36 #include 
	~"qsort_int.h
"

37 #include 
	~"spblas.h
"

40 
ICFactor
(const 
VECTOR_int
 &
ia
, const VECTOR_int &
ja
, 
VECTOR_double
 &
sa
);

42 
ICSolve
(const 
VECTOR_int
 &
ia
, const VECTOR_int &
ja
,

43 const 
VECTOR_double
 &
sa
, VECTOR_double &
dest
);

46 
	gICPreconditioner_double
::
	$ICPreconditioner_double
(const 
CompCol_Mat_double
 &
A
)

47 : 
	`val_
(0), 
	`pntr_
(
A
.
	`dim
(1)+1), 
	`indx_
(0), 
	$nz_
(0)

49 
dim_
[0] = 
A
.
	`dim
(0);

50 
dim_
[1] = 
A
.
	`dim
(1);

52 int 
i
, 
j
, 
k
;

54 for (
k
 = 0; k < 
dim_
[1]; k++)

55 for (
j
 = 
A
.
	`col_ptr
(
k
); j < A.col_ptr(k+1); j++)

56 if (
A
.
	`row_ind
(
j
) >= 
k
)

57 
nz_
++;

59 
val_
.
	`newsize
(
nz_
);

60 
indx_
.
	`newsize
(
nz_
);

63 
	`pntr_
(0) = 0;

64 for (
k
 = 0; k < 
dim_
[1]; k++) {

65 
	`pntr_
(
k
+1) = pntr_(k);

66 for (
j
 = 
A
.
	`col_ptr
(
k
); j < A.col_ptr(k+1); j++) {

67 if (
A
.
	`row_ind
(
j
) >= 
k
) {

68 
i
 = 
	`pntr_
(
k
+1)++;

69 
	`val_
(
i
) = 
A
.
	`val
(
j
);

70 
	`indx_
(
i
) = 
A
.
	`row_ind
(
j
);

75 for (
i
 = 0; i < 
dim_
[1]; i++)

76 
	`QSort
(
indx_
, 
val_
, 
pntr_
[
i
], pntr_[i+1] - pntr_[i]);

78 for (
i
 = 0; i < 
dim_
[1]; i++)

79 if (
indx_
[
	`pntr_
(
i
)] != i) {

80 
std
::
cerr
 << "IC Preconditioner: diagonal not found!" << 
i
 << "\n";

81 
	`exit
(1);

84 
	`ICFactor
(
pntr_
, 
indx_
, 
val_
);

85 
	}
}

88 
	gICPreconditioner_double
::
	$ICPreconditioner_double
(const 
CompRow_Mat_double
 &
A
)

89 : 
	`val_
(0), 
	`pntr_
(
A
.
	`dim
(0)+1), 
	`indx_
(0), 
	$nz_
(0)

91 
dim_
[0] = 
A
.
	`dim
(0);

92 
dim_
[1] = 
A
.
	`dim
(1);

94 int 
i
, 
j
, 
k
;

96 for (
k
 = 0; k < 
dim_
[0]; k++)

97 for (
j
 = 
A
.
	`row_ptr
(
k
); j < A.row_ptr(k+1); j++)

98 if (
A
.
	`col_ind
(
j
) >= 
k
)

99 
nz_
++;

101 
val_
.
	`newsize
(
nz_
);

102 
indx_
.
	`newsize
(
nz_
);

105 
	`pntr_
(0) = 0;

106 for (
k
 = 0; k < 
dim_
[0]; k++) {

107 
	`pntr_
(
k
+1) = pntr_(k);

108 for (
j
 = 
A
.
	`row_ptr
(
k
); j < A.row_ptr(k+1); j++) {

109 if (
A
.
	`col_ind
(
j
) >= 
k
) {

110 
i
 = 
	`pntr_
(
k
+1)++;

111 
	`val_
(
i
) = 
A
.
	`val
(
j
);

112 
	`indx_
(
i
) = 
A
.
	`col_ind
(
j
);

117 for (
i
 = 0; i < 
dim_
[0]; i++)

118 
	`QSort
(
indx_
, 
val_
, 
pntr_
[
i
], pntr_[i+1] - pntr_[i]);

120 for (
i
 = 0; i < 
dim_
[0]; i++)

121 if (
indx_
[
	`pntr_
(
i
)] != i) {

122 
std
::
cerr
 << "IC Preconditioner: diagonal not found!" << 
i
 << "\n";

123 
	`exit
(1);

126 
	`ICFactor
(
pntr_
, 
indx_
, 
val_
);

127 
	}
}

130 
VECTOR_double


131 
	gICPreconditioner_double
::
	$solve
(const 
VECTOR_double
 &
x
) const

133 
VECTOR_double
 
	`y
(
x
);

135 
	`ICSolve
(
pntr_
, 
indx_
, 
val_
, 
y
);

137 return 
y
;

138 
	}
}

141 
VECTOR_double


142 
	gICPreconditioner_double
::
	$trans_solve
(const 
VECTOR_double
 &
x
) const

144 
VECTOR_double
 
	`y
(
x
);

146 
	`ICSolve
(
pntr_
, 
indx_
, 
val_
, 
y
);

148 return 
y
;

149 
	}
}

153 
	$ICFactor
(const 
VECTOR_int
 &
pntr
, const VECTOR_int &
indx
,

154 
VECTOR_double
 &
val
)

156 int 
d
, 
g
, 
h
, 
i
, 
j
, 
k
, 
n
 = 
pntr
.
	`size
() - 1;

157 double 
z
;

159 for (
k
 = 0; k < 
n
 - 1; k++) {

160 
d
 = 
pntr
[
k
];

161 
z
 = 
val
[
d
] = 
	`sqrt
(val[d]);

163 for (
i
 = 
d
 + 1; i < 
pntr
[
k
+1]; i++)

164 
val
[
i
] /= 
z
;

166 for (
i
 = 
d
 + 1; i < 
pntr
[
k
+1]; i++) {

167 
z
 = 
val
[
i
];

168 
h
 = 
indx
[
i
];

169 
g
 = 
i
;

171 for (
j
 = 
pntr
[
h
] ; j < pntr[h+1]; j++)

172 for ( ; 
g
 < 
pntr
[
k
+1] && 
indx
[g+1] <= indx[
j
]; g++)

173 if (
indx
[
g
] == indx[
j
])

174 
val
[
j
] -= 
z
 * val[
g
];

177 
d
 = 
pntr
[
n
-1];

178 
val
[
d
] = 
	`sqrt
(val[d]);

179 
	}
}

183 
	$ICSolve
(const 
VECTOR_int
 &
pntr
, const VECTOR_int &
indx
,

184 const 
VECTOR_double
 &
val
, VECTOR_double &
dest
)

186 int 
M
 = 
dest
.
	`size
();

187 
VECTOR_double
 
	`work
(
M
);

189 int 
descra
[9];

191 
descra
[0] = 0;

194 
descra
[1] = 1;

195 
descra
[2] = 0;

197 
	`F77NAME
(
dcscsm
) (0, 
M
, 1, 1, 
NULL
, 1.0,

198 
descra
, &
	`val
(0), &
	`indx
(0), &
	`pntr
(0),

199 &
	`dest
(0), 
M
, 0.0, &dest(1), M,

200 &
	`work
(0), 
M
);

203 
	`F77NAME
(
dcscsm
) (1, 
M
, 1, 1, 
NULL
, 1.0,

204 
descra
, &
	`val
(0), &
	`indx
(0), &
	`pntr
(0),

205 &
	`dest
(0), 
M
, 0.0, &dest(1), M,

206 &
	`work
(0), 
M
);

207 
	}
}

	@src/ilupre.cc

33 #include 
	~<stdlib.h
>

34 #include 
	~"ilupre.h
"

35 #include 
	~"qsort.h
"

37 #include 
	~"spblas.h
"

39 
	gCompCol_ILUPreconditioner
::

40 
	$CompCol_ILUPreconditioner
(const 
CompCol_MatDouble
 &
A
)

41 : 
	`l_colptr_
(
A
.
	`dim
(1) + 1), 
	`u_colptr_
(A.dim(1) + 1),

42 
	`l_rowind_
(0), 
	`u_rowind_
(0),

43 
	`l_val_
(0), 
	$u_val_
(0)

45 int 
i
, 
j
, 
k
, 
pn
, 
qn
, 
rn
;

46 double 
multiplier
;

49 
dim_
[0] = 
A
.
	`dim
(0);

50 
dim_
[1] = 
A
.
	`dim
(1);

52 
l_nz_
 = 
u_nz_
 = 0;

55 for (
i
 = 0; i < 
dim_
[1]; i++)

56 for (
j
 = 
A
.
	`col_ptr
(
i
); j < A.col_ptr(i+1); j++)

57 if (
A
.
	`row_ind
(
j
) > 
i
)

58 
l_nz_
++;

60 
u_nz_
++;

62 
l_val_
.
	`newsize
(
l_nz_
);

63 
u_val_
.
	`newsize
(
u_nz_
);

64 
l_rowind_
.
	`newsize
(
l_nz_
);

65 
u_rowind_
.
	`newsize
(
u_nz_
);

67 
	`l_colptr_
(0) = 
	`u_colptr_
(0) = 0;

70 for (
i
 = 0; i < 
dim_
[1]; i++) {

71 
	`l_colptr_
(
i
+1) = l_colptr_(i);

72 
	`u_colptr_
(
i
+1) = u_colptr_(i);

74 for (
j
 = 
A
.
	`col_ptr
(
i
); j < A.col_ptr(i+1); j++)

75 if (
A
.
	`row_ind
(
j
) > 
i
) {

76 
k
 = 
	`l_colptr_
(
i
+1)++;

77 
	`l_val_
(
k
) = 
A
.
	`val
(
j
);

78 
	`l_rowind_
(
k
) = 
A
.
	`row_ind
(
j
);

79 } else if (
A
.
	`row_ind
(
j
) <= 
i
) {

80 
k
 = 
	`u_colptr_
(
i
+1)++;

81 
	`u_val_
(
k
) = 
A
.
	`val
(
j
);

82 
	`u_rowind_
(
k
) = 
A
.
	`row_ind
(
j
);

86 for (
i
 = 0; i < 
dim_
[1]; i++) {

87 
	`QSort
(
l_rowind_
, 
l_val_
, 
l_colptr_
[
i
], l_colptr_[i+1] - l_colptr_[i]);

88 
	`QSort
(
u_rowind_
, 
u_val_
, 
u_colptr_
[
i
], u_colptr_[i+1] - u_colptr_[i]);

92 for (
i
 = 0; i < 
dim_
[0] - 1; i++) {

93 
multiplier
 = 
	`u_val_
(
	`u_colptr_
(
i
+1)-1);

95 for (
j
 = 
l_colptr_
[
i
]; j < l_colptr_[i+1]; j++)

96 
l_val_
[
j
] /= 
multiplier
;

98 for (
j
 = 
u_colptr_
[
i
+1]; j < u_colptr_[i+2]-1; j++) {

99 
multiplier
 = 
u_val_
[
j
];

100 
qn
 = 
j
 + 1;

101 
rn
 = 
l_colptr_
[
i
+1];

102 for (
pn
 = 
l_colptr_
[
u_rowind_
[
j
]];

103 
l_rowind_
[
pn
] <= 
i
 + 1 && pn < 
l_colptr_
[
u_rowind_
[
j
]+1];

104 
pn
++) {

105 while (
u_rowind_
[
qn
] < 
l_rowind_
[
pn
] && qn < 
u_colptr_
[
i
+2])

106 
qn
++;

107 if (
l_rowind_
[
pn
] == 
u_rowind_
[
qn
] && qn < 
u_colptr_
[
i
+2])

108 
u_val_
[
qn
] -= 
multiplier
 * 
l_val_
[
pn
];

110 for (; 
pn
 < 
l_colptr_
[
u_rowind_
[
j
]+1]; pn++) {

111 while (
l_rowind_
[
rn
] < l_rowind_[
pn
] && rn < 
l_colptr_
[
i
+2])

112 
rn
++;

113 if (
l_rowind_
[
pn
] == l_rowind_[
rn
] && rn < 
l_colptr_
[
i
+2])

114 
l_val_
[
rn
] -= 
multiplier
 * l_val_[
pn
];

118 
	}
}

121 
	gCompRow_ILUPreconditioner
::

122 
	$CompRow_ILUPreconditioner
(const 
CompRow_MatDouble
 &
A
)

123 : 
	`l_rowptr_
(
A
.
	`dim
(1) + 1), 
	`u_rowptr_
(A.dim(1) + 1),

124 
	`l_colind_
(0), 
	`u_colind_
(0),

125 
	`l_val_
(0), 
	$u_val_
(0)

127 int 
i
, 
j
, 
k
, 
pn
, 
qn
, 
rn
;

128 double 
multiplier
;

131 
dim_
[0] = 
A
.
	`dim
(0);

132 
dim_
[1] = 
A
.
	`dim
(1);

134 
l_nz_
 = 
u_nz_
 = 0;

137 for (
i
 = 0; i < 
dim_
[1]; i++)

138 for (
j
 = 
A
.
	`row_ptr
(
i
); j < A.row_ptr(i+1); j++)

139 if (
A
.
	`col_ind
(
j
) < 
i
)

140 
l_nz_
++;

142 
u_nz_
++;

144 
l_val_
.
	`newsize
(
l_nz_
);

145 
u_val_
.
	`newsize
(
u_nz_
);

146 
l_colind_
.
	`newsize
(
l_nz_
);

147 
u_colind_
.
	`newsize
(
u_nz_
);

149 
	`l_rowptr_
(0) = 
	`u_rowptr_
(0) = 0;

152 for (
i
 = 0; i < 
dim_
[1]; i++) {

153 
	`l_rowptr_
(
i
+1) = l_rowptr_(i);

154 
	`u_rowptr_
(
i
+1) = u_rowptr_(i);

156 for (
j
 = 
A
.
	`row_ptr
(
i
); j < A.row_ptr(i+1); j++)

157 if (
A
.
	`col_ind
(
j
) < 
i
) {

158 
k
 = 
	`l_rowptr_
(
i
+1)++;

159 
	`l_val_
(
k
) = 
A
.
	`val
(
j
);

160 
	`l_colind_
(
k
) = 
A
.
	`col_ind
(
j
);

161 } else if (
A
.
	`col_ind
(
j
) >= 
i
) {

162 
k
 = 
	`u_rowptr_
(
i
+1)++;

163 
	`u_val_
(
k
) = 
A
.
	`val
(
j
);

164 
	`u_colind_
(
k
) = 
A
.
	`col_ind
(
j
);

168 for (
i
 = 0; i < 
dim_
[1]; i++) {

169 
	`QSort
(
l_colind_
, 
l_val_
, 
l_rowptr_
[
i
], l_rowptr_[i+1] - l_rowptr_[i]);

170 
	`QSort
(
u_colind_
, 
u_val_
, 
u_rowptr_
[
i
], u_rowptr_[i+1] - u_rowptr_[i]);

174 for (
i
 = 1; i < 
dim_
[0]; i++) {

175 for (
j
 = 
l_rowptr_
[
i
]; j < l_rowptr_[i+1]; j++) {

176 
pn
 = 
u_rowptr_
[
l_colind_
[
j
]];

177 
multiplier
 = (
l_val_
[
j
] /= 
u_val_
[
pn
]);

179 
qn
 = 
j
 + 1;

180 
rn
 = 
u_rowptr_
[
i
];

182 for (
pn
++; 
u_colind_
[pn] < 
i
 && pn < 
u_rowptr_
[
l_colind_
[
j
]+1]; pn++) {

183 while (
l_colind_
[
qn
] < 
u_colind_
[
pn
] && qn < 
l_rowptr_
[
i
+1])

184 
qn
++;

185 if (
u_colind_
[
pn
] == 
l_colind_
[
qn
] && qn < 
l_rowptr_
[
i
+1])

186 
l_val_
[
qn
] -= 
multiplier
 * 
u_val_
[
pn
];

188 for (; 
pn
 < 
u_rowptr_
[
l_colind_
[
j
]+1]; pn++) {

189 while (
u_colind_
[
rn
] < u_colind_[
pn
] && rn < 
u_rowptr_
[
i
+1])

190 
rn
++;

191 if (
u_colind_
[
pn
] == u_colind_[
rn
] && rn < 
u_rowptr_
[
i
+1])

192 
u_val_
[
rn
] -= 
multiplier
 * u_val_[
pn
];

196 
	}
}

199 
	gMV_Vector
<double>

200 
	gCompCol_ILUPreconditioner
::
solve
(const 
MV_Vector
<double> &
x
) const

202 int 
M
 = 
x
.
size
();

203 
	gMV_Vector
<double> 
y
(
M
);

204 
	gMV_Vector
<double> 
work
(
M
);

206 int 
	gdescra
[9];

208 
	gdescra
[0] = 0;

211 
	gdescra
[1] = 1;

212 
	gdescra
[2] = 1;

214 
F77NAME
(
dcscsm
) (0, 
	gM
, 1, 1, 
	gNULL
, 1.0,

215 
	gdescra
, &
l_val_
(0), &
l_rowind_
(0), &
l_colptr_
(0),

216 &
x
(0), 
	gM
, 0.0, &
y
(1), M,

217 &
work
(0), 
	gM
);

220 
	gdescra
[1] = 2;

221 
	gdescra
[2] = 0;

223 
F77NAME
(
dcscsm
) (0, 
	gM
, 1, 1, 
	gNULL
, 1.0,

224 
	gdescra
, &
u_val_
(0), &
u_rowind_
(0), &
u_colptr_
(0),

225 &
y
(0), 
	gM
, 0.0, &y(1), M,

226 &
work
(0), 
	gM
);

228 return 
	gy
;

232 
	gMV_Vector
<double>

233 
	gCompCol_ILUPreconditioner
::
trans_solve
(const 
MV_Vector
<double> &
x
) const

235 int 
M
 = 
x
.
size
();

236 
	gMV_Vector
<double> 
y
(
M
);

237 
	gMV_Vector
<double> 
work
(
M
);

239 int 
	gdescra
[9];

241 
	gdescra
[0] = 0;

244 
	gdescra
[1] = 2;

245 
	gdescra
[2] = 0;

247 
F77NAME
(
dcscsm
) (1, 
	gM
, 1, 1, 
	gNULL
, 1.0,

248 
	gdescra
, &
u_val_
(0), &
u_rowind_
(0), &
u_colptr_
(0),

249 &
x
(0), 
	gM
, 0.0, &
y
(1), M,

250 &
work
(0), 
	gM
);

253 
	gdescra
[1] = 1;

254 
	gdescra
[2] = 1;

256 
F77NAME
(
dcscsm
) (1, 
	gM
, 1, 1, 
	gNULL
, 1.0,

257 
	gdescra
, &
l_val_
(0), &
l_rowind_
(0), &
l_colptr_
(0),

258 &
y
(0), 
	gM
, 0.0, &y(1), M,

259 &
work
(0), 
	gM
);

261 return 
	gy
;

265 
	gMV_Vector
<double>

266 
	gCompRow_ILUPreconditioner
::
solve
(const 
MV_Vector
<double> &
x
) const

268 int 
M
 = 
x
.
size
();

269 
	gMV_Vector
<double> 
y
(
M
);

270 
	gMV_Vector
<double> 
work
(
M
);

272 int 
	gdescra
[9];

274 
	gdescra
[0] = 0;

277 
	gdescra
[1] = 1;

278 
	gdescra
[2] = 1;

280 
F77NAME
(
dcsrsm
) (0, 
	gM
, 1, 1, 
	gNULL
, 1.0,

281 
	gdescra
, &
l_val_
(0), &
l_colind_
(0), &
l_rowptr_
(0),

282 &
x
(0), 
	gM
, 0.0, &
y
(1), M,

283 &
work
(0), 
	gM
);

286 
	gdescra
[1] = 2;

287 
	gdescra
[2] = 0;

289 
F77NAME
(
dcsrsm
) (0, 
	gM
, 1, 1, 
	gNULL
, 1.0,

290 
	gdescra
, &
u_val_
(0), &
u_colind_
(0), &
u_rowptr_
(0),

291 &
y
(0), 
	gM
, 0.0, &y(1), M,

292 &
work
(0), 
	gM
);

294 return 
	gy
;

298 
	gMV_Vector
<double>

299 
	gCompRow_ILUPreconditioner
::
trans_solve
(const 
MV_Vector
<double> &
x
) const

301 int 
M
 = 
x
.
size
();

302 
	gMV_Vector
<double> 
y
(
M
);

303 
	gMV_Vector
<double> 
work
(
M
);

305 int 
	gdescra
[9];

307 
	gdescra
[0] = 0;

310 
	gdescra
[1] = 2;

311 
	gdescra
[2] = 0;

313 
F77NAME
(
dcsrsm
) (1, 
	gM
, 1, 1, 
	gNULL
, 1.0,

314 
	gdescra
, &
u_val_
(0), &
u_colind_
(0), &
u_rowptr_
(0),

315 &
x
(0), 
	gM
, 0.0, &
y
(1), M,

316 &
work
(0), 
	gM
);

319 
	gdescra
[1] = 1;

320 
	gdescra
[2] = 1;

322 
F77NAME
(
dcsrsm
) (1, 
	gM
, 1, 1, 
	gNULL
, 1.0,

323 
	gdescra
, &
l_val_
(0), &
l_colind_
(0), &
l_rowptr_
(0),

324 &
y
(0), 
	gM
, 0.0, &y(1), M,

325 &
work
(0), 
	gM
);

327 return 
	gy
;

	@src/ilupre_1.5.cc

31 #include 
	~<stdlib.h
>

32 #include 
	~"ilupre.h
"

33 #include 
	~"qsort.h
"

35 #include 
	~"spblas.h
"

37 
	gCompCol_ILUPreconditioner
::

38 
	$CompCol_ILUPreconditioner
(const 
CompCol_MatDouble
 &
A
)

39 : 
	`l_colptr_
(
A
.
	`dim
(1) + 1), 
	`u_colptr_
(A.dim(1) + 1),

40 
	`l_rowind_
(0), 
	`u_rowind_
(0),

41 
	`l_val_
(0), 
	$u_val_
(0)

43 int 
i
, 
j
, 
k
, 
pn
, 
qn
, 
rn
;

44 double 
multiplier
;

47 
dim_
[0] = 
A
.
	`dim
(0);

48 
dim_
[1] = 
A
.
	`dim
(1);

50 
l_nz_
 = 
u_nz_
 = 0;

53 for (
i
 = 0; i < 
dim_
[1]; i++)

54 for (
j
 = 
A
.
	`col_ptr
(
i
); j < A.col_ptr(i+1); j++)

55 if (
A
.
	`row_ind
(
j
) > 
i
)

56 
l_nz_
++;

58 
u_nz_
++;

60 
l_val_
.
	`newsize
(
l_nz_
);

61 
u_val_
.
	`newsize
(
u_nz_
);

62 
l_rowind_
.
	`newsize
(
l_nz_
);

63 
u_rowind_
.
	`newsize
(
u_nz_
);

65 
	`l_colptr_
(0) = 
	`u_colptr_
(0) = 0;

68 for (
i
 = 0; i < 
dim_
[1]; i++) {

69 
	`l_colptr_
(
i
+1) = l_colptr_(i);

70 
	`u_colptr_
(
i
+1) = u_colptr_(i);

72 for (
j
 = 
A
.
	`col_ptr
(
i
); j < A.col_ptr(i+1); j++)

73 if (
A
.
	`row_ind
(
j
) > 
i
) {

74 
k
 = 
	`l_colptr_
(
i
+1)++;

75 
	`l_val_
(
k
) = 
A
.
	`val
(
j
);

76 
	`l_rowind_
(
k
) = 
A
.
	`row_ind
(
j
);

77 } else if (
A
.
	`row_ind
(
j
) <= 
i
) {

78 
k
 = 
	`u_colptr_
(
i
+1)++;

79 
	`u_val_
(
k
) = 
A
.
	`val
(
j
);

80 
	`u_rowind_
(
k
) = 
A
.
	`row_ind
(
j
);

84 for (
i
 = 0; i < 
dim_
[1]; i++) {

85 
	`QSort
(
l_rowind_
, 
l_val_
, 
l_colptr_
[
i
], l_colptr_[i+1] - l_colptr_[i]);

86 
	`QSort
(
u_rowind_
, 
u_val_
, 
u_colptr_
[
i
], u_colptr_[i+1] - u_colptr_[i]);

90 for (
i
 = 0; i < 
dim_
[0] - 1; i++) {

91 
multiplier
 = 
	`u_val_
(
	`u_colptr_
(
i
+1)-1);

93 for (
j
 = 
l_colptr_
[
i
]; j < l_colptr_[i+1]; j++)

94 
l_val_
[
j
] /= 
multiplier
;

96 for (
j
 = 
u_colptr_
[
i
+1]; j < u_colptr_[i+2]-1; j++) {

97 
multiplier
 = 
u_val_
[
j
];

98 
qn
 = 
j
 + 1;

99 
rn
 = 
l_colptr_
[
i
+1];

100 for (
pn
 = 
l_colptr_
[
u_rowind_
[
j
]];

101 
l_rowind_
[
pn
] <= 
i
 + 1 && pn < 
l_colptr_
[
u_rowind_
[
j
]+1];

102 
pn
++) {

103 while (
u_rowind_
[
qn
] < 
l_rowind_
[
pn
] && qn < 
u_colptr_
[
i
+2])

104 
qn
++;

105 if (
l_rowind_
[
pn
] == 
u_rowind_
[
qn
])

106 
u_val_
[
qn
] -= 
multiplier
 * 
l_val_
[
pn
];

108 for (; 
pn
 < 
l_colptr_
[
u_rowind_
[
j
]+1]; pn++) {

109 while (
l_rowind_
[
rn
] < l_rowind_[
pn
] && rn < 
l_colptr_
[
i
+2])

110 
rn
++;

111 if (
l_rowind_
[
pn
] == l_rowind_[
rn
])

112 
l_val_
[
rn
] -= 
multiplier
 * l_val_[
pn
];

116 
	}
}

119 
	gCompRow_ILUPreconditioner
::

120 
	$CompRow_ILUPreconditioner
(const 
CompRow_MatDouble
 &
A
)

121 : 
	`l_rowptr_
(
A
.
	`dim
(1) + 1), 
	`u_rowptr_
(A.dim(1) + 1),

122 
	`l_colind_
(0), 
	`u_colind_
(0),

123 
	`l_val_
(0), 
	$u_val_
(0)

125 int 
i
, 
j
, 
k
, 
pn
, 
qn
, 
rn
;

126 double 
multiplier
;

129 
dim_
[0] = 
A
.
	`dim
(0);

130 
dim_
[1] = 
A
.
	`dim
(1);

132 
l_nz_
 = 
u_nz_
 = 0;

135 for (
i
 = 0; i < 
dim_
[1]; i++)

136 for (
j
 = 
A
.
	`row_ptr
(
i
); j < A.row_ptr(i+1); j++)

137 if (
A
.
	`col_ind
(
j
) < 
i
)

138 
l_nz_
++;

140 
u_nz_
++;

142 
l_val_
.
	`newsize
(
l_nz_
);

143 
u_val_
.
	`newsize
(
u_nz_
);

144 
l_colind_
.
	`newsize
(
l_nz_
);

145 
u_colind_
.
	`newsize
(
u_nz_
);

147 
	`l_rowptr_
(0) = 
	`u_rowptr_
(0) = 0;

150 for (
i
 = 0; i < 
dim_
[1]; i++) {

151 
	`l_rowptr_
(
i
+1) = l_rowptr_(i);

152 
	`u_rowptr_
(
i
+1) = u_rowptr_(i);

154 for (
j
 = 
A
.
	`row_ptr
(
i
); j < A.row_ptr(i+1); j++)

155 if (
A
.
	`col_ind
(
j
) < 
i
) {

156 
k
 = 
	`l_rowptr_
(
i
+1)++;

157 
	`l_val_
(
k
) = 
A
.
	`val
(
j
);

158 
	`l_colind_
(
k
) = 
A
.
	`col_ind
(
j
);

159 } else if (
A
.
	`col_ind
(
j
) >= 
i
) {

160 
k
 = 
	`u_rowptr_
(
i
+1)++;

161 
	`u_val_
(
k
) = 
A
.
	`val
(
j
);

162 
	`u_colind_
(
k
) = 
A
.
	`col_ind
(
j
);

166 for (
i
 = 0; i < 
dim_
[1]; i++) {

167 
	`QSort
(
l_colind_
, 
l_val_
, 
l_rowptr_
[
i
], l_rowptr_[i+1] - l_rowptr_[i]);

168 
	`QSort
(
u_colind_
, 
u_val_
, 
u_rowptr_
[
i
], u_rowptr_[i+1] - u_rowptr_[i]);

172 for (
i
 = 1; i < 
dim_
[0]; i++) {

173 for (
j
 = 
l_rowptr_
[
i
]; j < l_rowptr_[i+1]; j++) {

174 
pn
 = 
u_rowptr_
[
l_colind_
[
j
]];

175 
multiplier
 = (
l_val_
[
j
] /= 
u_val_
[
pn
]);

177 
qn
 = 
j
 + 1;

178 
rn
 = 
u_rowptr_
[
i
];

180 for (
pn
++; 
u_colind_
[pn] < 
i
 && pn < 
u_rowptr_
[
l_colind_
[
j
]+1]; pn++) {

181 while (
l_colind_
[
qn
] < 
u_colind_
[
pn
] && qn < 
l_rowptr_
[
i
+1])

182 
qn
++;

183 if (
u_colind_
[
pn
] == 
l_colind_
[
qn
])

184 
l_val_
[
qn
] -= 
multiplier
 * 
u_val_
[
pn
];

186 for (; 
pn
 < 
u_rowptr_
[
l_colind_
[
j
]+1]; pn++) {

187 while (
u_colind_
[
rn
] < u_colind_[
pn
] && rn < 
u_rowptr_
[
i
+1])

188 
rn
++;

189 if (
u_colind_
[
pn
] == u_colind_[
rn
])

190 
u_val_
[
rn
] -= 
multiplier
 * u_val_[
pn
];

194 
	}
}

197 
	gMV_Vector
<double>

198 
	gCompCol_ILUPreconditioner
::
solve
(const 
MV_Vector
<double> &
x
) const

200 int 
M
 = 
x
.
size
();

201 
	gMV_Vector
<double> 
y
(
M
);

202 
	gMV_Vector
<double> 
work
(
M
);

204 int 
	gdescra
[9];

206 
	gdescra
[0] = 0;

209 
	gdescra
[1] = 1;

210 
	gdescra
[2] = 1;

212 
F77NAME
(
dcscsm
) (0, 
	gM
, 1, 1, 
	gNULL
, 1.0,

213 
	gdescra
, &
l_val_
(0), &
l_rowind_
(0), &
l_colptr_
(0),

214 &
x
(0), 
	gM
, 0.0, &
y
(1), M,

215 &
work
(0), 
	gM
);

218 
	gdescra
[1] = 2;

219 
	gdescra
[2] = 0;

221 
F77NAME
(
dcscsm
) (0, 
	gM
, 1, 1, 
	gNULL
, 1.0,

222 
	gdescra
, &
u_val_
(0), &
u_rowind_
(0), &
u_colptr_
(0),

223 &
y
(0), 
	gM
, 0.0, &y(1), M,

224 &
work
(0), 
	gM
);

226 return 
	gy
;

230 
	gMV_Vector
<double>

231 
	gCompCol_ILUPreconditioner
::
trans_solve
(const 
MV_Vector
<double> &
x
) const

233 int 
M
 = 
x
.
size
();

234 
	gMV_Vector
<double> 
y
(
M
);

235 
	gMV_Vector
<double> 
work
(
M
);

237 int 
	gdescra
[9];

239 
	gdescra
[0] = 0;

242 
	gdescra
[1] = 2;

243 
	gdescra
[2] = 0;

245 
F77NAME
(
dcscsm
) (1, 
	gM
, 1, 1, 
	gNULL
, 1.0,

246 
	gdescra
, &
u_val_
(0), &
u_rowind_
(0), &
u_colptr_
(0),

247 &
x
(0), 
	gM
, 0.0, &
y
(1), M,

248 &
work
(0), 
	gM
);

251 
	gdescra
[1] = 1;

252 
	gdescra
[2] = 1;

254 
F77NAME
(
dcscsm
) (1, 
	gM
, 1, 1, 
	gNULL
, 1.0,

255 
	gdescra
, &
l_val_
(0), &
l_rowind_
(0), &
l_colptr_
(0),

256 &
y
(0), 
	gM
, 0.0, &y(1), M,

257 &
work
(0), 
	gM
);

259 return 
	gy
;

263 
	gMV_Vector
<double>

264 
	gCompRow_ILUPreconditioner
::
solve
(const 
MV_Vector
<double> &
x
) const

266 int 
M
 = 
x
.
size
();

267 
	gMV_Vector
<double> 
y
(
M
);

268 
	gMV_Vector
<double> 
work
(
M
);

270 int 
	gdescra
[9];

272 
	gdescra
[0] = 0;

275 
	gdescra
[1] = 1;

276 
	gdescra
[2] = 1;

278 
F77NAME
(
dcsrsm
) (0, 
	gM
, 1, 1, 
	gNULL
, 1.0,

279 
	gdescra
, &
l_val_
(0), &
l_colind_
(0), &
l_rowptr_
(0),

280 &
x
(0), 
	gM
, 0.0, &
y
(1), M,

281 &
work
(0), 
	gM
);

284 
	gdescra
[1] = 2;

285 
	gdescra
[2] = 0;

287 
F77NAME
(
dcsrsm
) (0, 
	gM
, 1, 1, 
	gNULL
, 1.0,

288 
	gdescra
, &
u_val_
(0), &
u_colind_
(0), &
u_rowptr_
(0),

289 &
y
(0), 
	gM
, 0.0, &y(1), M,

290 &
work
(0), 
	gM
);

292 return 
	gy
;

296 
	gMV_Vector
<double>

297 
	gCompRow_ILUPreconditioner
::
trans_solve
(const 
MV_Vector
<double> &
x
) const

299 int 
M
 = 
x
.
size
();

300 
	gMV_Vector
<double> 
y
(
M
);

301 
	gMV_Vector
<double> 
work
(
M
);

303 int 
	gdescra
[9];

305 
	gdescra
[0] = 0;

308 
	gdescra
[1] = 2;

309 
	gdescra
[2] = 0;

311 
F77NAME
(
dcsrsm
) (1, 
	gM
, 1, 1, 
	gNULL
, 1.0,

312 
	gdescra
, &
u_val_
(0), &
u_colind_
(0), &
u_rowptr_
(0),

313 &
x
(0), 
	gM
, 0.0, &
y
(1), M,

314 &
work
(0), 
	gM
);

317 
	gdescra
[1] = 1;

318 
	gdescra
[2] = 1;

320 
F77NAME
(
dcsrsm
) (1, 
	gM
, 1, 1, 
	gNULL
, 1.0,

321 
	gdescra
, &
l_val_
(0), &
l_colind_
(0), &
l_rowptr_
(0),

322 &
y
(0), 
	gM
, 0.0, &y(1), M,

323 &
work
(0), 
	gM
);

325 return 
	gy
;

	@src/ilupre_double.cc

31 #include 
	~<stdlib.h
>

32 #include 
	~"ilupre_double.h
"

33 #include 
	~"qsort_double.h
"

35 #include 
	~"spblas.h
"

37 
	gCompCol_ILUPreconditioner_double
::

38 
	$CompCol_ILUPreconditioner_double
(const 
CompCol_Mat_double
 &
A
)

40 
	`l_val_
(0), 
	`l_colptr_
(
A
.
	`dim
(1) + 1), 
	`l_rowind_
(0), 
	`l_nz_
(0), 
	`u_val_
(0),

41 
	`u_colptr_
(
A
.
	`dim
(1) + 1), 
	`u_rowind_
(0), 
	$u_nz_
(0)

43 int 
i
, 
j
, 
k
, 
pn
, 
qn
, 
rn
;

44 double 
multiplier
;

47 
dim_
[0] = 
A
.
	`dim
(0);

48 
dim_
[1] = 
A
.
	`dim
(1);

52 for (
i
 = 0; i < 
dim_
[1]; i++)

53 for (
j
 = 
A
.
	`col_ptr
(
i
); j < A.col_ptr(i+1); j++)

54 if (
A
.
	`row_ind
(
j
) > 
i
)

55 
l_nz_
++;

57 
u_nz_
++;

59 
l_val_
.
	`newsize
(
l_nz_
);

60 
u_val_
.
	`newsize
(
u_nz_
);

61 
l_rowind_
.
	`newsize
(
l_nz_
);

62 
u_rowind_
.
	`newsize
(
u_nz_
);

64 
	`l_colptr_
(0) = 
	`u_colptr_
(0) = 0;

67 for (
i
 = 0; i < 
dim_
[1]; i++) {

68 
	`l_colptr_
(
i
+1) = l_colptr_(i);

69 
	`u_colptr_
(
i
+1) = u_colptr_(i);

71 for (
j
 = 
A
.
	`col_ptr
(
i
); j < A.col_ptr(i+1); j++)

72 if (
A
.
	`row_ind
(
j
) > 
i
) {

73 
k
 = 
	`l_colptr_
(
i
+1)++;

74 
	`l_val_
(
k
) = 
A
.
	`val
(
j
);

75 
	`l_rowind_
(
k
) = 
A
.
	`row_ind
(
j
);

76 } else if (
A
.
	`row_ind
(
j
) <= 
i
) {

77 
k
 = 
	`u_colptr_
(
i
+1)++;

78 
	`u_val_
(
k
) = 
A
.
	`val
(
j
);

79 
	`u_rowind_
(
k
) = 
A
.
	`row_ind
(
j
);

83 for (
i
 = 0; i < 
dim_
[1]; i++) {

84 
	`QSort
(
l_rowind_
, 
l_val_
, 
l_colptr_
[
i
], l_colptr_[i+1] - l_colptr_[i]);

85 
	`QSort
(
u_rowind_
, 
u_val_
, 
u_colptr_
[
i
], u_colptr_[i+1] - u_colptr_[i]);

89 for (
i
 = 0; i < 
dim_
[0] - 1; i++) {

90 
multiplier
 = 
	`u_val_
(
	`u_colptr_
(
i
+1)-1);

92 for (
j
 = 
l_colptr_
[
i
]; j < l_colptr_[i+1]; j++)

93 
l_val_
[
j
] /= 
multiplier
;

95 for (
j
 = 
u_colptr_
[
i
+1]; j < u_colptr_[i+2]-1; j++) {

96 
multiplier
 = 
u_val_
[
j
];

97 
qn
 = 
j
 + 1;

98 
rn
 = 
l_colptr_
[
i
+1];

99 for (
pn
 = 
l_colptr_
[
u_rowind_
[
j
]];

100 
pn
 < 
l_colptr_
[
u_rowind_
[
j
]+1] && 
l_rowind_
[pn] <= 
i
 + 1;

101 
pn
++) {

102 while (
qn
 < 
u_colptr_
[
i
+2] && 
u_rowind_
[qn] < 
l_rowind_
[
pn
])

103 
qn
++;

104 if (
qn
 < 
u_colptr_
[
i
+2] && 
l_rowind_
[
pn
] == 
u_rowind_
[qn])

105 
u_val_
[
qn
] -= 
multiplier
 * 
l_val_
[
pn
];

107 for ( ; 
pn
 < 
l_colptr_
[
u_rowind_
[
j
]+1]; pn++) {

108 while (
rn
 < 
l_colptr_
[
i
+2] && 
l_rowind_
[rn] < l_rowind_[
pn
])

109 
rn
++;

110 if (
rn
 < 
l_colptr_
[
i
+2] && 
l_rowind_
[
pn
] == l_rowind_[rn])

111 
l_val_
[
rn
] -= 
multiplier
 * l_val_[
pn
];

115 
	}
}

118 
	gCompRow_ILUPreconditioner_double
::

119 
	$CompRow_ILUPreconditioner_double
(const 
CompRow_Mat_double
 &
A
)

120 : 
	`l_val_
(0), 
	`l_rowptr_
(
A
.
	`dim
(1) + 1), 
	`l_colind_
(0), 
	`l_nz_
(0),

121 
	`u_val_
(0), 
	`u_rowptr_
(
A
.
	`dim
(1) + 1), 
	`u_colind_
(0), 
	$u_nz_
(0)

123 int 
i
, 
j
, 
k
, 
pn
, 
qn
, 
rn
;

124 double 
multiplier
;

127 
dim_
[0] = 
A
.
	`dim
(0);

128 
dim_
[1] = 
A
.
	`dim
(1);

132 for (
i
 = 0; i < 
dim_
[1]; i++)

133 for (
j
 = 
A
.
	`row_ptr
(
i
); j < A.row_ptr(i+1); j++)

134 if (
A
.
	`col_ind
(
j
) < 
i
)

135 
l_nz_
++;

137 
u_nz_
++;

139 
l_val_
.
	`newsize
(
l_nz_
);

140 
u_val_
.
	`newsize
(
u_nz_
);

141 
l_colind_
.
	`newsize
(
l_nz_
);

142 
u_colind_
.
	`newsize
(
u_nz_
);

144 
	`l_rowptr_
(0) = 
	`u_rowptr_
(0) = 0;

147 for (
i
 = 0; i < 
dim_
[1]; i++) {

148 
	`l_rowptr_
(
i
+1) = l_rowptr_(i);

149 
	`u_rowptr_
(
i
+1) = u_rowptr_(i);

151 for (
j
 = 
A
.
	`row_ptr
(
i
); j < A.row_ptr(i+1); j++)

152 if (
A
.
	`col_ind
(
j
) < 
i
) {

153 
k
 = 
	`l_rowptr_
(
i
+1)++;

154 
	`l_val_
(
k
) = 
A
.
	`val
(
j
);

155 
	`l_colind_
(
k
) = 
A
.
	`col_ind
(
j
);

156 } else if (
A
.
	`col_ind
(
j
) >= 
i
) {

157 
k
 = 
	`u_rowptr_
(
i
+1)++;

158 
	`u_val_
(
k
) = 
A
.
	`val
(
j
);

159 
	`u_colind_
(
k
) = 
A
.
	`col_ind
(
j
);

163 for (
i
 = 0; i < 
dim_
[1]; i++) {

164 
	`QSort
(
l_colind_
, 
l_val_
, 
l_rowptr_
[
i
], l_rowptr_[i+1] - l_rowptr_[i]);

165 
	`QSort
(
u_colind_
, 
u_val_
, 
u_rowptr_
[
i
], u_rowptr_[i+1] - u_rowptr_[i]);

169 for (
i
 = 1; i < 
dim_
[0]; i++) {

170 for (
j
 = 
l_rowptr_
[
i
]; j < l_rowptr_[i+1]; j++) {

171 
pn
 = 
u_rowptr_
[
l_colind_
[
j
]];

172 
multiplier
 = (
l_val_
[
j
] /= 
u_val_
[
pn
]);

174 
qn
 = 
j
 + 1;

175 
rn
 = 
u_rowptr_
[
i
];

177 for (
pn
++; pn < 
u_rowptr_
[
l_colind_
[
j
]+1] && 
u_colind_
[pn] < 
i
; pn++) {

178 while (
qn
 < 
l_rowptr_
[
i
+1] && 
l_colind_
[qn] < 
u_colind_
[
pn
])

179 
qn
++;

180 if (
qn
 < 
l_rowptr_
[
i
+1] && 
u_colind_
[
pn
] == 
l_colind_
[qn])

181 
l_val_
[
qn
] -= 
multiplier
 * 
u_val_
[
pn
];

183 for ( ; 
pn
 < 
u_rowptr_
[
l_colind_
[
j
]+1]; pn++) {

184 while (
rn
 < 
u_rowptr_
[
i
+1] && 
u_colind_
[rn] < u_colind_[
pn
])

185 
rn
++;

186 if (
rn
 < 
u_rowptr_
[
i
+1] && 
u_colind_
[
pn
] == u_colind_[rn])

187 
u_val_
[
rn
] -= 
multiplier
 * u_val_[
pn
];

191 
	}
}

194 
VECTOR_double


195 
	gCompCol_ILUPreconditioner_double
::
	$solve
(const 
VECTOR_double
 &
x
) const

197 int 
M
 = 
x
.
	`size
();

198 
VECTOR_double
 
	`y
(
M
);

199 
VECTOR_double
 
	`work
(
M
);

201 int 
descra
[9];

203 
descra
[0] = 0;

206 
descra
[1] = 1;

207 
descra
[2] = 1;

209 
	`F77NAME
(
dcscsm
) (0, 
M
, 1, 1, 
NULL
, 1.0,

210 
descra
, &
	`l_val_
(0), &
	`l_rowind_
(0), &
	`l_colptr_
(0),

211 &
	`x
(0), 
M
, 0.0, &
	`y
(1), M,

212 &
	`work
(0), 
M
);

215 
descra
[1] = 2;

216 
descra
[2] = 0;

218 
	`F77NAME
(
dcscsm
) (0, 
M
, 1, 1, 
NULL
, 1.0,

219 
descra
, &
	`u_val_
(0), &
	`u_rowind_
(0), &
	`u_colptr_
(0),

220 &
	`y
(0), 
M
, 0.0, &y(1), M,

221 &
	`work
(0), 
M
);

223 return 
y
;

224 
	}
}

227 
VECTOR_double


228 
	gCompCol_ILUPreconditioner_double
::
	$trans_solve
(const 
VECTOR_double
 &
x
) const

230 int 
M
 = 
x
.
	`size
();

231 
VECTOR_double
 
	`y
(
M
);

232 
VECTOR_double
 
	`work
(
M
);

234 int 
descra
[9];

236 
descra
[0] = 0;

239 
descra
[1] = 2;

240 
descra
[2] = 0;

242 
	`F77NAME
(
dcscsm
) (1, 
M
, 1, 1, 
NULL
, 1.0,

243 
descra
, &
	`u_val_
(0), &
	`u_rowind_
(0), &
	`u_colptr_
(0),

244 &
	`x
(0), 
M
, 0.0, &
	`y
(1), M,

245 &
	`work
(0), 
M
);

248 
descra
[1] = 1;

249 
descra
[2] = 1;

251 
	`F77NAME
(
dcscsm
) (1, 
M
, 1, 1, 
NULL
, 1.0,

252 
descra
, &
	`l_val_
(0), &
	`l_rowind_
(0), &
	`l_colptr_
(0),

253 &
	`y
(0), 
M
, 0.0, &y(1), M,

254 &
	`work
(0), 
M
);

256 return 
y
;

257 
	}
}

260 
VECTOR_double


261 
	gCompRow_ILUPreconditioner_double
::
	$solve
(const 
VECTOR_double
 &
x
) const

263 int 
M
 = 
x
.
	`size
();

264 
VECTOR_double
 
	`y
(
M
);

265 
VECTOR_double
 
	`work
(
M
);

267 int 
descra
[9];

269 
descra
[0] = 0;

272 
descra
[1] = 1;

273 
descra
[2] = 1;

275 
	`F77NAME
(
dcsrsm
) (0, 
M
, 1, 1, 
NULL
, 1.0,

276 
descra
, &
	`l_val_
(0), &
	`l_colind_
(0), &
	`l_rowptr_
(0),

277 &
	`x
(0), 
M
, 0.0, &
	`y
(1), M,

278 &
	`work
(0), 
M
);

281 
descra
[1] = 2;

282 
descra
[2] = 0;

284 
	`F77NAME
(
dcsrsm
) (0, 
M
, 1, 1, 
NULL
, 1.0,

285 
descra
, &
	`u_val_
(0), &
	`u_colind_
(0), &
	`u_rowptr_
(0),

286 &
	`y
(0), 
M
, 0.0, &y(1), M,

287 &
	`work
(0), 
M
);

289 return 
y
;

290 
	}
}

293 
VECTOR_double


294 
	gCompRow_ILUPreconditioner_double
::
	$trans_solve
(const 
VECTOR_double
 &
x
) const

296 int 
M
 = 
x
.
	`size
();

297 
VECTOR_double
 
	`y
(
M
);

298 
VECTOR_double
 
	`work
(
M
);

300 int 
descra
[9];

302 
descra
[0] = 0;

305 
descra
[1] = 2;

306 
descra
[2] = 0;

308 
	`F77NAME
(
dcsrsm
) (1, 
M
, 1, 1, 
NULL
, 1.0,

309 
descra
, &
	`u_val_
(0), &
	`u_colind_
(0), &
	`u_rowptr_
(0),

310 &
	`x
(0), 
M
, 0.0, &
	`y
(1), M,

311 &
	`work
(0), 
M
);

314 
descra
[1] = 1;

315 
descra
[2] = 1;

317 
	`F77NAME
(
dcsrsm
) (1, 
M
, 1, 1, 
NULL
, 1.0,

318 
descra
, &
	`l_val_
(0), &
	`l_colind_
(0), &
	`l_rowptr_
(0),

319 &
	`y
(0), 
M
, 0.0, &y(1), M,

320 &
	`work
(0), 
M
);

322 return 
y
;

323 
	}
}

	@src/ilupre_double_1.5.cc

31 #include 
	~<stdlib.h
>

32 #include 
	~"ilupre_double.h
"

33 #include 
	~"qsort_double.h
"

35 #include 
	~"spblas.h
"

37 
	gCompCol_ILUPreconditioner_double
::

38 
	$CompCol_ILUPreconditioner_double
(const 
CompCol_Mat_double
 &
A
)

40 
	`l_val_
(0), 
	`l_colptr_
(
A
.
	`dim
(1) + 1), 
	`l_rowind_
(0), 
	`l_nz_
(0), 
	`u_val_
(0),

41 
	`u_colptr_
(
A
.
	`dim
(1) + 1), 
	`u_rowind_
(0), 
	$u_nz_
(0)

43 int 
i
, 
j
, 
k
, 
pn
, 
qn
, 
rn
;

44 double 
multiplier
;

47 
dim_
[0] = 
A
.
	`dim
(0);

48 
dim_
[1] = 
A
.
	`dim
(1);

52 for (
i
 = 0; i < 
dim_
[1]; i++)

53 for (
j
 = 
A
.
	`col_ptr
(
i
); j < A.col_ptr(i+1); j++)

54 if (
A
.
	`row_ind
(
j
) > 
i
)

55 
l_nz_
++;

57 
u_nz_
++;

59 
l_val_
.
	`newsize
(
l_nz_
);

60 
u_val_
.
	`newsize
(
u_nz_
);

61 
l_rowind_
.
	`newsize
(
l_nz_
);

62 
u_rowind_
.
	`newsize
(
u_nz_
);

64 
	`l_colptr_
(0) = 
	`u_colptr_
(0) = 0;

67 for (
i
 = 0; i < 
dim_
[1]; i++) {

68 
	`l_colptr_
(
i
+1) = l_colptr_(i);

69 
	`u_colptr_
(
i
+1) = u_colptr_(i);

71 for (
j
 = 
A
.
	`col_ptr
(
i
); j < A.col_ptr(i+1); j++)

72 if (
A
.
	`row_ind
(
j
) > 
i
) {

73 
k
 = 
	`l_colptr_
(
i
+1)++;

74 
	`l_val_
(
k
) = 
A
.
	`val
(
j
);

75 
	`l_rowind_
(
k
) = 
A
.
	`row_ind
(
j
);

76 } else if (
A
.
	`row_ind
(
j
) <= 
i
) {

77 
k
 = 
	`u_colptr_
(
i
+1)++;

78 
	`u_val_
(
k
) = 
A
.
	`val
(
j
);

79 
	`u_rowind_
(
k
) = 
A
.
	`row_ind
(
j
);

83 for (
i
 = 0; i < 
dim_
[1]; i++) {

84 
	`QSort
(
l_rowind_
, 
l_val_
, 
l_colptr_
[
i
], l_colptr_[i+1] - l_colptr_[i]);

85 
	`QSort
(
u_rowind_
, 
u_val_
, 
u_colptr_
[
i
], u_colptr_[i+1] - u_colptr_[i]);

89 for (
i
 = 0; i < 
dim_
[0] - 1; i++) {

90 
multiplier
 = 
	`u_val_
(
	`u_colptr_
(
i
+1)-1);

92 for (
j
 = 
l_colptr_
[
i
]; j < l_colptr_[i+1]; j++)

93 
l_val_
[
j
] /= 
multiplier
;

95 for (
j
 = 
u_colptr_
[
i
+1]; j < u_colptr_[i+2]-1; j++) {

96 
multiplier
 = 
u_val_
[
j
];

97 
qn
 = 
j
 + 1;

98 
rn
 = 
l_colptr_
[
i
+1];

99 for (
pn
 = 
l_colptr_
[
u_rowind_
[
j
]];

100 
pn
 < 
l_colptr_
[
u_rowind_
[
j
]+1] && 
l_rowind_
[pn] <= 
i
 + 1;

101 
pn
++) {

102 while (
qn
 < 
u_colptr_
[
i
+2] && 
u_rowind_
[qn] < 
l_rowind_
[
pn
])

103 
qn
++;

104 if (
l_rowind_
[
pn
] == 
u_rowind_
[
qn
])

105 
u_val_
[
qn
] -= 
multiplier
 * 
l_val_
[
pn
];

107 for ( ; 
pn
 < 
l_colptr_
[
u_rowind_
[
j
]+1]; pn++) {

108 while (
rn
 < 
l_colptr_
[
i
+2] && 
l_rowind_
[rn] < l_rowind_[
pn
])

109 
rn
++;

110 if (
l_rowind_
[
pn
] == l_rowind_[
rn
])

111 
l_val_
[
rn
] -= 
multiplier
 * l_val_[
pn
];

115 
	}
}

118 
	gCompRow_ILUPreconditioner_double
::

119 
	$CompRow_ILUPreconditioner_double
(const 
CompRow_Mat_double
 &
A
)

120 : 
	`l_val_
(0), 
	`l_rowptr_
(
A
.
	`dim
(1) + 1), 
	`l_colind_
(0), 
	`l_nz_
(0),

121 
	`u_val_
(0), 
	`u_rowptr_
(
A
.
	`dim
(1) + 1), 
	`u_colind_
(0), 
	$u_nz_
(0)

123 int 
i
, 
j
, 
k
, 
pn
, 
qn
, 
rn
;

124 double 
multiplier
;

127 
dim_
[0] = 
A
.
	`dim
(0);

128 
dim_
[1] = 
A
.
	`dim
(1);

132 for (
i
 = 0; i < 
dim_
[1]; i++)

133 for (
j
 = 
A
.
	`row_ptr
(
i
); j < A.row_ptr(i+1); j++)

134 if (
A
.
	`col_ind
(
j
) < 
i
)

135 
l_nz_
++;

137 
u_nz_
++;

139 
l_val_
.
	`newsize
(
l_nz_
);

140 
u_val_
.
	`newsize
(
u_nz_
);

141 
l_colind_
.
	`newsize
(
l_nz_
);

142 
u_colind_
.
	`newsize
(
u_nz_
);

144 
	`l_rowptr_
(0) = 
	`u_rowptr_
(0) = 0;

147 for (
i
 = 0; i < 
dim_
[1]; i++) {

148 
	`l_rowptr_
(
i
+1) = l_rowptr_(i);

149 
	`u_rowptr_
(
i
+1) = u_rowptr_(i);

151 for (
j
 = 
A
.
	`row_ptr
(
i
); j < A.row_ptr(i+1); j++)

152 if (
A
.
	`col_ind
(
j
) < 
i
) {

153 
k
 = 
	`l_rowptr_
(
i
+1)++;

154 
	`l_val_
(
k
) = 
A
.
	`val
(
j
);

155 
	`l_colind_
(
k
) = 
A
.
	`col_ind
(
j
);

156 } else if (
A
.
	`col_ind
(
j
) >= 
i
) {

157 
k
 = 
	`u_rowptr_
(
i
+1)++;

158 
	`u_val_
(
k
) = 
A
.
	`val
(
j
);

159 
	`u_colind_
(
k
) = 
A
.
	`col_ind
(
j
);

163 for (
i
 = 0; i < 
dim_
[1]; i++) {

164 
	`QSort
(
l_colind_
, 
l_val_
, 
l_rowptr_
[
i
], l_rowptr_[i+1] - l_rowptr_[i]);

165 
	`QSort
(
u_colind_
, 
u_val_
, 
u_rowptr_
[
i
], u_rowptr_[i+1] - u_rowptr_[i]);

169 for (
i
 = 1; i < 
dim_
[0]; i++) {

170 for (
j
 = 
l_rowptr_
[
i
]; j < l_rowptr_[i+1]; j++) {

171 
pn
 = 
u_rowptr_
[
l_colind_
[
j
]];

172 
multiplier
 = (
l_val_
[
j
] /= 
u_val_
[
pn
]);

174 
qn
 = 
j
 + 1;

175 
rn
 = 
u_rowptr_
[
i
];

177 for (
pn
++; pn < 
u_rowptr_
[
l_colind_
[
j
]+1] && 
u_colind_
[pn] < 
i
; pn++) {

178 while (
qn
 < 
l_rowptr_
[
i
+1] && 
l_colind_
[qn] < 
u_colind_
[
pn
])

179 
qn
++;

180 if (
u_colind_
[
pn
] == 
l_colind_
[
qn
])

181 
l_val_
[
qn
] -= 
multiplier
 * 
u_val_
[
pn
];

183 for ( ; 
pn
 < 
u_rowptr_
[
l_colind_
[
j
]+1]; pn++) {

184 while (
rn
 < 
u_rowptr_
[
i
+1] && 
u_colind_
[rn] < u_colind_[
pn
])

185 
rn
++;

186 if (
u_colind_
[
pn
] == u_colind_[
rn
])

187 
u_val_
[
rn
] -= 
multiplier
 * u_val_[
pn
];

191 
	}
}

194 
VECTOR_double


195 
	gCompCol_ILUPreconditioner_double
::
	$solve
(const 
VECTOR_double
 &
x
) const

197 int 
M
 = 
x
.
	`size
();

198 
VECTOR_double
 
	`y
(
M
);

199 
VECTOR_double
 
	`work
(
M
);

201 int 
descra
[9];

203 
descra
[0] = 0;

206 
descra
[1] = 1;

207 
descra
[2] = 1;

209 
	`F77NAME
(
dcscsm
) (0, 
M
, 1, 1, 
NULL
, 1.0,

210 
descra
, &
	`l_val_
(0), &
	`l_rowind_
(0), &
	`l_colptr_
(0),

211 &
	`x
(0), 
M
, 0.0, &
	`y
(1), M,

212 &
	`work
(0), 
M
);

215 
descra
[1] = 2;

216 
descra
[2] = 0;

218 
	`F77NAME
(
dcscsm
) (0, 
M
, 1, 1, 
NULL
, 1.0,

219 
descra
, &
	`u_val_
(0), &
	`u_rowind_
(0), &
	`u_colptr_
(0),

220 &
	`y
(0), 
M
, 0.0, &y(1), M,

221 &
	`work
(0), 
M
);

223 return 
y
;

224 
	}
}

227 
VECTOR_double


228 
	gCompCol_ILUPreconditioner_double
::
	$trans_solve
(const 
VECTOR_double
 &
x
) const

230 int 
M
 = 
x
.
	`size
();

231 
VECTOR_double
 
	`y
(
M
);

232 
VECTOR_double
 
	`work
(
M
);

234 int 
descra
[9];

236 
descra
[0] = 0;

239 
descra
[1] = 2;

240 
descra
[2] = 0;

242 
	`F77NAME
(
dcscsm
) (1, 
M
, 1, 1, 
NULL
, 1.0,

243 
descra
, &
	`u_val_
(0), &
	`u_rowind_
(0), &
	`u_colptr_
(0),

244 &
	`x
(0), 
M
, 0.0, &
	`y
(1), M,

245 &
	`work
(0), 
M
);

248 
descra
[1] = 1;

249 
descra
[2] = 1;

251 
	`F77NAME
(
dcscsm
) (1, 
M
, 1, 1, 
NULL
, 1.0,

252 
descra
, &
	`l_val_
(0), &
	`l_rowind_
(0), &
	`l_colptr_
(0),

253 &
	`y
(0), 
M
, 0.0, &y(1), M,

254 &
	`work
(0), 
M
);

256 return 
y
;

257 
	}
}

260 
VECTOR_double


261 
	gCompRow_ILUPreconditioner_double
::
	$solve
(const 
VECTOR_double
 &
x
) const

263 int 
M
 = 
x
.
	`size
();

264 
VECTOR_double
 
	`y
(
M
);

265 
VECTOR_double
 
	`work
(
M
);

267 int 
descra
[9];

269 
descra
[0] = 0;

272 
descra
[1] = 1;

273 
descra
[2] = 1;

275 
	`F77NAME
(
dcsrsm
) (0, 
M
, 1, 1, 
NULL
, 1.0,

276 
descra
, &
	`l_val_
(0), &
	`l_colind_
(0), &
	`l_rowptr_
(0),

277 &
	`x
(0), 
M
, 0.0, &
	`y
(1), M,

278 &
	`work
(0), 
M
);

281 
descra
[1] = 2;

282 
descra
[2] = 0;

284 
	`F77NAME
(
dcsrsm
) (0, 
M
, 1, 1, 
NULL
, 1.0,

285 
descra
, &
	`u_val_
(0), &
	`u_colind_
(0), &
	`u_rowptr_
(0),

286 &
	`y
(0), 
M
, 0.0, &y(1), M,

287 &
	`work
(0), 
M
);

289 return 
y
;

290 
	}
}

293 
VECTOR_double


294 
	gCompRow_ILUPreconditioner_double
::
	$trans_solve
(const 
VECTOR_double
 &
x
) const

296 int 
M
 = 
x
.
	`size
();

297 
VECTOR_double
 
	`y
(
M
);

298 
VECTOR_double
 
	`work
(
M
);

300 int 
descra
[9];

302 
descra
[0] = 0;

305 
descra
[1] = 2;

306 
descra
[2] = 0;

308 
	`F77NAME
(
dcsrsm
) (1, 
M
, 1, 1, 
NULL
, 1.0,

309 
descra
, &
	`u_val_
(0), &
	`u_colind_
(0), &
	`u_rowptr_
(0),

310 &
	`x
(0), 
M
, 0.0, &
	`y
(1), M,

311 &
	`work
(0), 
M
);

314 
descra
[1] = 1;

315 
descra
[2] = 1;

317 
	`F77NAME
(
dcsrsm
) (1, 
M
, 1, 1, 
NULL
, 1.0,

318 
descra
, &
	`l_val_
(0), &
	`l_colind_
(0), &
	`l_rowptr_
(0),

319 &
	`y
(0), 
M
, 0.0, &y(1), M,

320 &
	`work
(0), 
M
);

322 return 
y
;

323 
	}
}

	@src/iohb.c

101 #include
	~<stdio.h
>

102 #include
	~<stdlib.h
>

103 #include
	~<string.h
>

105 void 
nullchk
();

106 void 
ParseIfmt
();

107 void 
ParseRfmt
();

108 void 
convertDtoE
();

109 void 
readHB_header
();

110 void 
readHB_mat_double
();

111 void 
readHB_rhs_double
();

112 void 
writeHB_mat_double
();

113 char * 
substr
();

114 char * 
substr_after
();

115 char * 
substr_before
();

116 char * 
substr_through
();

117 void 
upcase
();

118 int 
my_index
();

120 void 
	$readHB_info
(
filename
, 
M
, 
N
, 
nz
, 
nrhs
)

121 char *
filename
; int *
M
; int *
N
; int *
nz
; int *
nrhs
;

142 int 
verbose
 = 0;

143 
FILE
 *
in_file
;

144 char 
Title
[73], 
Key
[9], 
Type
[4], 
Rhstype
[4];

145 char 
Ptrfmt
[17], 
Indfmt
[17], 
Valfmt
[21], 
Rhsfmt
[21];

146 int 
Ptrcrd
, 
Indcrd
, 
Valcrd
, 
Rhscrd
;

147 int 
Nrow
, 
Ncol
, 
Nnzero
;

148 int 
Nrhs
;

150 
in_file
 = 
	`fopen
( 
filename
, "r");

151 if (
in_file
 == 
NULL
)

153 
	`printf
("Cannot open file: %s\n",
filename
);

154 
	`exit
(1);

157 
	`readHB_header
(
in_file
, 
Title
, 
Key
, 
Type
, &
Nrow
, &
Ncol
, &
Nnzero
, &
Nrhs
,

158 
Ptrfmt
, 
Indfmt
, 
Valfmt
, 
Rhsfmt
,

159 &
Ptrcrd
, &
Indcrd
, &
Valcrd
, &
Rhscrd
, 
Rhstype
);

161 *
M
 = 
Nrow
;

162 *
N
 = 
Ncol
;

163 *
nz
 = 
Nnzero
;

164 if (
Rhscrd
 != 0) {*
nrhs
 = 
Nrhs
;}

165 else {*
nrhs
 = 0;}

168 if (
verbose
 == 1)

170 
	`printf
("Reading from Harwell-Boeing file %s...\n",
filename
);

171 
	`printf
("Title: %s \n",
Title
);

172 
	`printf
("Key: %s \n",
Key
);

173 
	`printf
("The stored matrix is %i by %i with %i nonzeros.\n",

174 *
M
, *
N
, *
nz
 );

175 
	`printf
("%i right-hand--side(s) are stored.\n",*
nrhs
);

180 
	}
}

187 void 
	$readHB_header
(
in_file
, 
Title
, 
Key
, 
Type
,

188 
Nrow
, 
Ncol
, 
Nnzero
, 
Nrhs
,

189 
Ptrfmt
, 
Indfmt
, 
Valfmt
, 
Rhsfmt
,

190 
Ptrcrd
, 
Indcrd
, 
Valcrd
, 
Rhscrd
,

191 
Rhstype
)

192 
FILE
 *
in_file
; char *
Title
; char *
Key
; char *
Type
;

193 int *
Nrow
; int *
Ncol
; int *
Nnzero
; int *
Nrhs
;

194 char *
Ptrfmt
; char *
Indfmt
; char *
Valfmt
; char *
Rhsfmt
;

195 int *
Ptrcrd
; int *
Indcrd
; int *
Valcrd
; int *
Rhscrd
;

196 char *
Rhstype
;

198 char 
line
[82];

199 char *
line_ptr
;

200 int 
Totcrd
;

201 int 
Neltvl
, 
Nrhsix
;

204 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

205 
	`nullchk
(
line_ptr
);

206 (void) 
	`sscanf
(
line
, "%72c %8c", 
Title
, 
Key
);

209 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

210 
	`nullchk
(
line_ptr
);

211 (void) 
	`sscanf
(
line
, "%i %i %i %i %i", &
Totcrd
, 
Ptrcrd
, 
Indcrd
,

212 
Valcrd
, 
Rhscrd
);

215 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

216 
	`nullchk
(
line_ptr
);

217 (void) 
	`sscanf
(
line
, "%3c %i %i %i %i", 
Type
, 
Nrow
, 
Ncol
,

218 
Nnzero
, &
Neltvl
);

221 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

222 
	`nullchk
(
line_ptr
);

223 (void) 
	`sscanf
(
line
, "%s %s %s %s", 
Ptrfmt
, 
Indfmt
, 
Valfmt
, 
Rhsfmt
);

226 if (*
Rhscrd
 != 0 )

228 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

229 
	`nullchk
(
line_ptr
);

230 (void) 
	`sscanf
(
line
, "%3c %i %i", 
Rhstype
, 
Nrhs
, &
Nrhsix
);

234 
	}
}

238 void 
	$readHB_mat_double
(
filename
, 
colptr
, 
rowind
, 
val
)

239 char *
filename
; int 
colptr
[]; int 
rowind
[]; double 
val
[];

259 
FILE
 *
in_file
;

260 char 
Title
[73], 
Key
[9], 
Type
[4], 
Rhstype
[4];

261 char 
Ptrfmt
[17], 
Indfmt
[17], 
Valfmt
[21], 
Rhsfmt
[21];

262 int 
Ptrcrd
, 
Indcrd
, 
Valcrd
, 
Rhscrd
;

263 int 
Nrow
, 
Ncol
, 
Nnzero
;

264 int 
Nrhs
;

265 char 
line
[82];

266 char* 
line_ptr
;

267 int 
Ptrperline
, 
Ptrwidth
, 
Indperline
, 
Indwidth
;

268 int 
Valperline
, 
Valwidth
;

269 int 
Valflag
;

270 int 
i
, 
ind
, 
col
;

271 int 
count
;

272 char* 
ThisElement
;

274 
in_file
 = 
	`fopen
( 
filename
, "r");

275 if (
in_file
 == 
NULL
)

277 
	`printf
("Cannot open file: %s\n",
filename
);

278 
	`exit
(1);

281 
	`readHB_header
(
in_file
, 
Title
, 
Key
, 
Type
, &
Nrow
, &
Ncol
, &
Nnzero
, &
Nrhs
,

282 
Ptrfmt
, 
Indfmt
, 
Valfmt
, 
Rhsfmt
,

283 &
Ptrcrd
, &
Indcrd
, &
Valcrd
, &
Rhscrd
, 
Rhstype
);

286 
	`ParseIfmt
(
Ptrfmt
,&
Ptrperline
,&
Ptrwidth
);

287 
	`ParseIfmt
(
Indfmt
,&
Indperline
,&
Indwidth
);

288 
	`ParseRfmt
(
Valfmt
,&
Valperline
,&
Valwidth
,&
Valflag
);

292 
count
=0;

293 for (
i
=0;i<
Ptrcrd
;i++)

295 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

296 
	`nullchk
(
line_ptr
);

297 
col
 = 0;

298 for (
ind
 = 0;ind<
Ptrperline
;ind++)

300 if (
count
 > 
Ncol
) break;

301 
ThisElement
 = 
	`substr
(
line
,
col
,
Ptrwidth
);

302 
colptr
[
count
] = 
	`atoi
(
ThisElement
)-1;

303 
count
++; 
col
 += 
Ptrwidth
;

309 
count
 = 0;

310 for (
i
=0;i<
Indcrd
;i++)

312 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

313 
	`nullchk
(
line_ptr
);

314 
col
 = 0;

315 for (
ind
 = 0;ind<
Indperline
;ind++)

317 if (
count
 == 
Nnzero
) break;

318 
ThisElement
 = 
	`substr
(
line
,
col
,
Indwidth
);

319 
rowind
[
count
] = 
	`atoi
(
ThisElement
)-1;

320 
count
++; 
col
 += 
Indwidth
;

326 
count
 = 0;

327 for (
i
=0;i<
Valcrd
;i++)

329 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

330 
	`nullchk
(
line_ptr
);

331 if (
Valflag
 == 'D') 
	`convertDtoE
(
line
);

332 
col
 = 0;

333 for (
ind
 = 0;ind<
Valperline
;ind++)

335 if (
count
 == 
Nnzero
) break;

336 
ThisElement
 = 
	`substr
(
line
,
col
,
Valwidth
);

337 
val
[
count
] = 
	`atof
(
ThisElement
);

338 
count
++; 
col
 += 
Valwidth
;

343 
	}
}

346 void 
	$readHB_mat_float
(
filename
, 
colptr
, 
rowind
, 
val
)

347 char *
filename
; int *
colptr
; int *
rowind
; float *
val
;

367 
FILE
 *
in_file
;

368 char 
Title
[73], 
Key
[9], 
Type
[4], 
Rhstype
[4];

369 char 
Ptrfmt
[17], 
Indfmt
[17], 
Valfmt
[21], 
Rhsfmt
[21];

370 int 
Ptrcrd
, 
Indcrd
, 
Valcrd
, 
Rhscrd
;

371 int 
Nrow
, 
Ncol
, 
Nnzero
;

372 int 
Nrhs
;

373 char 
line
[82];

374 char* 
line_ptr
;

375 int 
Ptrperline
, 
Ptrwidth
, 
Indperline
, 
Indwidth
;

376 int 
Valperline
, 
Valwidth
;

377 int 
Valflag
;

378 int 
i
, 
ind
, 
col
;

379 int 
count
;

380 char* 
ThisElement
;

382 
in_file
 = 
	`fopen
( 
filename
, "r");

383 if (
in_file
 == 
NULL
)

385 
	`printf
("Cannot open file: %s\n",
filename
);

386 
	`exit
(1);

389 
	`readHB_header
(
in_file
, 
Title
, 
Key
, 
Type
, &
Nrow
, &
Ncol
, &
Nnzero
, &
Nrhs
,

390 
Ptrfmt
, 
Indfmt
, 
Valfmt
, 
Rhsfmt
,

391 &
Ptrcrd
, &
Indcrd
, &
Valcrd
, &
Rhscrd
, 
Rhstype
);

394 
	`ParseIfmt
(
Ptrfmt
,&
Ptrperline
,&
Ptrwidth
);

395 
	`ParseIfmt
(
Indfmt
,&
Indperline
,&
Indwidth
);

396 
	`ParseRfmt
(
Valfmt
,&
Valperline
,&
Valwidth
,&
Valflag
);

400 
count
=0;

401 for (
i
=0;i<
Ptrcrd
;i++)

403 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

404 
	`nullchk
(
line_ptr
);

405 
col
 = 0;

406 for (
ind
 = 0;ind<
Ptrperline
;ind++)

408 if (
count
 > 
Ncol
) break;

409 
ThisElement
 = 
	`substr
(
line
,
col
,
Ptrwidth
);

410 
colptr
[
count
] = 
	`atoi
(
ThisElement
)-1;

411 
count
++; 
col
 += 
Ptrwidth
;

417 
count
 = 0;

418 for (
i
=0;i<
Indcrd
;i++)

420 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

421 
	`nullchk
(
line_ptr
);

422 
col
 = 0;

423 for (
ind
 = 0;ind<
Indperline
;ind++)

425 if (
count
 == 
Nnzero
) break;

426 
ThisElement
 = 
	`substr
(
line
,
col
,
Indwidth
);

427 
rowind
[
count
] = 
	`atoi
(
ThisElement
)-1;

428 
count
++; 
col
 += 
Indwidth
;

434 
count
 = 0;

435 for (
i
=0;i<
Valcrd
;i++)

437 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

438 
	`nullchk
(
line_ptr
);

439 if (
Valflag
 == 'D') 
	`convertDtoE
(
line
);

440 
col
 = 0;

441 for (
ind
 = 0;ind<
Valperline
;ind++)

443 if (
count
 == 
Nnzero
) break;

444 
ThisElement
 = 
	`substr
(
line
,
col
,
Valwidth
);

445 
val
[
count
] = 
	`atof
(
ThisElement
);

446 
count
++; 
col
 += 
Valwidth
;

451 
	}
}

454 void 
	$readHB_rhs_double
(
filename
, 
b
, 
j
)

455 char *
filename
; double 
b
[]; int 
j
;

475 int 
i
, 
n
, 
null_entries
, 
lines_left
;

476 
FILE
 *
in_file
;

477 char 
Title
[73], 
Key
[9], 
Type
[4], 
Rhstype
[4];

478 char 
Ptrfmt
[17], 
Indfmt
[17], 
Valfmt
[21], 
Rhsfmt
[21];

479 int 
Ptrcrd
, 
Indcrd
, 
Valcrd
, 
Rhscrd
;

480 int 
Nrow
, 
Ncol
, 
Nnzero
;

481 int 
Nrhs
;

482 int 
Rhsperline
, 
Rhswidth
;

483 int 
Rhsflag
;

484 char 
buffer
[
BUFSIZ
];

485 int 
ind
, 
col
;

486 int 
count
;

487 char *
line_ptr
;

488 char 
line
[80];

489 char *
ThisElement
;

491 if ((
in_file
 = 
	`fopen
( 
filename
, "r")) == 
NULL
)

493 
	`printf
("Cannot open file: %s\n",
filename
);

494 
	`exit
(1);

497 
	`readHB_header
(
in_file
, 
Title
, 
Key
, 
Type
, &
Nrow
, &
Ncol
, &
Nnzero
, &
Nrhs
,

498 
Ptrfmt
, 
Indfmt
, 
Valfmt
, 
Rhsfmt
,

499 &
Ptrcrd
, &
Indcrd
, &
Valcrd
, &
Rhscrd
, 
Rhstype
);

501 if (
Nrhs
 <= 0)

503 
	`printf
("Attempt to read rhs when none is present.\n");

504 
	`exit
(1);

507 if (
Rhstype
[0] != 'F')

509 
	`printf
("Attempt to read rhs which is not stored in Full form.\n");

510 
	`printf
("Rhs must be specified as full. \n");

511 
	`exit
(1);

515 
	`ParseRfmt
(
Rhsfmt
, &
Rhsperline
, &
Rhswidth
, &
Rhsflag
);

518 
n
 = 
Ptrcrd
 + 
Indcrd
 + 
Valcrd
 + 
j
*
Nrow
/
Rhsperline
;

522 
null_entries
 = 
j
*
Nrow
%
Rhsperline
;

523 
lines_left
 = (int) ( .5 + (double) (
Nrow
-
Rhsperline
+
null_entries
)/

524 (double) 
Rhsperline
 );

526 for (
i
 = 0; i < 
n
; i++)

527 
	`fgets
(
buffer
, 
BUFSIZ
, 
in_file
);

529 
count
 = 0;

534 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

535 
	`nullchk
(
line_ptr
);

536 
col
 = 0;

537 for (
ind
 = 0; ind < 
Rhsperline
; ind++)

539 if (
ind
 < 
null_entries
)

540 
col
 += 
Rhswidth
;

543 if (
count
 > 
Nrow
-1)

545 
ThisElement
 = 
	`substr
(
line
, 
col
, 
Rhswidth
);

546 
b
[
count
] = 
	`atof
(
ThisElement
);

547 
count
++; 
col
 += 
Rhswidth
;

552 for (
i
 = 0; i < 
lines_left
; i++)

554 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

555 
	`nullchk
(
line_ptr
);

556 
col
 = 0;

557 for (
ind
 = 0; ind < 
Rhsperline
; ind++)

559 if (
count
 > 
Nrow
-1)

561 
ThisElement
 = 
	`substr
(
line
, 
col
, 
Rhswidth
);

562 
b
[
count
] = 
	`atof
(
ThisElement
);

563 
count
++; 
col
 += 
Rhswidth
;

568 
	}
}

570 void 
	$readHB_rhs_float
(
filename
, 
b
, 
j
)

571 char *
filename
; float 
b
[]; int 
j
;

591 int 
i
, 
n
, 
null_entries
, 
lines_left
;

592 
FILE
 *
in_file
;

593 char 
Title
[73], 
Key
[9], 
Type
[4], 
Rhstype
[4];

594 char 
Ptrfmt
[17], 
Indfmt
[17], 
Valfmt
[21], 
Rhsfmt
[21];

595 int 
Ptrcrd
, 
Indcrd
, 
Valcrd
, 
Rhscrd
;

596 int 
Nrow
, 
Ncol
, 
Nnzero
;

597 int 
Nrhs
;

598 int 
Rhsperline
, 
Rhswidth
;

599 int 
Rhsflag
;

600 char 
buffer
[
BUFSIZ
];

601 int 
ind
, 
col
;

602 int 
count
;

603 char *
line_ptr
;

604 char 
line
[80];

605 char *
ThisElement
;

607 if ((
in_file
 = 
	`fopen
( 
filename
, "r")) == 
NULL
)

609 
	`printf
("Cannot open file: %s\n",
filename
);

610 
	`exit
(1);

613 
	`readHB_header
(
in_file
, 
Title
, 
Key
, 
Type
, &
Nrow
, &
Ncol
, &
Nnzero
, &
Nrhs
,

614 
Ptrfmt
, 
Indfmt
, 
Valfmt
, 
Rhsfmt
,

615 &
Ptrcrd
, &
Indcrd
, &
Valcrd
, &
Rhscrd
, 
Rhstype
);

617 if (
Nrhs
 <= 0)

619 
	`printf
("Attempt to read rhs when none is present.\n");

620 
	`exit
(1);

623 if (
Rhstype
[0] != 'F')

625 
	`printf
("Attempt to read rhs which is not stored in Full form.\n");

626 
	`printf
("Rhs must be specified as full. \n");

627 
	`exit
(1);

631 
	`ParseRfmt
(
Rhsfmt
, &
Rhsperline
, &
Rhswidth
, &
Rhsflag
);

634 
n
 = 
Ptrcrd
 + 
Indcrd
 + 
Valcrd
 + 
j
*
Nrow
/
Rhsperline
;

638 
null_entries
 = 
j
*
Nrow
%
Rhsperline
;

639 
lines_left
 = (int)( .5 + (double) (
Nrow
-
Rhsperline
+
null_entries
)/

640 (double) 
Rhsperline
);

642 for (
i
 = 0; i < 
n
; i++)

643 
	`fgets
(
buffer
, 
BUFSIZ
, 
in_file
);

645 
count
 = 0;

650 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

651 
	`nullchk
(
line_ptr
);

652 
col
 = 0;

653 for (
ind
 = 0; ind < 
Rhsperline
; ind++)

655 if (
ind
 < 
null_entries
)

656 
col
 += 
Rhswidth
;

659 if (
count
 > 
Nrow
-1)

661 
ThisElement
 = 
	`substr
(
line
, 
col
, 
Rhswidth
);

662 
b
[
count
] = 
	`atof
(
ThisElement
);

663 
count
++; 
col
 += 
Rhswidth
;

668 for (
i
 = 0; i < 
lines_left
; i++)

670 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

671 
	`nullchk
(
line_ptr
);

672 
col
 = 0;

673 for (
ind
 = 0; ind < 
Rhsperline
; ind++)

675 if (
count
 > 
Nrow
-1)

677 
ThisElement
 = 
	`substr
(
line
, 
col
, 
Rhswidth
);

678 
b
[
count
] = 
	`atof
(
ThisElement
);

679 
count
++; 
col
 += 
Rhswidth
;

684 
	}
}

687 void 
	$writeHB_mat_double
(
filename
, 
M
, 
N
, 
nz
, 
colptr
, 
rowind
, 
val
, 
nrhs
, 
rhs
,

688 
Title
, 
Key
)

689 char *
filename
; int 
M
, 
N
, 
nz
, 
colptr
[], 
rowind
[]; double 
val
[]; int 
nrhs
;

690 double 
rhs
[]; char *
Title
; char *
Key
;

703 
FILE
 *
out_file
;

705 int 
totcrd
, 
ptrcrd
, 
indcrd
, 
valcrd
, 
rhscrd
;

706 char *
ptrfmt
, *
indfmt
, *
valfmt
, *
rhsfmt
;

707 char *
Type
;

708 char *
Titlefill
, *
Keyfill
;

709 int 
filllen
, 
i
;

710 int 
entry
, 
finfo
;

712 
out_file
 = 
	`fopen
( 
filename
, "w");

714 
ptrcrd
 = (
N
+1)/8;

715 if ( (
N
+1)%8 != 0) 
ptrcrd
++;

717 
indcrd
 = 
nz
/8;

718 if ( 
nz
%8 != 0) 
indcrd
++;

720 
valcrd
 = 
nz
/4;

721 if ( 
nz
%4 != 0) 
valcrd
++;

723 
rhscrd
 = 
nrhs
*
M
/4;

724 if ( 
nrhs
*
M
%4 != 0) 
rhscrd
++;

726 
totcrd
 = 4+
ptrcrd
+
indcrd
+
valcrd
+
rhscrd
;

728 
ptrfmt
 = "(8I10) ";

729 
indfmt
 = 
ptrfmt
;

730 
valfmt
 = "(4E20.16) ";

731 
rhsfmt
 = 
valfmt
;

733 
Type
 = "RUA";

737 
	`fprintf
(
out_file
,"%-72s%-8s\n%14d%14d%14d%14d%14d\n",
Title
, 
Key
, 
totcrd
,

738 
ptrcrd
, 
indcrd
, 
valcrd
, 
rhscrd
);

739 
	`fprintf
(
out_file
,"%3s%11s%14d%14d%14d\n",
Type
," ", 
M
, 
N
, 
nz
);

740 
	`fprintf
(
out_file
,"%16s%16s%20s%20s\n", 
ptrfmt
, 
indfmt
, 
valfmt
, 
rhsfmt
);

741 if ( 
nrhs
 != 0 ) {

743 
	`fprintf
(
out_file
,"F %d\n", 
nrhs
);

747 for (
i
=0;i<
N
+1;i++)

749 
entry
 = 
colptr
[
i
]+1;

750 
	`fprintf
(
out_file
,"%10d",
entry
);

751 if ( (
i
+1)%8 == 0 ) 
	`fprintf
(
out_file
,"\n");

754 if ( (
N
+1) % 8 != 0 ) 
	`fprintf
(
out_file
,"\n");

757 for (
i
=0;i<
nz
;i++)

759 
entry
 = 
rowind
[
i
]+1;

760 
	`fprintf
(
out_file
,"%10d",
entry
);

761 if ( (
i
+1)%8 == 0 ) 
	`fprintf
(
out_file
,"\n");

764 if ( 
nz
 % 8 != 0 ) 
	`fprintf
(
out_file
,"\n");

767 for (
i
=0;i<
nz
;i++)

769 
	`fprintf
(
out_file
,"% 20.12E",
val
[
i
]);

770 if ( (
i
+1)%4 == 0 ) 
	`fprintf
(
out_file
,"\n");

773 if ( 
nz
 % 4 != 0 ) 
	`fprintf
(
out_file
,"\n");

776 if ( 
nrhs
 > 0 ) {

777 for (
i
=0;i<
nrhs
*
M
;i++)

779 
	`fprintf
(
out_file
,"% 20.12E",
rhs
[
i
]);

780 if ( (
i
+1)%4 == 0 ) 
	`fprintf
(
out_file
,"\n");

784 
finfo
 = 
	`fclose
(
out_file
);

785 if (
finfo
 != 0) 
	`printf
("Error closing file in writeHB_mat_double().\n");

788 
	}
}

791 void 
	$writeHB_mat_float
(
filename
, 
M
, 
N
, 
nz
, 
colptr
, 
rowind
, 
val
, 
nrhs
, 
rhs
,

792 
Title
, 
Key
)

793 char *
filename
; int 
M
, 
N
, 
nz
, 
colptr
[], 
rowind
[]; float 
val
[]; int 
nrhs
;

794 float 
rhs
[]; char *
Title
; char *
Key
;

807 
FILE
 *
out_file
;

809 int 
totcrd
, 
ptrcrd
, 
indcrd
, 
valcrd
, 
rhscrd
;

810 char *
ptrfmt
, *
indfmt
, *
valfmt
;

811 char *
Type
;

812 char *
Titlefill
, *
Keyfill
;

813 int 
filllen
, 
i
;

814 int 
entry
, 
finfo
;

816 
out_file
 = 
	`fopen
( 
filename
, "w");

818 
ptrcrd
 = (
N
+1)/8;

819 if ( (
N
+1)%8 != 0) 
ptrcrd
++;

821 
indcrd
 = 
nz
/8;

822 if ( 
nz
%8 != 0) 
indcrd
++;

824 
valcrd
 = 
nz
/4;

825 if ( 
nz
%4 != 0) 
valcrd
++;

827 
rhscrd
 = 
nrhs
*
M
/4;

828 if ( 
nrhs
*
M
%4 != 0) 
rhscrd
++;

830 
totcrd
 = 4+
ptrcrd
+
indcrd
+
valcrd
+
rhscrd
;

832 
ptrfmt
 = "(8I10) ";

833 
indfmt
 = 
ptrfmt
;

834 
valfmt
 = "(4E20.16) ";

836 
Type
 = "RUA";

840 
	`fprintf
(
out_file
,"%-72s%-8s\n%14d%14d%14d%14d%14d\n",
Title
, 
Key
, 
totcrd
,

841 
ptrcrd
, 
indcrd
, 
valcrd
, 
rhscrd
);

842 
	`fprintf
(
out_file
,"%3s%11s%14d%14d%14d\n",
Type
," ", 
M
, 
N
, 
nz
);

843 
	`fprintf
(
out_file
,"%16s%16s%16s\n", 
ptrfmt
, 
indfmt
, 
valfmt
);

846 for (
i
=0;i<
N
+1;i++)

848 
entry
 = 
colptr
[
i
]+1;

849 
	`fprintf
(
out_file
,"%10d",
entry
);

850 if ( (
i
+1)%8 == 0 ) 
	`fprintf
(
out_file
,"\n");

853 if ( (
N
+1) % 8 != 0 ) 
	`fprintf
(
out_file
,"\n");

856 for (
i
=0;i<
nz
;i++)

858 
entry
 = 
rowind
[
i
]+1;

859 
	`fprintf
(
out_file
,"%10d",
entry
);

860 if ( (
i
+1)%8 == 0 ) 
	`fprintf
(
out_file
,"\n");

863 if ( 
nz
 % 8 != 0 ) 
	`fprintf
(
out_file
,"\n");

866 for (
i
=0;i<
nz
;i++)

868 
	`fprintf
(
out_file
,"% 20.12E",
val
[
i
]);

869 if ( (
i
+1)%4 == 0 ) 
	`fprintf
(
out_file
,"\n");

872 if ( 
nz
 % 4 != 0 ) 
	`fprintf
(
out_file
,"\n");

875 if ( 
nrhs
 > 0 ) {

876 for (
i
=0;i<
nrhs
*
M
;i++)

878 
	`fprintf
(
out_file
,"% 20.12E",
rhs
[
i
]);

879 if ( (
i
+1)%4 == 0 ) 
	`fprintf
(
out_file
,"\n");

883 
finfo
 = 
	`fclose
(
out_file
);

884 if (
finfo
 != 0) 
	`printf
("Error closing file in writeHB_mat_float().\n");

887 
	}
}

900 void 
	$nullchk
(
line_ptr
)

901 char *
line_ptr
;

903 if (
line_ptr
 == 
NULL
)

905 
	`printf
("Cannot complete reading file information.\n ");

906 
	`exit
(1);

908 
	}
}

914 void 
	$ParseIfmt
(
fmt
, 
perline
, 
width
)

915 char *
fmt
; int *
perline
; int *
width
;

917 char *
PPL
, *
WID
;

918 
	`upcase
(
fmt
);

919 
PPL
 = 
	`substr_before
(
fmt
,'I');

920 
PPL
 = 
	`substr
(PPL,1,
	`strlen
(PPL)-1);

921 *
perline
 = 
	`atoi
(
PPL
);

922 
WID
 = 
	`substr_after
(
fmt
,'I');

923 
WID
 = 
	`substr
(WID,0,
	`strlen
(WID)-1);

924 *
width
 = 
	`atoi
(
WID
);

925 
	}
}

932 void 
	$ParseRfmt
(
fmt
, 
perline
, 
width
, 
flag
)

933 char *
fmt
; int *
perline
; int *
width
; int *
flag
;

935 int 
foundE
, 
foundD
, 
foundF
, 
foundP
;

936 char *
PPL
, *
WID
;

938 if (
fmt
 == 
NULL
 )

940 *
perline
 = 0; *
width
 = 0; *
flag
 = '\0'; return;

943 
	`upcase
(
fmt
);

944 
foundP
 = 
	`my_index
(
fmt
,'P');

945 
foundE
 = 
	`my_index
(
fmt
,'E');

946 
foundD
 = 
	`my_index
(
fmt
,'D');

947 
foundF
 = 
	`my_index
(
fmt
,'F');

948 if (
foundP
 != -1 )

950 
fmt
 = fmt + 
foundP
 + 1;

952 if (
foundE
 != -1 )

954 *
flag
 = 'E';

955 
PPL
 = 
	`substr_before
(
fmt
,'E');

956 
PPL
 = 
	`substr
(PPL,1,
	`strlen
(PPL)-1);

957 *
perline
 = 
	`atoi
(
PPL
);

958 
WID
 = 
	`substr_after
(
fmt
,'E');

959 
WID
 = 
	`substr_through
(WID,'.');

960 
WID
 = 
	`substr
(WID,0,
	`strlen
(WID)-1);

961 *
width
 = 
	`atoi
(
WID
);

963 else if (
foundD
 != -1)

965 *
flag
 = 'D';

966 
PPL
 = 
	`substr_before
(
fmt
,'D');

967 
PPL
 = 
	`substr
(PPL,1,
	`strlen
(PPL)-1);

968 *
perline
 = 
	`atoi
(
PPL
);

969 
WID
 = 
	`substr_after
(
fmt
,'D');

970 
WID
 = 
	`substr_through
(WID,'.');

971 
WID
 = 
	`substr
(WID,0,
	`strlen
(WID)-1);

972 *
width
 = 
	`atoi
(
WID
);

974 else if (
foundF
 != -1)

976 *
flag
 = 'F';

977 
PPL
 = 
	`substr_before
(
fmt
,'F');

978 
PPL
 = 
	`substr
(PPL,1,
	`strlen
(PPL)-1);

979 *
perline
 = 
	`atoi
(
PPL
);

980 
WID
 = 
	`substr_after
(
fmt
,'F');

981 
WID
 = 
	`substr_through
(WID,'.');

982 
WID
 = 
	`substr
(WID,0,
	`strlen
(WID)-1);

983 *
width
 = 
	`atoi
(
WID
);

987 
	`printf
("Real format in H/B file not supported.\n");

988 
	`exit
(1);

991 
	}
}

999 void 
	$convertDtoE
(
line
)

1000 char *
line
;

1002 int 
len
, 
i
;

1003 
len
 = 
	`strlen
(
line
);

1004 for (
i
=0;i<
len
;i++)

1005 if ( 
line
[
i
] == 'D' || line[i] == 'd' ) line[i] = line[i]+1;

1007 
	}
}

1019 char* 
	$substr
(
S
, 
pos
, 
len
)

1020 char *
S
;

1021 int 
pos
, 
len
;

1023 int 
i
;

1024 char *
SubS
;

1025 
SubS
 = 
	`malloc
(
len
+1);

1026 if ( (
pos
+
len
) > 
	`strlen
(
S
))

1028 
	`printf
("Error: Substring (%s, %d, %d) will read beyond string boundary.\n",

1029 
S
, 
pos
, 
len
);

1030 
	`exit
(1);

1032 for (
i
=0;i<
len
;i++)

1033 
SubS
[
i
] = 
S
[
pos
+i];

1034 
SubS
[
len
] = '\0';

1035 return 
SubS
;

1036 
	}
}

1038 char* 
	$substr_after
(
S
, 
M
)

1039 char *
S
; char 
M
;

1043 int 
i
, 
pos
, 
SubSlen
;

1044 char * 
SubS
;

1045 
pos
 = 0;

1046 for (
i
=0;i< 
	`strlen
(
S
);i++)

1048 if ( 
S
[
i
] == 
M
 )

1050 
pos
 = 
i
+1;

1054 if (
pos
 != 0)

1056 
SubSlen
 = 
	`strlen
(
S
) - 
pos
;

1057 
SubS
 = 
	`malloc
(
SubSlen
);

1058 for (
i
=0;i< 
SubSlen
;i++)

1059 
SubS
[
i
] = 
S
[
pos
+i];

1060 
SubS
[
SubSlen
] = '\0';

1061 return 
SubS
;

1065 
	`printf
("Character %s not found in input string.\n", 
M
);

1066 
	`exit
(1);

1069 return 
NULL
;

1070 
	}
}

1074 char* 
	$substr_before
(
S
, 
M
)

1075 char *
S
; char 
M
;

1079 int 
i
, 
pos
, 
SubSlen
;

1080 char* 
SubS
;

1081 
pos
 = 0;

1082 for (
i
=0;i< 
	`strlen
(
S
);i++)

1084 if ( 
S
[
i
] == 
M
 )

1086 
pos
 = 
i
-1;

1090 if (
pos
 != 0)

1092 
SubSlen
 = 
pos
+1;

1093 
SubS
 = 
	`malloc
(
SubSlen
);

1094 for (
i
=0;i< 
SubSlen
;i++)

1095 
SubS
[
i
] = 
S
[i];

1096 
SubS
[
SubSlen
] = '\0';

1097 return 
SubS
;

1101 
	`printf
("Character %s not found in input string.\n", 
M
);

1102 
	`exit
(1);

1104 return 
NULL
;

1105 
	}
}

1108 char* 
	$substr_through
(
S
, 
M
)

1109 char *
S
; char 
M
;

1112 int 
i
, 
pos
, 
SubSlen
;

1113 char *
SubS
;

1114 
pos
 = 0;

1115 for (
i
=0;i< 
	`strlen
(
S
);i++)

1117 if ( 
S
[
i
] == 
M
 )

1119 
pos
 = 
i
;

1123 if (
pos
 != 0)

1125 
SubSlen
 = 
pos
+1;

1126 
SubS
 = 
	`malloc
(
SubSlen
);

1127 for (
i
=0;i< 
SubSlen
;i++)

1128 
SubS
[
i
] = 
S
[i];

1129 
SubS
[
SubSlen
] = '\0';

1130 return 
SubS
;

1134 
	`printf
("Character %s not found in input string.\n", 
M
);

1135 
	`exit
(1);

1137 return 
NULL
;

1138 
	}
}

1141 void 
	$upcase
(
S
)

1142 char *
S
;

1145 int 
i
;

1146 for (
i
=0;i< 
	`strlen
(
S
);i++)

1147 if ( 
S
[
i
] >= 'a' && S[i] <= 'z' ) S[i] = S[i] - 32;

1148 
	}
}

1151 int 
	$my_index
(
S
, 
M
)

1152 char *
S
; char 
M
;

1156 int 
i
, 
pos
;

1157 
pos
 = -1;

1158 for (
i
=0;i< 
	`strlen
(
S
);i++)

1160 if ( 
S
[
i
] == 
M
 )

1162 
pos
 = 
i
;

1166 return 
pos
;

1167 
	}
}

1170 void 
	$readHB_newmat_double
(
filename
, 
M
, 
N
, 
nonzeros
, 
colptr
, 
rowind
, 
val
)

1171 char *
filename
; int *
M
; int *
N
; int *
nonzeros
; int **
colptr
;

1172 int **
rowind
; double **
val
;

1174 int 
nrhs
;

1176 
	`readHB_info
(
filename
, 
M
, 
N
, 
nonzeros
, &
nrhs
);

1177 *
colptr
 = (int *)
	`malloc
((*
N
+1)*sizeof(int));

1178 *
rowind
 = (int *)
	`malloc
(*
nonzeros
*sizeof(int));

1179 *
val
 = (double *)
	`malloc
(*
nonzeros
*sizeof(double));

1181 
	`readHB_mat_double
(
filename
, *
colptr
, *
rowind
, *
val
);

1183 
	}
}

1185 void 
	$readHB_newmat_float
(
filename
, 
M
, 
N
, 
nonzeros
, 
colptr
, 
rowind
, 
val
)

1186 char *
filename
; int *
M
; int *
N
; int *
nonzeros
; int **
colptr
;

1187 int **
rowind
; float **
val
;

1189 int 
nrhs
;

1191 
	`readHB_info
(
filename
, 
M
, 
N
, 
nonzeros
, &
nrhs
);

1192 *
colptr
 = (int *)
	`malloc
((*
N
+1)*sizeof(int));

1193 *
rowind
 = (int *)
	`malloc
(*
nonzeros
*sizeof(int));

1194 *
val
 = (float *)
	`malloc
(*
nonzeros
*sizeof(float));

1196 
	`readHB_mat_float
(
filename
, *
colptr
, *
rowind
, *
val
);

1198 
	}
}

	@src/iohb_double.cc

35 #include 
	~<stdio.h
>

36 #include 
	~"vecdefs.h
"

37 #include 
VECTOR_H


38 #include 
MATRIX_H


39 #include 
	~"compcol_double.h
"

40 #include 
	~"comprow_double.h
"

41 #include 
	~"coord_double.h
"

42 #include 
	~"iohb_double.h
"

46 
	gCompCol_Mat_double
& 
	$readHB_mat
(const char *
filename
, 
CompCol_Mat_double
 *
A
)

48 int 
M
=0, 
N
=0, 
nz
=0, 
nrhs
=0;

49 
	`readHB_info
(
filename
, &
M
, &
N
, &
nz
, &
nrhs
);

50 
CompCol_Mat_double
 &
T
 = *
A
;

52 
T
.
	`newsize
(
M
,
N
,
nz
);

53 
	`readHB_mat_double
(
filename
, &
T
.
	`col_ptr
(0), &T.
	`row_ind
(0), &T.
	`val
(0));

54 return 
T
;

55 
	}
}

57 
	gCompRow_Mat_double
& 
	$readHB_mat
(const char *
filename
, 
CompRow_Mat_double
 *
A
)

59 
CompCol_Mat_double
 
B
;

60 
	`readHB_mat
(
filename
, &
B
);

61 *
A
 = 
B
;

62 return *
A
;

63 
	}
}

65 
	gCoord_Mat_double
& 
	$readHB_mat
(const char *
filename
, 
Coord_Mat_double
 *
A
)

67 
CompCol_Mat_double
 
B
;

68 
	`readHB_mat
(
filename
, &
B
);

69 *
A
 = 
B
;

70 return *
A
;

71 
	}
}

75 const 
	gCompCol_Mat_double
& 
	$writeHB_mat
(const char *
filename
,

76 const 
CompCol_Mat_double
 &
A
, int 
nrhs
, const double* 
rhs
, const char

77 *
title
, const char *
key
)

79 const char *
title_
 = (
title
==0 ? "Generated by SparseLib++" : title);

80 const char *
key_
 = (
key
==0 ? "SL++" : key);

83 
	`writeHB_mat_double
(
filename
, 
A
.
	`dim
(0), A.dim(1), A.
	`NumNonzeros
(),

84 &(
A
.
	`col_ptr
(0)), &(A.
	`row_ind
(0)), &(A.
	`val
(0)), 
nrhs
, 
rhs
, 
title_
, 
key_
);

85 return 
A
;

86 
	}
}

88 const 
	gCompRow_Mat_double
& 
	$writeHB_mat
(const char *
filename
,

89 const 
CompRow_Mat_double
 &
A
, int 
nrhs
, const double* 
rhs
, const char *
title
,

90 const char *
key
)

92 const char *
title_
 = (
title
==0 ? "Generated by SparseLib++" : title);

93 const char *
key_
 = (
key
==0 ? "SL++" : key);

97 
CompCol_Mat_double
 
	`B
(
A
);

99 
	`writeHB_mat_double
(
filename
, 
B
.
	`dim
(0), B.dim(1), B.
	`NumNonzeros
(),

100 &(
B
.
	`col_ptr
(0)), &(B.
	`row_ind
(0)), &(B.
	`val
(0)), 
nrhs
, 
rhs
, 
title_
, 
key_
);

101 return 
A
;

102 
	}
}

105 const 
	gCoord_Mat_double
& 
	$writeHB_mat
(const char *
filename
,

106 const 
Coord_Mat_double
 &
A
, int 
nrhs
, const double *
rhs
, const char *
title
,

107 const char *
key
)

109 const char *
title_
 = (
title
==0 ? "Generated by SparseLib++" : title);

110 const char *
key_
 = (
key
==0 ? "SL++" : key);

113 
CompCol_Mat_double
 
	`B
(
A
);

115 
	`writeHB_mat_double
(
filename
, 
B
.
	`dim
(0), B.dim(1), B.
	`NumNonzeros
(),

116 &(
B
.
	`col_ptr
(0)), &(B.
	`row_ind
(0)), &(B.
	`val
(0)), 
nrhs
, 
rhs
, 
title_
, 
key_
);

117 return 
A
;

118 
	}
}

122 
	gVECTOR_double
& 
	$readHB_rhs
(const char *
filename
, 
VECTOR_double
 *
b
, int 
j
)

124 int 
M
;

125 int 
N
;

126 int 
nrhs
;

127 int 
nz
;

129 
	`readHB_info
(
filename
, &
M
, &
N
, &
nz
, &
nrhs
);

130 
VECTOR_double
 
	`T
(
N
);

132 if (
j
 >= 0 && j < 
nrhs
)

133 
	`readHB_rhs_double
(
filename
, &
	`T
(0), 
j
);

136 
	`printf
(

138 
j
, 
filename
);

139 
	`exit
(1);

141 return ( *
b
 = 
T
) ;

142 
	}
}

	@src/iotext.c

35 #include
	~<stdio.h
>

36 #include
	~<stdlib.h
>

38 #include 
	~"compcol_double.h
"

39 #include 
	~"comprow_double.h
"

40 #include 
	~"coord_double.h
"

42 void 
	$readtxtfile_mat
(const char *
filename
, 
Coord_Mat_double
 &
A
)

62 
FILE
 *
in_file
;

63 char 
line
[82];

64 char* 
line_ptr
;

67 
in_file
 = 
	`fopen
( 
filename
, "r");

68 if (
in_file
 == 
NULL
)

70 
cerr
 << "Cannot open file: " << 
filename
 << 
endl
;

71 
	`exit
(1);

77 int 
args
, 
i
, 
j
;

78 double 
value
;

79 int 
count
 = 0;

80 int 
maxrow
 = 0;

81 int 
maxcol
 = 0;

84 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

85 if (
line_ptr
 == 
NULL
) break;

86 
args
 = 
	`sscanf
(
line_ptr
,"%d %d %le",&
i
,&
j
,&
value
);

87 if (
args
 != 3)

89 
	`printf
("Error reading textfile:%s\n",
filename
);

90 
	`exit
(1);

92 if (
i
 > 
maxrow
) maxrow = i;

93 if (
j
 > 
maxcol
) maxcol = j;

94 
count
++;

96 
	`fclose
(
in_file
);

100 double *
val
= 
new
 double[
count
];

101 int *
colind
 = 
new
 int[
count
], *
rowind
 = new int[count];

103 
in_file
 = 
	`fopen
( 
filename
, "r");

104 if (
in_file
 == 
NULL
)

106 
cerr
 << "Cannot open file: " << 
filename
 << 
endl
;

107 
	`exit
(1);

110 for (
i
=0;i<
count
;i++)

112 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

113 if (
line_ptr
 == 
NULL
) break;

114 
args
 = 
	`sscanf
(
line_ptr
,"%d %d %le",&
rowind
[
i
],&
colind
[i],&
val
[i]);

115 
rowind
[
i
]--; 
colind
[i]--;

116 if (
args
 != 3)

118 
	`printf
("Error reading textfile:%s\n",
filename
);

119 
	`exit
(1);

123 
	`fclose
(
in_file
);

125 
Coord_Mat_double
 
	`C
(
maxrow
,
maxcol
,
count
, 
val
, 
rowind
, 
colind
);

126 
A
 = 
C
;

129 
	}
}

132 void 
	$readtxtfile_mat
(const char *
filename
, 
CompCol_Mat_double
 &
A
)

134 
Coord_Mat_double
 
C
;

135 
	`readtxtfile_mat
(
filename
, 
C
);

136 
A
 = 
C
;

138 
	}
}

140 void 
	$readtxtfile_mat
(const char *
filename
, 
CompRow_Mat_double
 &
A
)

142 
Coord_Mat_double
 
C
;

143 
	`readtxtfile_mat
(
filename
, 
C
);

144 
A
 = 
C
;

146 
	}
}

148 void 
	$writetxtfile_mat
(const char *
filename
, 
Coord_Mat_double
 &
A
)

164 
FILE
 *
out_file
;

165 
out_file
 = 
	`fopen
( 
filename
, "w");

167 int 
nnz
 = 
A
.
	`NumNonzeros
();

168 int 
rowp1
, 
colp1
;

169 int 
M
 = 
A
.
	`dim
(0);

170 int 
N
 = 
A
.
	`dim
(1);

171 int 
flag
 = 0;

173 for (int 
j
 = 0; j < 
nnz
 ; j++)

175 
rowp1
 = 
A
.
	`row_ind
(
j
) +1;

176 
colp1
 = 
A
.
	`col_ind
(
j
) +1;

177 if ( 
rowp1
 == 
M
 && 
colp1
 == 
N
 ) 
flag
 = 1;

178 
	`fprintf
(
out_file
, "%14d%4s%14d \t % 20.16E\n", 
rowp1
, " ",

179 
colp1
," ", 
A
.
	`val
(
j
));

181 if (
flag
 == 0)

182 
	`fprintf
(
out_file
, "%14d%4s%14d%\t % 20.16E\n", 
M
, " ",

183 
N
," ", 
	`A
(
M
-1,N-1));

184 
	`fclose
(
out_file
);

187 
	}
}

190 void 
	$writetxtfile_mat
(const char *
filename
, 
CompCol_Mat_double
 &
A
)

192 
FILE
 *
out_file
;

193 
out_file
 = 
	`fopen
( 
filename
, "w");

195 int 
rowp1
, 
colp1
;

196 int 
M
 = 
A
.
	`dim
(0);

197 int 
N
 = 
A
.
	`dim
(1);

198 int 
flag
 = 0;

200 for (int 
j
 = 0; j < 
N
 ; j++)

201 for (int 
i
=
A
.
	`col_ptr
(
j
);i<A.col_ptr(j+1);i++)

203 
rowp1
 = 
A
.
	`row_ind
(
i
)+1;

204 
colp1
 = 
j
 + 1;

205 if ( 
rowp1
 == 
M
 && 
colp1
 == 
N
 ) 
flag
 = 1;

206 
	`fprintf
(
out_file
,"%14d%4s%14d%4s% 20.16E\n", 
rowp1
, " ",

207 
colp1
," ", 
A
.
	`val
(
i
));

210 if (
flag
 == 0)

211 
	`fprintf
(
out_file
,"%14d%4s%14d%4s% 20.16E\n", 
M
, " ", 
N
," ", 
	`A
(M-1,N-1));

213 
	`fclose
(
out_file
);

216 
	}
}

218 void 
	$writetxtfile_mat
(const char *
filename
, 
CompRow_Mat_double
 &
A
)

220 
FILE
 *
out_file
;

221 
out_file
 = 
	`fopen
( 
filename
, "w");

223 int 
rowp1
, 
colp1
;

224 int 
M
 = 
A
.
	`dim
(0);

225 int 
N
 = 
A
.
	`dim
(1);

226 int 
flag
 = 0;

228 for (int 
i
 = 0; i < 
M
 ; i++)

229 for (int 
j
=
A
.
	`row_ptr
(
i
);j<A.row_ptr(i+1);j++)

231 
rowp1
 = 
i
 + 1;

232 
colp1
 = 
A
.
	`col_ind
(
j
) + 1;

233 if ( 
rowp1
 == 
M
 && 
colp1
 == 
N
 ) 
flag
 = 1;

234 
	`fprintf
(
out_file
,"%14d%4s%14d%4s% 20.16E\n", 
rowp1
, " ",

235 
colp1
," ", 
A
.
	`val
(
j
));

238 if (
flag
 == 0)

239 
	`fprintf
(
out_file
,"%14d%4s%14d%4s% 20.16E\n", 
M
, " ", 
N
," ", 
	`A
(M-1,N-1));

241 
	`fclose
(
out_file
);

244 
	}
}

	@src/iotext.cc

35 #include
	~<stdio.h
>

36 #include
	~<stdlib.h
>

38 #include 
	~"compcol.h
"

39 #include 
	~"comprow.h
"

40 #include 
	~"coord.h
"

42 void 
	$readtxtfile_mat
(const char *
filename
, 
Coord_MatDouble
 &
A
)

62 
FILE
 *
in_file
;

63 char 
line
[82];

64 char* 
line_ptr
;

67 
in_file
 = 
	`fopen
( 
filename
, "r");

68 if (
in_file
 == 
NULL
)

70 
std
::
cerr
 << "Cannot open file: " << 
filename
 << "\n";

71 
	`exit
(1);

77 int 
args
, 
i
, 
j
;

78 double 
value
;

79 int 
count
 = 0;

80 int 
maxrow
 = 0;

81 int 
maxcol
 = 0;

84 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

85 if (
line_ptr
 == 
NULL
) break;

86 
args
 = 
	`sscanf
(
line_ptr
,"%d %d %le",&
i
,&
j
,&
value
);

87 if (
args
 != 3)

89 
	`printf
("Error reading textfile:%s\n",
filename
);

90 
	`exit
(1);

92 if (
i
 > 
maxrow
) maxrow = i;

93 if (
j
 > 
maxcol
) maxcol = j;

94 
count
++;

96 
	`fclose
(
in_file
);

100 double *
val
= 
new
 double[
count
];

101 int *
colind
 = 
new
 int[
count
], *
rowind
 = new int[count];

103 
in_file
 = 
	`fopen
( 
filename
, "r");

104 if (
in_file
 == 
NULL
)

106 
std
::
cerr
 << "Cannot open file: " << 
filename
 << "\n";

107 
	`exit
(1);

110 for (
i
=0;i<
count
;i++)

112 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

113 if (
line_ptr
 == 
NULL
) break;

114 
args
 = 
	`sscanf
(
line_ptr
,"%d %d %le",&
rowind
[
i
],&
colind
[i],&
val
[i]);

115 
rowind
[
i
]--; 
colind
[i]--;

116 if (
args
 != 3)

118 
	`printf
("Error reading textfile:%s\n",
filename
);

119 
	`exit
(1);

123 
	`fclose
(
in_file
);

125 
Coord_MatDouble
 
	`C
(
maxrow
,
maxcol
,
count
, 
val
, 
rowind
, 
colind
);

126 
A
 = 
C
;

129 
	}
}

132 void 
	$readtxtfile_mat
(const char *
filename
, 
CompCol_MatDouble
 &
A
)

134 
Coord_MatDouble
 
C
;

135 
	`readtxtfile_mat
(
filename
, 
C
);

136 
A
 = 
C
;

138 
	}
}

140 void 
	$readtxtfile_mat
(const char *
filename
, 
CompRow_MatDouble
 &
A
)

142 
Coord_MatDouble
 
C
;

143 
	`readtxtfile_mat
(
filename
, 
C
);

144 
A
 = 
C
;

146 
	}
}

148 void 
	$writetxtfile_mat
(const char *
filename
, 
Coord_MatDouble
 &
A
)

164 
FILE
 *
out_file
;

165 
out_file
 = 
	`fopen
( 
filename
, "w");

167 int 
nnz
 = 
A
.
	`NumNonzeros
();

168 int 
rowp1
, 
colp1
;

169 int 
M
 = 
A
.
	`dim
(0);

170 int 
N
 = 
A
.
	`dim
(1);

171 int 
flag
 = 0;

173 for (int 
j
 = 0; j < 
nnz
 ; j++)

175 
rowp1
 = 
A
.
	`row_ind
(
j
) +1;

176 
colp1
 = 
A
.
	`col_ind
(
j
) +1;

177 if ( 
rowp1
 == 
M
 && 
colp1
 == 
N
 ) 
flag
 = 1;

178 
	`fprintf
(
out_file
, "%14d%4s%14d%4s% 20.12E\n", 
rowp1
, " ",

179 
colp1
," ", 
A
.
	`val
(
j
));

181 if (
flag
 == 0)

182 
	`fprintf
(
out_file
, "%14d%4s%14d%4s% 20.12E\n", 
M
, " ",

183 
N
," ", 
	`A
(
M
-1,N-1));

184 
	`fclose
(
out_file
);

187 
	}
}

190 void 
	$writetxtfile_mat
(const char *
filename
, 
CompCol_MatDouble
 &
A
)

192 
FILE
 *
out_file
;

193 
out_file
 = 
	`fopen
( 
filename
, "w");

195 int 
rowp1
, 
colp1
;

196 int 
M
 = 
A
.
	`dim
(0);

197 int 
N
 = 
A
.
	`dim
(1);

198 int 
flag
 = 0;

200 for (int 
j
 = 0; j < 
N
 ; j++)

201 for (int 
i
=
A
.
	`col_ptr
(
j
);i<A.col_ptr(j+1);i++)

203 
rowp1
 = 
A
.
	`row_ind
(
i
)+1;

204 
colp1
 = 
j
 + 1;

205 if ( 
rowp1
 == 
M
 && 
colp1
 == 
N
 ) 
flag
 = 1;

206 
	`fprintf
(
out_file
,"%14d%4s%14d%4s% 20.12E\n", 
rowp1
, " ",

207 
colp1
," ", 
A
.
	`val
(
i
));

210 if (
flag
 == 0)

211 
	`fprintf
(
out_file
,"%14d%4s%14d%4s% 20.12E\n", 
M
, " ", 
N
," ", 
	`A
(M-1,N-1));

213 
	`fclose
(
out_file
);

216 
	}
}

218 void 
	$writetxtfile_mat
(const char *
filename
, 
CompRow_MatDouble
 &
A
)

220 
FILE
 *
out_file
;

221 
out_file
 = 
	`fopen
( 
filename
, "w");

223 int 
rowp1
, 
colp1
;

224 int 
M
 = 
A
.
	`dim
(0);

225 int 
N
 = 
A
.
	`dim
(1);

226 int 
flag
 = 0;

228 for (int 
i
 = 0; i < 
M
 ; i++)

229 for (int 
j
=
A
.
	`row_ptr
(
i
);j<A.row_ptr(i+1);j++)

231 
rowp1
 = 
i
 + 1;

232 
colp1
 = 
A
.
	`col_ind
(
j
) + 1;

233 if ( 
rowp1
 == 
M
 && 
colp1
 == 
N
 ) 
flag
 = 1;

234 
	`fprintf
(
out_file
,"%14d%4s%14d%4s% 20.12E\n", 
rowp1
, " ",

235 
colp1
," ", 
A
.
	`val
(
j
));

238 if (
flag
 == 0)

239 
	`fprintf
(
out_file
,"%14d%4s%14d%4s% 20.12E\n", 
M
, " ", 
N
," ", 
	`A
(M-1,N-1));

241 
	`fclose
(
out_file
);

244 
	}
}

	@src/iotext_double.cc

35 #include
	~<stdio.h
>

36 #include
	~<stdlib.h
>

37 #include 
	~<iostream
>

39 #include 
	~"compcol_double.h
"

40 #include 
	~"comprow_double.h
"

41 #include 
	~"coord_double.h
"

43 void 
	$readtxtfile_mat
(const char *
filename
, 
Coord_Mat_double
 *
A
)

63 
FILE
 *
in_file
;

64 char 
line
[82];

65 char* 
line_ptr
;

68 
in_file
 = 
	`fopen
( 
filename
, "r");

69 if (
in_file
 == 
NULL
)

71 
std
::
cerr
 << "Cannot open file: " << 
filename
 << "\n";

72 
	`exit
(1);

78 int 
args
, 
i
, 
j
;

79 double 
value
;

80 int 
count
 = 0;

81 int 
maxrow
 = 0;

82 int 
maxcol
 = 0;

85 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

86 if (
line_ptr
 == 
NULL
) break;

87 
args
 = 
	`sscanf
(
line_ptr
,"%d %d %le",&
i
,&
j
,&
value
);

88 if (
args
 != 3)

90 
	`printf
("Error reading textfile:%s\n",
filename
);

91 
	`exit
(1);

93 if (
i
 > 
maxrow
) maxrow = i;

94 if (
j
 > 
maxcol
) maxcol = j;

95 
count
++;

97 
	`fclose
(
in_file
);

101 double *
val
= 
new
 double[
count
];

102 int *
colind
 = 
new
 int[
count
], *
rowind
 = new int[count];

104 
in_file
 = 
	`fopen
( 
filename
, "r");

105 if (
in_file
 == 
NULL
)

107 
std
::
cerr
 << "Cannot open file: " << 
filename
 << "\n";

108 
	`exit
(1);

111 for (
i
=0;i<
count
;i++)

113 
line_ptr
 = 
	`fgets
(
line
, 82, 
in_file
);

114 if (
line_ptr
 == 
NULL
) break;

115 
args
 = 
	`sscanf
(
line_ptr
,"%d %d %le",&
rowind
[
i
],&
colind
[i],&
val
[i]);

116 
rowind
[
i
]--; 
colind
[i]--;

117 if (
args
 != 3)

119 
	`printf
("Error reading textfile:%s\n",
filename
);

120 
	`exit
(1);

126 
	`fclose
(
in_file
);

128 
delete
 [] 
val
;

129 
delete
 [] 
colind
;

130 
delete
 [] 
rowind
;

132 
Coord_Mat_double
 
	`C
(
maxrow
,
maxcol
,
count
, 
val
, 
rowind
, 
colind
);

133 *
A
 = 
C
;

136 
	}
}

139 void 
	$readtxtfile_mat
(const char *
filename
, 
CompCol_Mat_double
 *
A
)

141 
Coord_Mat_double
 
C
;

142 
	`readtxtfile_mat
(
filename
, &
C
);

143 *
A
 = 
C
;

145 
	}
}

147 void 
	$readtxtfile_mat
(const char *
filename
, 
CompRow_Mat_double
 *
A
)

149 
Coord_Mat_double
 
C
;

150 
	`readtxtfile_mat
(
filename
, &
C
);

151 *
A
 = 
C
;

153 
	}
}

155 void 
	$writetxtfile_mat
(const char *
filename
, const 
Coord_Mat_double
 &
A
)

171 
FILE
 *
out_file
;

172 
out_file
 = 
	`fopen
( 
filename
, "w");

174 int 
nnz
 = 
A
.
	`NumNonzeros
();

175 int 
rowp1
, 
colp1
;

176 int 
M
 = 
A
.
	`dim
(0);

177 int 
N
 = 
A
.
	`dim
(1);

178 int 
flag
 = 0;

180 for (int 
j
 = 0; j < 
nnz
 ; j++)

182 
rowp1
 = 
A
.
	`row_ind
(
j
) +1;

183 
colp1
 = 
A
.
	`col_ind
(
j
) +1;

184 if ( 
rowp1
 == 
M
 && 
colp1
 == 
N
 ) 
flag
 = 1;

185 
	`fprintf
(
out_file
, "%14d\t%14d\t%20.16e\n", 
rowp1
, 
colp1
,
A
.
	`val
(
j
));

187 if (
flag
 == 0)

188 
	`fprintf
(
out_file
, "%14d\t%14d\t%20.16e\n", 
M
, 
N
, 
	`A
(M-1,N-1));

189 
	`fclose
(
out_file
);

192 
	}
}

195 void 
	$writetxtfile_mat
(const char *
filename
, const 
CompCol_Mat_double
 &
A
)

197 
FILE
 *
out_file
;

198 
out_file
 = 
	`fopen
( 
filename
, "w");

200 int 
rowp1
, 
colp1
;

201 int 
M
 = 
A
.
	`dim
(0);

202 int 
N
 = 
A
.
	`dim
(1);

203 int 
flag
 = 0;

205 for (int 
j
 = 0; j < 
N
 ; j++)

206 for (int 
i
=
A
.
	`col_ptr
(
j
);i<A.col_ptr(j+1);i++)

208 
rowp1
 = 
A
.
	`row_ind
(
i
)+1;

209 
colp1
 = 
j
 + 1;

210 if ( 
rowp1
 == 
M
 && 
colp1
 == 
N
 ) 
flag
 = 1;

211 
	`fprintf
(
out_file
,"%14d%4s%14d%4s% 20.16E\n", 
rowp1
, " ",

212 
colp1
," ", 
A
.
	`val
(
i
));

215 if (
flag
 == 0)

216 
	`fprintf
(
out_file
,"%14d\t%14d\t%20.16E\n", 
M
, 
N
, 
	`A
(M-1,N-1));

218 
	`fclose
(
out_file
);

221 
	}
}

223 void 
	$writetxtfile_mat
(const char *
filename
, const 
CompRow_Mat_double
 &
A
)

225 
FILE
 *
out_file
;

226 
out_file
 = 
	`fopen
( 
filename
, "w");

228 int 
rowp1
, 
colp1
;

229 int 
M
 = 
A
.
	`dim
(0);

230 int 
N
 = 
A
.
	`dim
(1);

231 int 
flag
 = 0;

233 for (int 
i
 = 0; i < 
M
 ; i++)

234 for (int 
j
=
A
.
	`row_ptr
(
i
);j<A.row_ptr(i+1);j++)

236 
rowp1
 = 
i
 + 1;

237 
colp1
 = 
A
.
	`col_ind
(
j
) + 1;

238 if ( 
rowp1
 == 
M
 && 
colp1
 == 
N
 ) 
flag
 = 1;

239 
	`fprintf
(
out_file
,"%14d\t%14d\t%20.16e\n", 
rowp1
, 
colp1
,
A
.
	`val
(
j
));

242 if (
flag
 == 0)

243 
	`fprintf
(
out_file
,"%14d\t%14d\t%20.16e\n", 
M
, 
N
, 
	`A
(M-1,N-1));

245 
	`fclose
(
out_file
);

248 
	}
}

	@src/qsort_double.cc

35 #include 
	~"qsort_double.h
"

37 #ifdef 
sparc


38 #include 
	~<alloca.h
>

42 #define 
	#CMP
(
A
,
B
) ((A) < (B))

	)

46 static 
inline
 void 
	$SWAP_double
(double &
A
, double &
B
)

48 double 
tmp
 = 
A
; A = 
B
; B = tmp;

49 
	}
}

52 static 
inline
 void 
	$swap_int
(int &
a
, int &
b
)

54 int 
tmp
=
a
; a=
b
; b=tmp;

55 
	}
}

58 #define 
	#BYTES_PER_WORD
 8

	)

61 #define 
	#STACK_SIZE
 (
BYTES_PER_WORD
 * sizeof (long))

	)

62 #define 
	#PUSH
(
LOW
,
HIGH
) do {
top
->
lo
 = LOW;top++->
hi
 = HIGH;} while (0)

	)

63 #define 
	#POP
(
LOW
,
HIGH
) do {LOW = (--
top
)->
lo
;HIGH = top->
hi
;} while (0)

	)

64 #define 
	#STACK_NOT_EMPTY
 (
stack
 < 
top
)

	)

68 #define 
	#MAX_THRESH
 4

	)

72 int 
	mlo
;

73 int 
	mhi
;

74 } 
	tstack_node
;

100 int 
	$QSort
(
VECTOR_double
& 
v
, int 
base_ptr
, int 
total_elems
)

102 double 
pivot_buffer
;

104 if (
total_elems
 > 
MAX_THRESH
) {

106 int 
lo
 = 
base_ptr
;

107 int 
hi
 = 
lo
 + 
total_elems
 - 1;

109 
stack_node
 
stack
[
STACK_SIZE
];

110 
stack_node
 *
top
 = 
stack
 + 1;

112 while (
STACK_NOT_EMPTY
) {

113 int 
left_ptr
;

114 int 
right_ptr
;

124 int 
mid
 = 
lo
 + (
hi
 - lo) / 2;

126 if (
	`CMP
 (
v
[
mid
], v[
lo
]))

127 
	`SWAP_double
(
v
[
mid
], v[
lo
]);

128 if (
	`CMP
 (
v
[
hi
], v[
mid
]))

129 
	`SWAP_double
(
v
[
hi
], v[
mid
]);

131 goto 
jump_over
;

133 if (
	`CMP
 (
v
[
mid
], v[
lo
]))

134 
	`SWAP_double
(
v
[
mid
], v[
lo
]);

136 
jump_over
:

138 
pivot_buffer
 = 
v
[
mid
];

141 
left_ptr
 = 
lo
 + 1;

142 
right_ptr
 = 
hi
 - 1;

148 while (
	`CMP
 (
v
[
left_ptr
], 
pivot_buffer
))

149 
left_ptr
++;

151 while (
	`CMP
 (
pivot_buffer
, 
v
[
right_ptr
]))

152 
right_ptr
--;

154 if (
left_ptr
 < 
right_ptr
) {

155 
	`SWAP_double
(
v
[
left_ptr
], v[
right_ptr
]);

156 
left_ptr
++;

157 
right_ptr
--;

158 } else if (
left_ptr
 == 
right_ptr
) {

159 
left_ptr
 ++;

160 
right_ptr
 --;

163 } while (
left_ptr
 <= 
right_ptr
);

171 if ((
right_ptr
 - 
lo
) <= 
MAX_THRESH
) {

172 if ((
hi
 - 
left_ptr
) <= 
MAX_THRESH
)

173 
	`POP
 (
lo
, 
hi
);

175 
lo
 = 
left_ptr
;

176 } else if ((
hi
 - 
left_ptr
) <= 
MAX_THRESH
)

177 
hi
 = 
right_ptr
;

178 else if ((
right_ptr
 - 
lo
) > (
hi
 - 
left_ptr
)) {

179 
	`PUSH
 (
lo
, 
right_ptr
);

180 
lo
 = 
left_ptr
;

182 
	`PUSH
 (
left_ptr
, 
hi
);

183 
hi
 = 
right_ptr
;

194 #define 
	#MIN
(
X
,
Y
) ((X) < (Y) ? (X) : (Y))

	)

197 int 
end_ptr
 = 
base_ptr
 + 
total_elems
 - 1;

198 int 
run_ptr
;

199 int 
tmp_ptr
 = 
base_ptr
;

200 int 
thresh
 = 
	`MIN
 (
end_ptr
, 
base_ptr
 + 
MAX_THRESH
);

202 for (
run_ptr
 = 
tmp_ptr
 + 1; run_ptr <= 
thresh
; run_ptr++)

203 if (
	`CMP
 (
v
[
run_ptr
], v[
tmp_ptr
]))

204 
tmp_ptr
 = 
run_ptr
;

206 if (
tmp_ptr
 != 
base_ptr
)

207 
	`SWAP_double
(
v
[
tmp_ptr
], v[
base_ptr
]);

209 for (
run_ptr
 = 
base_ptr
 + 1; (
tmp_ptr
 = run_ptr += 1) <= 
end_ptr
;) {

211 while (
	`CMP
 (
v
[
run_ptr
], v[
tmp_ptr
 -= 1]))

214 if ((
tmp_ptr
 += 1) != 
run_ptr
) {

215 int 
trav
;

217 for (
trav
 = 
run_ptr
 + 1; --trav >= run_ptr;) {

218 double 
c
;

219 
c
 = 
v
[
trav
];

220 int 
hi
, 
lo
;

222 for (
hi
 = 
lo
 = 
trav
; (lo -= 1) >= 
tmp_ptr
; hi = lo)

223 
v
[
hi
] = v[
lo
];

224 
v
[
hi
] = 
c
;

231 
	}
}

234 int 
	$QSort
(
VECTOR_int
 & 
v
, 
VECTOR_double
& 
x
, int 
base_ptr
, int 
total_elems
)

236 int 
pivot_buffer
;

237 double 
pixot_buffer
;

239 if (
total_elems
 > 
MAX_THRESH
) {

241 int 
lo
 = 
base_ptr
;

242 int 
hi
 = 
lo
 + 
total_elems
 - 1;

244 
stack_node
 
stack
[
STACK_SIZE
];

245 
stack_node
 *
top
 = 
stack
 + 1;

247 while (
STACK_NOT_EMPTY
) {

248 int 
left_ptr
;

249 int 
right_ptr
;

259 int 
mid
 = 
lo
 + (
hi
 - lo) / 2;

261 if (
	`CMP
 (
v
[
mid
], v[
lo
])) {

262 
	`swap_int
 (
v
[
mid
], v[
lo
]);

263 
	`SWAP_double
 (
x
[
mid
], x[
lo
]);

265 if (
	`CMP
 (
v
[
hi
], v[
mid
])) {

266 
	`swap_int
 (
v
[
hi
], v[
mid
]);

267 
	`SWAP_double
 (
x
[
hi
], x[
mid
]);

269 goto 
jump_over
;

271 if (
	`CMP
 (
v
[
mid
], v[
lo
])) {

272 
	`swap_int
(
v
[
mid
], v[
lo
]);

273 
	`SWAP_double
 (
x
[
mid
], x[
lo
]);

276 
jump_over
:

278 
pivot_buffer
 = 
v
[
mid
];

279 
pixot_buffer
 = 
x
[
mid
];

282 
left_ptr
 = 
lo
 + 1;

283 
right_ptr
 = 
hi
 - 1;

289 while (
	`CMP
 (
v
[
left_ptr
], 
pivot_buffer
))

290 
left_ptr
++;

292 while (
	`CMP
 (
pivot_buffer
, 
v
[
right_ptr
]))

293 
right_ptr
--;

295 if (
left_ptr
 < 
right_ptr
) {

296 
	`swap_int
 (
v
[
left_ptr
], v[
right_ptr
]);

297 
	`SWAP_double
 (
x
[
left_ptr
], x[
right_ptr
]);

298 
left_ptr
++;

299 
right_ptr
--;

300 } else if (
left_ptr
 == 
right_ptr
) {

301 
left_ptr
 ++;

302 
right_ptr
 --;

305 } while (
left_ptr
 <= 
right_ptr
);

313 if ((
right_ptr
 - 
lo
) <= 
MAX_THRESH
) {

314 if ((
hi
 - 
left_ptr
) <= 
MAX_THRESH
)

315 
	`POP
 (
lo
, 
hi
);

317 
lo
 = 
left_ptr
;

318 } else if ((
hi
 - 
left_ptr
) <= 
MAX_THRESH
)

319 
hi
 = 
right_ptr
;

320 else if ((
right_ptr
 - 
lo
) > (
hi
 - 
left_ptr
)) {

321 
	`PUSH
 (
lo
, 
right_ptr
);

322 
lo
 = 
left_ptr
;

324 
	`PUSH
 (
left_ptr
, 
hi
);

325 
hi
 = 
right_ptr
;

336 #define 
	#MIN
(
X
,
Y
) ((X) < (Y) ? (X) : (Y))

	)

339 int 
end_ptr
 = 
base_ptr
 + 
total_elems
 - 1;

340 int 
run_ptr
;

341 int 
tmp_ptr
 = 
base_ptr
;

342 int 
thresh
 = 
	`MIN
 (
end_ptr
, 
base_ptr
 + 
MAX_THRESH
);

344 for (
run_ptr
 = 
tmp_ptr
 + 1; run_ptr <= 
thresh
; run_ptr++)

345 if (
	`CMP
 (
v
[
run_ptr
], v[
tmp_ptr
]))

346 
tmp_ptr
 = 
run_ptr
;

348 if (
tmp_ptr
 != 
base_ptr
) {

349 
	`swap_int
(
v
[
tmp_ptr
], v[
base_ptr
]);

350 
	`SWAP_double
 (
x
[
tmp_ptr
], x[
base_ptr
]);

353 for (
run_ptr
 = 
base_ptr
 + 1; (
tmp_ptr
 = run_ptr += 1) <= 
end_ptr
;) {

355 while (
	`CMP
 (
v
[
run_ptr
], v[
tmp_ptr
 -= 1]))

358 if ((
tmp_ptr
 += 1) != 
run_ptr
) {

359 int 
trav
;

361 for (
trav
 = 
run_ptr
 + 1; --trav >= run_ptr;) {

362 int 
c
;

363 double 
d
;

364 
c
 = 
v
[
trav
];

365 
d
 = 
x
[
trav
];

366 int 
hi
, 
lo
;

368 for (
hi
 = 
lo
 = 
trav
; (lo -= 1) >= 
tmp_ptr
; hi = lo) {

369 
v
[
hi
] = v[
lo
];

370 
x
[
hi
] = x[
lo
];

372 
v
[
hi
] = 
c
;

373 
x
[
hi
] = 
d
;

380 
	}
}

	@src/qsort_int.cc

35 #include 
	~"qsort_int.h
"

37 #ifdef 
sparc


38 #include 
	~<alloca.h
>

42 #define 
	#CMP
(
A
,
B
) ((A) < (B))

	)

46 static 
inline
 void 
	$SWAP_int
(int &
A
, int &
B
)

48 int 
tmp
 = 
A
; A = 
B
; B = tmp;

49 
	}
}

52 static 
inline
 void 
	$swap_int
(int &
a
, int &
b
)

54 int 
tmp
=
a
; a=
b
; b=tmp;

55 
	}
}

58 #define 
	#BYTES_PER_WORD
 8

	)

61 #define 
	#STACK_SIZE
 (
BYTES_PER_WORD
 * sizeof (long))

	)

62 #define 
	#PUSH
(
LOW
,
HIGH
) do {
top
->
lo
 = LOW;top++->
hi
 = HIGH;} while (0)

	)

63 #define 
	#POP
(
LOW
,
HIGH
) do {LOW = (--
top
)->
lo
;HIGH = top->
hi
;} while (0)

	)

64 #define 
	#STACK_NOT_EMPTY
 (
stack
 < 
top
)

	)

68 #define 
	#MAX_THRESH
 4

	)

72 int 
	mlo
;

73 int 
	mhi
;

74 } 
	tstack_node
;

100 int 
	$QSort
(
VECTOR_int
& 
v
, int 
base_ptr
, int 
total_elems
)

102 int 
pivot_buffer
;

104 if (
total_elems
 > 
MAX_THRESH
) {

106 int 
lo
 = 
base_ptr
;

107 int 
hi
 = 
lo
 + 
total_elems
 - 1;

109 
stack_node
 
stack
[
STACK_SIZE
];

110 
stack_node
 *
top
 = 
stack
 + 1;

112 while (
STACK_NOT_EMPTY
) {

113 int 
left_ptr
;

114 int 
right_ptr
;

124 int 
mid
 = 
lo
 + (
hi
 - lo) / 2;

126 if (
	`CMP
 (
v
[
mid
], v[
lo
]))

127 
	`SWAP_int
(
v
[
mid
], v[
lo
]);

128 if (
	`CMP
 (
v
[
hi
], v[
mid
]))

129 
	`SWAP_int
(
v
[
hi
], v[
mid
]);

131 goto 
jump_over
;

133 if (
	`CMP
 (
v
[
mid
], v[
lo
]))

134 
	`SWAP_int
(
v
[
mid
], v[
lo
]);

136 
jump_over
:

138 
pivot_buffer
 = 
v
[
mid
];

141 
left_ptr
 = 
lo
 + 1;

142 
right_ptr
 = 
hi
 - 1;

148 while (
	`CMP
 (
v
[
left_ptr
], 
pivot_buffer
))

149 
left_ptr
++;

151 while (
	`CMP
 (
pivot_buffer
, 
v
[
right_ptr
]))

152 
right_ptr
--;

154 if (
left_ptr
 < 
right_ptr
) {

155 
	`SWAP_int
(
v
[
left_ptr
], v[
right_ptr
]);

156 
left_ptr
++;

157 
right_ptr
--;

158 } else if (
left_ptr
 == 
right_ptr
) {

159 
left_ptr
 ++;

160 
right_ptr
 --;

163 } while (
left_ptr
 <= 
right_ptr
);

171 if ((
right_ptr
 - 
lo
) <= 
MAX_THRESH
) {

172 if ((
hi
 - 
left_ptr
) <= 
MAX_THRESH
)

173 
	`POP
 (
lo
, 
hi
);

175 
lo
 = 
left_ptr
;

176 } else if ((
hi
 - 
left_ptr
) <= 
MAX_THRESH
)

177 
hi
 = 
right_ptr
;

178 else if ((
right_ptr
 - 
lo
) > (
hi
 - 
left_ptr
)) {

179 
	`PUSH
 (
lo
, 
right_ptr
);

180 
lo
 = 
left_ptr
;

182 
	`PUSH
 (
left_ptr
, 
hi
);

183 
hi
 = 
right_ptr
;

194 #define 
	#MIN
(
X
,
Y
) ((X) < (Y) ? (X) : (Y))

	)

197 int 
end_ptr
 = 
base_ptr
 + 
total_elems
 - 1;

198 int 
run_ptr
;

199 int 
tmp_ptr
 = 
base_ptr
;

200 int 
thresh
 = 
	`MIN
 (
end_ptr
, 
base_ptr
 + 
MAX_THRESH
);

202 for (
run_ptr
 = 
tmp_ptr
 + 1; run_ptr <= 
thresh
; run_ptr++)

203 if (
	`CMP
 (
v
[
run_ptr
], v[
tmp_ptr
]))

204 
tmp_ptr
 = 
run_ptr
;

206 if (
tmp_ptr
 != 
base_ptr
)

207 
	`SWAP_int
(
v
[
tmp_ptr
], v[
base_ptr
]);

209 for (
run_ptr
 = 
base_ptr
 + 1; (
tmp_ptr
 = run_ptr += 1) <= 
end_ptr
;) {

211 while (
	`CMP
 (
v
[
run_ptr
], v[
tmp_ptr
 -= 1]))

214 if ((
tmp_ptr
 += 1) != 
run_ptr
) {

215 int 
trav
;

217 for (
trav
 = 
run_ptr
 + 1; --trav >= run_ptr;) {

218 int 
c
;

219 
c
 = 
v
[
trav
];

220 int 
hi
, 
lo
;

222 for (
hi
 = 
lo
 = 
trav
; (lo -= 1) >= 
tmp_ptr
; hi = lo)

223 
v
[
hi
] = v[
lo
];

224 
v
[
hi
] = 
c
;

231 
	}
}

234 int 
	$QSort
(
VECTOR_int
 & 
v
, VECTOR_int& 
x
, int 
base_ptr
, int 
total_elems
)

236 int 
pivot_buffer
;

237 int 
pixot_buffer
;

239 if (
total_elems
 > 
MAX_THRESH
) {

241 int 
lo
 = 
base_ptr
;

242 int 
hi
 = 
lo
 + 
total_elems
 - 1;

244 
stack_node
 
stack
[
STACK_SIZE
];

245 
stack_node
 *
top
 = 
stack
 + 1;

247 while (
STACK_NOT_EMPTY
) {

248 int 
left_ptr
;

249 int 
right_ptr
;

259 int 
mid
 = 
lo
 + (
hi
 - lo) / 2;

261 if (
	`CMP
 (
v
[
mid
], v[
lo
])) {

262 
	`swap_int
 (
v
[
mid
], v[
lo
]);

263 
	`SWAP_int
 (
x
[
mid
], x[
lo
]);

265 if (
	`CMP
 (
v
[
hi
], v[
mid
])) {

266 
	`swap_int
 (
v
[
hi
], v[
mid
]);

267 
	`SWAP_int
 (
x
[
hi
], x[
mid
]);

269 goto 
jump_over
;

271 if (
	`CMP
 (
v
[
mid
], v[
lo
])) {

272 
	`swap_int
(
v
[
mid
], v[
lo
]);

273 
	`SWAP_int
 (
x
[
mid
], x[
lo
]);

276 
jump_over
:

278 
pivot_buffer
 = 
v
[
mid
];

279 
pixot_buffer
 = 
x
[
mid
];

282 
left_ptr
 = 
lo
 + 1;

283 
right_ptr
 = 
hi
 - 1;

289 while (
	`CMP
 (
v
[
left_ptr
], 
pivot_buffer
))

290 
left_ptr
++;

292 while (
	`CMP
 (
pivot_buffer
, 
v
[
right_ptr
]))

293 
right_ptr
--;

295 if (
left_ptr
 < 
right_ptr
) {

296 
	`swap_int
 (
v
[
left_ptr
], v[
right_ptr
]);

297 
	`SWAP_int
 (
x
[
left_ptr
], x[
right_ptr
]);

298 
left_ptr
++;

299 
right_ptr
--;

300 } else if (
left_ptr
 == 
right_ptr
) {

301 
left_ptr
 ++;

302 
right_ptr
 --;

305 } while (
left_ptr
 <= 
right_ptr
);

313 if ((
right_ptr
 - 
lo
) <= 
MAX_THRESH
) {

314 if ((
hi
 - 
left_ptr
) <= 
MAX_THRESH
)

315 
	`POP
 (
lo
, 
hi
);

317 
lo
 = 
left_ptr
;

318 } else if ((
hi
 - 
left_ptr
) <= 
MAX_THRESH
)

319 
hi
 = 
right_ptr
;

320 else if ((
right_ptr
 - 
lo
) > (
hi
 - 
left_ptr
)) {

321 
	`PUSH
 (
lo
, 
right_ptr
);

322 
lo
 = 
left_ptr
;

324 
	`PUSH
 (
left_ptr
, 
hi
);

325 
hi
 = 
right_ptr
;

336 #define 
	#MIN
(
X
,
Y
) ((X) < (Y) ? (X) : (Y))

	)

339 int 
end_ptr
 = 
base_ptr
 + 
total_elems
 - 1;

340 int 
run_ptr
;

341 int 
tmp_ptr
 = 
base_ptr
;

342 int 
thresh
 = 
	`MIN
 (
end_ptr
, 
base_ptr
 + 
MAX_THRESH
);

344 for (
run_ptr
 = 
tmp_ptr
 + 1; run_ptr <= 
thresh
; run_ptr++)

345 if (
	`CMP
 (
v
[
run_ptr
], v[
tmp_ptr
]))

346 
tmp_ptr
 = 
run_ptr
;

348 if (
tmp_ptr
 != 
base_ptr
) {

349 
	`swap_int
(
v
[
tmp_ptr
], v[
base_ptr
]);

350 
	`SWAP_int
 (
x
[
tmp_ptr
], x[
base_ptr
]);

353 for (
run_ptr
 = 
base_ptr
 + 1; (
tmp_ptr
 = run_ptr += 1) <= 
end_ptr
;) {

355 while (
	`CMP
 (
v
[
run_ptr
], v[
tmp_ptr
 -= 1]))

358 if ((
tmp_ptr
 += 1) != 
run_ptr
) {

359 int 
trav
;

361 for (
trav
 = 
run_ptr
 + 1; --trav >= run_ptr;) {

362 int 
c
;

363 int 
d
;

364 
c
 = 
v
[
trav
];

365 
d
 = 
x
[
trav
];

366 int 
hi
, 
lo
;

368 for (
hi
 = 
lo
 = 
trav
; (lo -= 1) >= 
tmp_ptr
; hi = lo) {

369 
v
[
hi
] = v[
lo
];

370 
x
[
hi
] = x[
lo
];

372 
v
[
hi
] = 
c
;

373 
x
[
hi
] = 
d
;

380 
	}
}

	@src/qsort_type.cc

35 #include 
	~"qsort_TYPE.h
"

37 #ifdef 
sparc


38 #include 
	~<alloca.h
>

42 #define 
	#CMP
(
A
,
B
) ((A) < (B))

	)

46 static 
inline
 void 
	$SWAP_TYPE
(
TYPE
 &
A
, TYPE &
B
)

48 
TYPE
 
tmp
 = 
A
; A = 
B
; B = tmp;

49 
	}
}

52 static 
inline
 void 
	$swap_int
(int &
a
, int &
b
)

54 int 
tmp
=
a
; a=
b
; b=tmp;

55 
	}
}

58 #define 
	#BYTES_PER_WORD
 8

	)

61 #define 
	#STACK_SIZE
 (
BYTES_PER_WORD
 * sizeof (long))

	)

62 #define 
	#PUSH
(
LOW
,
HIGH
) do {
top
->
lo
 = LOW;top++->
hi
 = HIGH;} while (0)

	)

63 #define 
	#POP
(
LOW
,
HIGH
) do {LOW = (--
top
)->
lo
;HIGH = top->
hi
;} while (0)

	)

64 #define 
	#STACK_NOT_EMPTY
 (
stack
 < 
top
)

	)

68 #define 
	#MAX_THRESH
 4

	)

72 int 
	mlo
;

73 int 
	mhi
;

74 } 
	tstack_node
;

100 int 
	$QSort
(
VECTOR_TYPE
& 
v
, int 
base_ptr
, int 
total_elems
)

102 
TYPE
 
pivot_buffer
;

104 if (
total_elems
 > 
MAX_THRESH
) {

106 int 
lo
 = 
base_ptr
;

107 int 
hi
 = 
lo
 + 
total_elems
 - 1;

109 
stack_node
 
stack
[
STACK_SIZE
];

110 
stack_node
 *
top
 = 
stack
 + 1;

112 while (
STACK_NOT_EMPTY
) {

113 int 
left_ptr
;

114 int 
right_ptr
;

124 int 
mid
 = 
lo
 + (
hi
 - lo) / 2;

126 if (
	`CMP
 (
v
[
mid
], v[
lo
]))

127 
	`SWAP_TYPE
(
v
[
mid
], v[
lo
]);

128 if (
	`CMP
 (
v
[
hi
], v[
mid
]))

129 
	`SWAP_TYPE
(
v
[
hi
], v[
mid
]);

131 goto 
jump_over
;

133 if (
	`CMP
 (
v
[
mid
], v[
lo
]))

134 
	`SWAP_TYPE
(
v
[
mid
], v[
lo
]);

136 
jump_over
:

138 
pivot_buffer
 = 
v
[
mid
];

141 
left_ptr
 = 
lo
 + 1;

142 
right_ptr
 = 
hi
 - 1;

148 while (
	`CMP
 (
v
[
left_ptr
], 
pivot_buffer
))

149 
left_ptr
++;

151 while (
	`CMP
 (
pivot_buffer
, 
v
[
right_ptr
]))

152 
right_ptr
--;

154 if (
left_ptr
 < 
right_ptr
) {

155 
	`SWAP_TYPE
(
v
[
left_ptr
], v[
right_ptr
]);

156 
left_ptr
++;

157 
right_ptr
--;

158 } else if (
left_ptr
 == 
right_ptr
) {

159 
left_ptr
 ++;

160 
right_ptr
 --;

163 } while (
left_ptr
 <= 
right_ptr
);

171 if ((
right_ptr
 - 
lo
) <= 
MAX_THRESH
) {

172 if ((
hi
 - 
left_ptr
) <= 
MAX_THRESH
)

173 
	`POP
 (
lo
, 
hi
);

175 
lo
 = 
left_ptr
;

176 } else if ((
hi
 - 
left_ptr
) <= 
MAX_THRESH
)

177 
hi
 = 
right_ptr
;

178 else if ((
right_ptr
 - 
lo
) > (
hi
 - 
left_ptr
)) {

179 
	`PUSH
 (
lo
, 
right_ptr
);

180 
lo
 = 
left_ptr
;

182 
	`PUSH
 (
left_ptr
, 
hi
);

183 
hi
 = 
right_ptr
;

194 #define 
	#MIN
(
X
,
Y
) ((X) < (Y) ? (X) : (Y))

	)

197 int 
end_ptr
 = 
base_ptr
 + 
total_elems
 - 1;

198 int 
run_ptr
;

199 int 
tmp_ptr
 = 
base_ptr
;

200 int 
thresh
 = 
	`MIN
 (
end_ptr
, 
base_ptr
 + 
MAX_THRESH
);

202 for (
run_ptr
 = 
tmp_ptr
 + 1; run_ptr <= 
thresh
; run_ptr++)

203 if (
	`CMP
 (
v
[
run_ptr
], v[
tmp_ptr
]))

204 
tmp_ptr
 = 
run_ptr
;

206 if (
tmp_ptr
 != 
base_ptr
)

207 
	`SWAP_TYPE
(
v
[
tmp_ptr
], v[
base_ptr
]);

209 for (
run_ptr
 = 
base_ptr
 + 1; (
tmp_ptr
 = run_ptr += 1) <= 
end_ptr
;) {

211 while (
	`CMP
 (
v
[
run_ptr
], v[
tmp_ptr
 -= 1]))

214 if ((
tmp_ptr
 += 1) != 
run_ptr
) {

215 int 
trav
;

217 for (
trav
 = 
run_ptr
 + 1; --trav >= run_ptr;) {

218 
TYPE
 
c
;

219 
c
 = 
v
[
trav
];

220 int 
hi
, 
lo
;

222 for (
hi
 = 
lo
 = 
trav
; (lo -= 1) >= 
tmp_ptr
; hi = lo)

223 
v
[
hi
] = v[
lo
];

224 
v
[
hi
] = 
c
;

231 
	}
}

234 int 
	$QSort
(
VECTOR_int
 & 
v
, 
VECTOR_TYPE
& 
x
, int 
base_ptr
, int 
total_elems
)

236 int 
pivot_buffer
;

237 
TYPE
 
pixot_buffer
;

239 if (
total_elems
 > 
MAX_THRESH
) {

241 int 
lo
 = 
base_ptr
;

242 int 
hi
 = 
lo
 + 
total_elems
 - 1;

244 
stack_node
 
stack
[
STACK_SIZE
];

245 
stack_node
 *
top
 = 
stack
 + 1;

247 while (
STACK_NOT_EMPTY
) {

248 int 
left_ptr
;

249 int 
right_ptr
;

259 int 
mid
 = 
lo
 + (
hi
 - lo) / 2;

261 if (
	`CMP
 (
v
[
mid
], v[
lo
])) {

262 
	`swap_int
 (
v
[
mid
], v[
lo
]);

263 
	`SWAP_TYPE
 (
x
[
mid
], x[
lo
]);

265 if (
	`CMP
 (
v
[
hi
], v[
mid
])) {

266 
	`swap_int
 (
v
[
hi
], v[
mid
]);

267 
	`SWAP_TYPE
 (
x
[
hi
], x[
mid
]);

269 goto 
jump_over
;

271 if (
	`CMP
 (
v
[
mid
], v[
lo
])) {

272 
	`swap_int
(
v
[
mid
], v[
lo
]);

273 
	`SWAP_TYPE
 (
x
[
mid
], x[
lo
]);

276 
jump_over
:

278 
pivot_buffer
 = 
v
[
mid
];

279 
pixot_buffer
 = 
x
[
mid
];

282 
left_ptr
 = 
lo
 + 1;

283 
right_ptr
 = 
hi
 - 1;

289 while (
	`CMP
 (
v
[
left_ptr
], 
pivot_buffer
))

290 
left_ptr
++;

292 while (
	`CMP
 (
pivot_buffer
, 
v
[
right_ptr
]))

293 
right_ptr
--;

295 if (
left_ptr
 < 
right_ptr
) {

296 
	`swap_int
 (
v
[
left_ptr
], v[
right_ptr
]);

297 
	`SWAP_TYPE
 (
x
[
left_ptr
], x[
right_ptr
]);

298 
left_ptr
++;

299 
right_ptr
--;

300 } else if (
left_ptr
 == 
right_ptr
) {

301 
left_ptr
 ++;

302 
right_ptr
 --;

305 } while (
left_ptr
 <= 
right_ptr
);

313 if ((
right_ptr
 - 
lo
) <= 
MAX_THRESH
) {

314 if ((
hi
 - 
left_ptr
) <= 
MAX_THRESH
)

315 
	`POP
 (
lo
, 
hi
);

317 
lo
 = 
left_ptr
;

318 } else if ((
hi
 - 
left_ptr
) <= 
MAX_THRESH
)

319 
hi
 = 
right_ptr
;

320 else if ((
right_ptr
 - 
lo
) > (
hi
 - 
left_ptr
)) {

321 
	`PUSH
 (
lo
, 
right_ptr
);

322 
lo
 = 
left_ptr
;

324 
	`PUSH
 (
left_ptr
, 
hi
);

325 
hi
 = 
right_ptr
;

336 #define 
	#MIN
(
X
,
Y
) ((X) < (Y) ? (X) : (Y))

	)

339 int 
end_ptr
 = 
base_ptr
 + 
total_elems
 - 1;

340 int 
run_ptr
;

341 int 
tmp_ptr
 = 
base_ptr
;

342 int 
thresh
 = 
	`MIN
 (
end_ptr
, 
base_ptr
 + 
MAX_THRESH
);

344 for (
run_ptr
 = 
tmp_ptr
 + 1; run_ptr <= 
thresh
; run_ptr++)

345 if (
	`CMP
 (
v
[
run_ptr
], v[
tmp_ptr
]))

346 
tmp_ptr
 = 
run_ptr
;

348 if (
tmp_ptr
 != 
base_ptr
) {

349 
	`swap_int
(
v
[
tmp_ptr
], v[
base_ptr
]);

350 
	`SWAP_TYPE
 (
x
[
tmp_ptr
], x[
base_ptr
]);

353 for (
run_ptr
 = 
base_ptr
 + 1; (
tmp_ptr
 = run_ptr += 1) <= 
end_ptr
;) {

355 while (
	`CMP
 (
v
[
run_ptr
], v[
tmp_ptr
 -= 1]))

358 if ((
tmp_ptr
 += 1) != 
run_ptr
) {

359 int 
trav
;

361 for (
trav
 = 
run_ptr
 + 1; --trav >= run_ptr;) {

362 int 
c
;

363 
TYPE
 
d
;

364 
c
 = 
v
[
trav
];

365 
d
 = 
x
[
trav
];

366 int 
hi
, 
lo
;

368 for (
hi
 = 
lo
 = 
trav
; (lo -= 1) >= 
tmp_ptr
; hi = lo) {

369 
v
[
hi
] = v[
lo
];

370 
x
[
hi
] = x[
lo
];

372 
v
[
hi
] = 
c
;

373 
x
[
hi
] = 
d
;

380 
	}
}

	@testing/td.cc

1 #include 
	~<stdio.h
>

2 #include 
	~<stdlib.h
>

3 #include 
	~<iostream
>

4 #include 
	~<sstream
>

6 struct 
	sduo
 {

7 long 
	mhigher
;

8 long 
	mlower
;

11 struct 
duo
 
	gresult
;

13 struct 
duo
* 
	$duoDiff
(long 
firstHigher
, long 
firstLower
, long 
secondHigher
, long 
secondLower
, long 
base
)

15 long 
h
 = 
firstHigher
 - 
secondHigher
;

16 long 
l
 = 
firstLower
 - 
secondLower
;

17 if (
h
 < 0)

18 return 
NULL
;

19 if (
l
 < 0) {

20 
l
 += 
base
;

21 --
h
;

23 
result
.
higher
 = 
h
;

24 
result
.
lower
 = 
l
;

25 return &
result
;

26 
	}
}

28 
	gstd
::
stringstream
 
decimalString
;

30 
	gstd
::
string
 
	$decimalFormat
(long 
number
, long 
base
)

32 
decimalString
.
	`str
("");

33 
decimalString
 << ".";

35 while (
number
 > 0) {

36 
number
 *= 10;

37 
decimalString
 << 
number
 / 
base
;

38 
number
 %= 
base
;

41 return 
decimalString
.
	`str
();

42 
	}
}

44 void 
	$printTimespec
(struct 
timespec
& 
ts_start
, struct timespec& 
ts_stop
, char* 
app
)

46 struct 
duo
* 
timeDuo
 = 
	`duoDiff
((long) 
ts_stop
.
tv_sec
, ts_stop.
tv_nsec
,

47 (long) 
ts_start
.
tv_sec
, ts_start.
tv_nsec
,

49 
time_t
 
elapsed_sec
 = (time_t) 
timeDuo
->
higher
;

50 long 
elapsed_nsec
 = 
timeDuo
->
lower
;

52 
std
::
cout
 << "Time " << 
app
 << ": "

53 << 
elapsed_sec
 << 
	`decimalFormat
(
elapsed_nsec
, 1000000000) << 
std
::
endl
;

54 
	}
}

57 
	$main
(int 
argc
, char** 
argv
)

59 struct 
timespec
 
ts_start
, 
ts_stop
;

60 
FILE
* 
file
;

61 int 
i
, 
j
, 
index
;

62 double 
v
;

63 char 
s
[256];

64 char 
buf
[256];

65 int 
xdim
 = 
	`atoi
(
argv
[1]);

66 int 
ydim
 = 
	`atoi
(
argv
[2]);

67 double** 
A
;

68 double* 
x
;

69 double* 
y
;

70 double* 
Ax
;

71 double* 
Aty
;

72 double* 
result_Ax
;

73 double* 
result_Aty
;

76 
A
 = 
new
 double* [
xdim
];

77 
x
 = 
new
 double [
ydim
];

78 
y
 = 
new
 double [
xdim
];

79 
Ax
 = 
new
 double [
xdim
];

80 
Aty
 = 
new
 double [
ydim
];

81 
result_Ax
 = 
new
 double[
xdim
];

82 
result_Aty
 = 
new
 double[
ydim
];

84 for (
i
=0; i<
xdim
; ++i)

85 
A
[
i
] = 
new
 double [
ydim
];

87 for (
i
=0; i<
xdim
; ++i)

88 for (
j
=0; j<
ydim
; ++j)

89 
A
[
i
][
j
] = 0;

92 
file
 = 
	`fopen
(
argv
[3], "r");

93 while (
	`fgets
(
buf
, sizeof(buf), 
file
) != 
NULL
) {

94 
	`sscanf
(
buf
, "%8d%8d%s\n", &
i
, &
j
, 
s
);

95 
v
 = 
	`atof
(
s
);

96 
A
[
i
-1][
j
-1] = 
v
;

98 
	`fclose
(
file
);

100 
index
 = 0;

101 
file
 = 
	`fopen
(
argv
[4], "r");

102 while (
	`fgets
(
buf
, sizeof(buf), 
file
) != 
NULL
) {

103 
v
 = 
	`atof
(
buf
);

104 
x
[
index
++] = 
v
;

106 
	`fclose
(
file
);

108 
index
 = 0;

109 
file
 = 
	`fopen
(
argv
[5], "r");

110 while (
	`fgets
(
buf
, sizeof(buf), 
file
) != 
NULL
) {

111 
v
 = 
	`atof
(
buf
);

112 
y
[
index
++] = 
v
;

114 
	`fclose
(
file
);

116 
index
 = 0;

117 
file
 = 
	`fopen
(
argv
[6], "r");

118 while (
	`fgets
(
buf
, sizeof(buf), 
file
) != 
NULL
) {

119 
v
 = 
	`atof
(
buf
);

120 
Ax
[
index
++] = 
v
;

122 
	`fclose
(
file
);

124 
index
 = 0;

125 
file
 = 
	`fopen
(
argv
[7], "r");

126 while (
	`fgets
(
buf
, sizeof(buf), 
file
) != 
NULL
) {

127 
v
 = 
	`atof
(
buf
);

128 
Aty
[
index
++] = 
v
;

130 
	`fclose
(
file
);

132 for (
i
=0; i<
xdim
; ++i) {

133 
result_Ax
[
i
] = 0;

134 for (
j
=0; j<
ydim
; ++j)

135 
result_Ax
[
i
] += 
A
[i][
j
] * 
x
[j];

138 for (
i
=0; i<
ydim
; ++i) {

139 
result_Aty
[
i
] = 0;

140 for (
j
=0; j<
xdim
; ++j)

141 
result_Aty
[
i
] += 
A
[
j
][i] * 
y
[j];

145 
	`clock_gettime
(
CLOCK_PROCESS_CPUTIME_ID
, &
ts_start
);

147 for (int 
repeat
=0; repeat<100000; ++repeat) {

148 for (
i
=0; i<
xdim
; ++i)

149 for (
j
=0; j<
ydim
; ++j)

150 
A
[
i
][
j
] = 0;

153 
file
 = 
	`fopen
(
argv
[3], "r");

154 while (
	`fgets
(
buf
, sizeof(buf), 
file
) != 
NULL
) {

155 
	`sscanf
(
buf
, "%8d%8d%s\n", &
i
, &
j
, 
s
);

156 
v
 = 
	`atof
(
s
);

157 
A
[
i
-1][
j
-1] = 
v
;

159 
	`fclose
(
file
);

161 
index
 = 0;

162 
file
 = 
	`fopen
(
argv
[4], "r");

163 while (
	`fgets
(
buf
, sizeof(buf), 
file
) != 
NULL
) {

164 
v
 = 
	`atof
(
buf
);

165 
x
[
index
++] = 
v
;

167 
	`fclose
(
file
);

169 
index
 = 0;

170 
file
 = 
	`fopen
(
argv
[5], "r");

171 while (
	`fgets
(
buf
, sizeof(buf), 
file
) != 
NULL
) {

172 
v
 = 
	`atof
(
buf
);

173 
y
[
index
++] = 
v
;

175 
	`fclose
(
file
);

177 
index
 = 0;

178 
file
 = 
	`fopen
(
argv
[6], "r");

179 while (
	`fgets
(
buf
, sizeof(buf), 
file
) != 
NULL
) {

180 
v
 = 
	`atof
(
buf
);

181 
Ax
[
index
++] = 
v
;

183 
	`fclose
(
file
);

185 
index
 = 0;

186 
file
 = 
	`fopen
(
argv
[7], "r");

187 while (
	`fgets
(
buf
, sizeof(buf), 
file
) != 
NULL
) {

188 
v
 = 
	`atof
(
buf
);

189 
Aty
[
index
++] = 
v
;

191 
	`fclose
(
file
);

193 for (
i
=0; i<
xdim
; ++i) {

194 
result_Ax
[
i
] = 0;

195 for (
j
=0; j<
ydim
; ++j)

196 
result_Ax
[
i
] += 
A
[i][
j
] * 
x
[j];

199 for (
i
=0; i<
ydim
; ++i) {

200 
result_Aty
[
i
] = 0;

201 for (
j
=0; j<
xdim
; ++j)

202 
result_Aty
[
i
] += 
A
[
j
][i] * 
y
[j];

206 
	`clock_gettime
(
CLOCK_PROCESS_CPUTIME_ID
, &
ts_stop
);

207 
	`printTimespec
(
ts_start
, 
ts_stop
, 
argv
[0]);

209 for (
i
=0; i<
xdim
; ++i) {

210 if (
result_Ax
[
i
] - 
Ax
[i] > 1e-12) {

211 
	`printf
("Error in computing Ax[%d]: result_Ax = %.16f, Ax = %.16f\n", 
i
, 
result_Ax
[i], 
Ax
[i]);

216 for (
i
=0; i<
ydim
; ++i) {

217 if (
result_Aty
[
i
] - 
Aty
[i] > 1e-12) {

218 
	`printf
("Error in computing Aty[%d]: result_Aty = %.16f, Aty = %.16f\n", 
i
, 
result_Aty
[i], 
Aty
[i]);

223 for (
i
=0; i<
xdim
; ++i)

224 
delete
[] 
A
[
i
];

225 
delete
[] 
A
;

226 
delete
[] 
x
;

227 
delete
[] 
y
;

228 
delete
[] 
Ax
;

229 
delete
[] 
Aty
;

230 
delete
[] 
result_Ax
;

231 
delete
[] 
result_Aty
;

234 
	}
}

	@testing/tpre.cc

31 #include 
	~<iostream
>

32 #include 
	~<stdlib.h
>

34 #include 
	~"compcol_double.h
"

35 #include 
	~"comprow_double.h
"

36 #include 
	~"ilupre_double.h
"

37 #include 
	~"icpre_double.h
"

38 #include 
	~"iohb_double.h
"

40 
using
 
namespace
 
	gstd
;

42 int 
	$main
(int 
argc
, char * 
argv
[])

44 if (
argc
 < 2) {

45 
cerr
 << "Usage: " << 
argv
[0] << " HBfile [-v]" << 
endl
;

46 
	`exit
(-1);

49 int 
verbose
 = 0;

50 int 
errcount
 = 0;

52 if (
argc
 > 2 ) {

53 if (
argv
[2][1] == 'v')

54 
verbose
 = 1;

56 
cerr
 << "Usage: " << 
argv
[0] << " HBfile [-v]" << 
endl
;

61 
CompCol_Mat_double
 
Ac
;

62 
CompRow_Mat_double
 
Ar
;

64 
	`readHB_mat
(
argv
[1], &
Ac
);

65 
Ar
 = 
Ac
;

67 int 
m
 = 
Ar
.
	`dim
(0), 
n
 = Ar.dim(1);

69 
VECTOR_double
 
	`b
(
n
), 
	`x
(
m
), 
	`c
(m);

71 for (int 
i
 = 0; i < 
m
; i++)

72 
	`x
(
i
) = i;

74 
b
 = 
Ar
 * 
x
;

76 
CompCol_ILUPreconditioner_double
 
	`Mc
(
Ac
);

77 
CompRow_ILUPreconditioner_double
 
	`Mr
(
Ar
);

78 
ICPreconditioner_double
 
	`cMc
(
Ac
);

79 
ICPreconditioner_double
 
	`cMr
(
Ar
);

81 if (
verbose
) 
cout
 << "Mc" << 
endl
;

82 
VECTOR_double
 
yc
 = 
Mc
.
	`solve
(
b
);

83 if (
verbose
) 
cout
 << "ILU yc-x " << 
	`norm
(
yc
-
x
)/norm(x) << 
endl
;

84 if (
	`norm
(
yc
-
x
)/norm(x) > 1.e-12) {

85 
errcount
++;

86 if (
verbose
) {

87 
cout
 << "x" << 
endl
 << 
x
 << endl;

88 
cout
 << "yc" << 
endl
 << 
yc
 << endl;

92 if (
verbose
) 
cout
 << "Mr" << 
endl
;

93 
VECTOR_double
 
yr
 = 
Mr
.
	`solve
(
b
);

94 if (
verbose
) 
cout
 << "ILU yr-x " << 
	`norm
(
yr
-
x
)/norm(x) << 
endl
;

95 if (
	`norm
(
yr
-
x
)/norm(x) > 1.e-12) {

96 
errcount
++;

97 if (
verbose
) {

98 
cout
 << "x" << 
endl
 << 
x
 << endl;

99 
cout
 << "yr" << 
endl
 << 
yr
 << endl;

103 if (
verbose
) 
cout
 << "cMc" << 
endl
;

104 
yc
 = 
cMc
.
	`solve
(
b
);

105 if (
verbose
) 
cout
 << "IC yc-x " << 
	`norm
(
yc
-
x
)/norm(x) << 
endl
;

106 if (
	`norm
(
yc
-
x
)/norm(x) > 1.e-12) {

107 
errcount
++;

108 if (
verbose
) {

109 
cout
 << "x" << 
endl
 << 
x
 << endl;

110 
cout
 << "yc" << 
endl
 << 
yc
 << endl;

114 if (
verbose
) 
cout
 << "cMr" << 
endl
;

115 
yr
 = 
cMr
.
	`solve
(
b
);

116 if (
verbose
) 
cout
 << "IC yr-x " << 
	`norm
(
yr
-
x
)/norm(x) << 
endl
;

117 if (
	`norm
(
yr
-
x
)/norm(x) > 1.e-12) {

118 
errcount
++;

119 if (
verbose
) {

120 
cout
 << "x" << 
endl
 << 
x
 << endl;

121 
cout
 << "yr" << 
endl
 << 
yr
 << endl;

126 
c
 = 
Ar
.
	`trans_mult
(
x
);

128 if (
	`norm
(
b
-
c
)/norm(b) > 1.e-14) {

129 
errcount
++;

130 if (
verbose
) {

131 
cout
 << "b" << 
endl
 << 
b
 << endl;

132 
cout
 << "c" << 
endl
 << 
c
 << endl;

136 if (
verbose
) 
cout
 << "Mc" << 
endl
;

137 
yc
 = 
Mc
.
	`trans_solve
(
b
);

138 if (
verbose
) 
cout
 << "ILU yc-x " << 
	`norm
(
yc
-
x
)/norm(x) << 
endl
;

139 if (
	`norm
(
yc
-
x
)/norm(x) > 1.e-12) {

140 
errcount
++;

141 if (
verbose
) {

142 
cout
 << "x" << 
endl
 << 
x
 << endl;

143 
cout
 << "yc" << 
endl
 << 
yc
 << endl;

147 if (
verbose
) 
cout
 << "Mr" << 
endl
;

148 
yr
 = 
Mr
.
	`trans_solve
(
b
);

149 if (
verbose
) 
cout
 << "ILU yr-x " << 
	`norm
(
yr
-
x
)/norm(x) << 
endl
;

150 if (
	`norm
(
yr
-
x
)/norm(x) > 1.e-12) {

151 
errcount
++;

152 if (
verbose
) {

153 
cout
 << "x" << 
endl
 << 
x
 << endl;

154 
cout
 << "yr" << 
endl
 << 
yr
 << endl;

158 if (
verbose
) 
cout
 << "cMc" << 
endl
;

159 
yc
 = 
cMc
.
	`trans_solve
(
b
);

160 if (
verbose
) 
cout
 << "IC yc-x " << 
	`norm
(
yc
-
x
)/norm(x) << 
endl
;

161 if (
	`norm
(
yc
-
x
)/norm(x) > 1.e-12) {

162 
errcount
++;

163 if (
verbose
) {

164 
cout
 << "x" << 
endl
 << 
x
 << endl;

165 
cout
 << "yc" << 
endl
 << 
yc
 << endl;

169 if (
verbose
) 
cout
 << "cMr" << 
endl
;

170 
yr
 = 
cMr
.
	`trans_solve
(
b
);

171 if (
verbose
) 
cout
 << "IC yr-x " << 
	`norm
(
yr
-
x
)/norm(x) << 
endl
;

172 if (
	`norm
(
yr
-
x
)/norm(x) > 1.e-12) {

173 
errcount
++;

174 if (
verbose
) {

175 
cout
 << "x" << 
endl
 << 
x
 << endl;

176 
cout
 << "yr" << 
endl
 << 
yr
 << endl;

180 if (
errcount
 > 0) {

181 
cout
 << "There were " << 
errcount
 << " errors" << 
endl
;

182 if (
verbose
 == 0) {

183 
cout
 << "Run again with -v to find out where" << 
endl
;

186 
cout
 << "++++++++++++++++++++++++++++++++++++++++++++++++++++++++" << 
endl
;

187 
cout
 << "+ Successful completion of testing for SparseLib++ +" << 
endl
;

188 
cout
 << "+ No errors detected in preconditioner routines. +" << 
endl
;

189 
cout
 << "++++++++++++++++++++++++++++++++++++++++++++++++++++++++" << 
endl
;

190 
cout
 << 
endl
 << endl;

193 return 
errcount
;

194 
	}
}

	@testing/tsl.cc

30 #include 
	~<iostream
>

31 #include 
	~<stdlib.h
>

33 #include 
	~"compcol_double.h
"

34 #include 
	~"comprow_double.h
"

35 #include 
	~"coord_double.h
"

36 #include 
	~"iohb_double.h
"

38 
using
 
namespace
 
	gstd
;

40 int 
	$main
(int 
argc
, char * 
argv
[])

43 if (
argc
 < 2)

45 
cerr
 << "Usage: " << 
argv
[0] << " HBfile [-v]" << 
endl
;

46 
	`exit
(-1);

48 int 
verbose
 = 0;

49 if (
argc
 > 2 )

51 if (
argv
[2][1] == 'v') 
verbose
 = 1;

54 
cerr
 << "Usage: " << 
argv
[0] << " HBfile [-v]" << 
endl
;

55 
	`exit
(-1);

62 if (
verbose
) 
cout
 << "Testing readHB functions:" << 
endl
 << endl;

63 
CompCol_Mat_double
 
A1
;

64 int 
M
, 
N
, 
nonzeros
, 
nrhs
;

65 
	`readHB_info
(
argv
[1], &
M
, &
N
, &
nonzeros
, &
nrhs
);

66 if (
verbose
)

68 
cout
 << "Return values from readHB_info:" << 
endl
;

69 
cout
 << "M = " << 
M
 << " N = " << 
N
 ;

70 
cout
 << " Nonzeros = " << 
nonzeros
 << " Nrhs = " << 
nrhs
 << 
endl
;

71 
cout
 << "Output from readHB_info in verbose mode: " << 
endl
;

72 
cout
 << "......................................................"<<
endl
;

73 
	`readHB_info
(
argv
[1], &
M
, &
N
, &
nonzeros
, &
nrhs
);

74 
cout
 << "......................................................"<<
endl


75 << 
endl
;

77 
cout
 << "Reading the matrix from " << 
argv
[1] << "..." << 
endl
;

79 
	`readHB_mat
(
argv
[1], &
A1
);

80 if ( 
nrhs
 > 0)

82 if (
verbose
)

83 
cout
 << "Reading a rhs from " << 
argv
[1] << "..." << 
endl
 << endl;

84 
VECTOR_double
 
	`b
(
N
);

85 
	`readHB_rhs
(
argv
[1], &
b
);

103 double 
val
[12] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0,

105 int 
colind
[12] = {0, 1, 4, 0, 1, 2, 1, 2, 4, 3, 0, 4};

106 int 
rowptr
[6] = { 0, 3, 6, 9,10, 12};

107 double 
rowsum
[5] = {6.0, 15.0, 24.0, 10.0, 23.0};

108 double 
colsum
[5] = {16.0, 14.0, 14.0, 10.0, 24.0};

110 
CompRow_Mat_double
 
	`R
(5,5,12,
val
,
rowptr
,
colind
);

112 if (
verbose
)

114 
cout
 << "Generated row-oriented matrix from data." << 
endl
;

115 
cout
 << "Converting: Row to Column... " << 
endl
;

117 
CompCol_Mat_double
 
	`C
(
R
);

118 if (
verbose
) 
cout
 << " Column to Coord... " << 
endl
;

119 
Coord_Mat_double
 
	`CO1
(
C
);

120 if (
verbose
) 
cout
 << " Coord to Row... " << 
endl
;

121 
CompRow_Mat_double
 
	`R2
(
CO1
);

123 double 
err
 = 0.0;

124 int 
i
,
j
;

125 for (
i
=0;i<5;i++)

126 for (
j
=0;j<5;j++)

127 if ( (
	`R2
(
i
,
j
) - 
	`R
(i,j)) < 0) 
err
 -= R2(i,j) - R(i,j);

128 else 
err
 += 
	`R2
(
i
,
j
) - 
	`R
(i,j);

130 if ( 
err
 > 1.e-8 )

132 
cout
 << "Error in conversions too high. Halting execution. " << 
endl
;

133 
	`exit
(1);

135 if (
verbose
)

137 
cout
 << "Accumulated error = " << 
err
 << " success. " << 
endl
;

138 
cout
 << "Reverse direction..." << 
endl
;

139 
cout
 << "Converting: Row to Coord... " << 
endl
;

142 
Coord_Mat_double
 
	`CO2
(
R
);

143 if (
verbose
) 
cout
 << " Coord to Column... " << 
endl
;

144 
CompCol_Mat_double
 
	`C2
(
CO2
);

145 if (
verbose
) 
cout
 << " Column to Row... " << 
endl
;

146 
CompRow_Mat_double
 
	`R3
(
C2
);

148 
err
 = 0.0;

149 for (
i
=0;i<5;i++)

150 for (
j
=0;j<5;j++)

151 if ( (
	`R3
(
i
,
j
) - 
	`R
(i,j)) < 0) 
err
 -= (R3(i,j) - R(i,j));

152 else 
err
 += (
	`R3
(
i
,
j
) - 
	`R
(i,j));

153 if ( 
err
 > 1.e-8 )

155 
cout
 << "Error in conversions too high. Halting execution. " << 
endl
;

156 
	`exit
(1);

158 if (
verbose
)

160 
cout
 << "Accumulated error = " << 
err
 << " success. " << 
endl
;

161 
cout
 << 
endl
;

162 
cout
 << "Testing sparse matrix - dense vector multiplies... " << 
endl
;

163 
cout
 << "Small test matrix: " << 
endl
;

166 
VECTOR_double
 
	`x
(5,0.0);

167 
VECTOR_double
 
	`v
(5,1.0);

169 if (
verbose
) 
cout
 << "Mat-vec (CompCol)... ";

170 
x
 = 
C
*
v
;

171 for (
i
=0;i<5;i++)

172 if (
	`x
(
i
) != 
rowsum
[i])

174 
cout
 << "Mat-vec (Compcol) error." <<
endl
;

175 
	`exit
(1);

177 if (
verbose
) 
cout
 << "success." << 
endl
;

179 
x
 = 0.0;

180 if (
verbose
) 
cout
 << "Mat-trans_mult-vec (CompCol)...";

181 
x
 = 
C
.
	`trans_mult
(
v
);

182 for (
i
=0;i<5;i++)

183 if (
	`x
(
i
) != 
colsum
[i])

185 
cout
 << "Mat-trans_mult-vec (CompCol) error." <<
endl
;

186 
	`exit
(1);

188 if (
verbose
) 
cout
 << "success." << 
endl
;

190 
x
 = 0.0;

191 if (
verbose
) 
cout
 << "Mat-vec (CompRow)... ";

192 
x
 = 
R
*
v
;

193 for (
i
=0;i<5;i++)

194 if (
	`x
(
i
) != 
rowsum
[i])

196 
cout
 << "Mat-vec (CompRow) error." <<
endl
;

197 
	`exit
(1);

199 if (
verbose
) 
cout
 << "success." << 
endl
;

201 
x
 = 0.0;

202 if (
verbose
) 
cout
 << "Mat-trans_mult-vec (CompRow)...";

203 
x
 = 
R
.
	`trans_mult
(
v
);

204 for (
i
=0;i<5;i++)

205 if (
	`x
(
i
) != 
colsum
[i])

207 
cout
 << "Mat-trans_mult-vec (CompRow) error." <<
endl
;

208 
	`exit
(1);

210 if (
verbose
) 
cout
 << "success." << 
endl
;

212 
x
 = 0.0;

213 if (
verbose
) 
cout
 << "Mat-vec (Coord)... ";

214 
x
 = 
CO1
*
v
;

215 for (
i
=0;i<5;i++)

216 if (
	`x
(
i
) != 
rowsum
[i])

218 
cout
 << "Mat-vec (Coord) error." <<
endl
;

219 
	`exit
(1);

221 if (
verbose
) 
cout
 << "success." << 
endl
;

223 
x
 = 0.0;

224 if (
verbose
) 
cout
 << "Mat-trans_mult-vec (Coord)... ";

225 
x
 = 
CO1
.
	`trans_mult
(
v
);

226 for (
i
=0;i<5;i++)

227 if (
	`x
(
i
) != 
colsum
[i])

229 
cout
 << "Mat-trans_mult-vec (Coord) error." <<
endl
;

230 
	`exit
(1);

232 if (
verbose
)

234 
cout
 << "success." << 
endl
;

235 
cout
 << 
endl
;

236 
cout
 << "Testing sparse matrix - dense vector multiplies... " << 
endl
;

237 
cout
 << "Matrix from Harwell-Boeing file: " << 
endl
;

240 
VECTOR_double
 
	`x1
(
M
,0.0);

241 
VECTOR_double
 
	`v1
(
N
,1.0);

243 if (
verbose
) 
cout
 << "Mat-vec (CompCol)... "<< 
endl
;

244 
x1
= 
A1
*
v1
;

246 
VECTOR_double
 
	`x2
(
M
,0.0);

247 
CompRow_Mat_double
 
	`A2
(
A1
);

248 if (
verbose
) 
cout
 << "Mat-vec (CompRow)... "<< 
endl
;

249 
x2
 = 
A2
*
v1
;

251 
VECTOR_double
 
	`x3
(
M
,0.0);

252 
Coord_Mat_double
 
	`A3
(
A2
);

253 if (
verbose
) 
cout
 << "Mat-vec (Coord)... "<< 
endl
;

254 
x3
 = 
A3
*
v1
;

256 if (
verbose
) 
cout
 << "Comparing results... ";

258 
err
 = 0.0;

259 for (
i
=0;i<
M
;i++)

261 if ( (
	`x1
(
i
) - 
	`x2
(i)) < 0 ) 
err
 -= (x1(i) - x2(i));

262 else 
err
 += (
	`x1
(
i
) - 
	`x2
(i));

264 if ( 
err
 > 1.e-5 )

266 
cout
 << 
endl
 << "Error in Matvecs on HB generated matrix. " << endl;

267 
	`exit
(1);

270 
err
 = 0.0;

271 for (
i
=0;i<
M
;i++)

273 if ( (
	`x2
(
i
) - 
	`x3
(i)) < 0 ) 
err
 -= (x2(i) - x3(i));

274 else 
err
 += (
	`x2
(
i
) - 
	`x3
(i));

276 if ( 
err
 > 1.e-5 )

278 
cout
 << 
endl
 << "Error in Matvecs on HB generated matrix. " << endl;

279 
	`exit
(1);

281 if (
verbose
) 
cout
 << "success. " << 
endl
;

283 
v1
 = 0.0;

284 
x1
 = 1.0;

285 if (
verbose
) 
cout
 << "Mat-trans-vec (CompCol)... "<< 
endl
;

286 
v1
 = 
A1
.
	`trans_mult
(
x1
);

288 
VECTOR_double
 
	`v2
(
N
,0.0);

289 if (
verbose
) 
cout
 << "Mat-trans-vec (CompRow)... "<< 
endl
;

290 
v2
 = 
A2
.
	`trans_mult
(
x1
);

292 
VECTOR_double
 
	`v3
(
N
,0.0);

293 if (
verbose
) 
cout
 << "Mat-trans-vec (Coord)... "<< 
endl
;

294 
v3
 = 
A3
.
	`trans_mult
(
x1
);

296 if (
verbose
) 
cout
 << "Comparing results... ";

298 
err
 = 0.0;

299 for (
i
=0;i<
N
;i++)

301 if ( (
	`v1
(
i
) - 
	`v2
(i)) < 0 ) 
err
 -= (v1(i) - v2(i));

302 else 
err
 += (
	`v1
(
i
) - 
	`v2
(i));

304 if ( 
err
 > 1.e-5 )

306 
cout
 << 
endl
 << "Error in Mat-tran_mult-vecs on HB generated matrix. "

307 << 
endl
;

308 
	`exit
(1);

311 
err
 = 0.0;

312 for (
i
=0;i<
N
;i++)

314 if ( (
	`v2
(
i
) - 
	`v3
(i)) < 0 ) 
err
 -= (v2(i) - v3(i));

315 else 
err
 += (
	`v2
(
i
) - 
	`v3
(i));

317 if ( 
err
 > 1.e-5 )

319 
cout
 << 
endl
 << "Error in Mat-tran_mult-vecs on HB generated matrix. "

320 << 
endl
;

321 
	`exit
(1);

323 if (
verbose
) 
cout
 << "success. " << 
endl
;

325 
cout
 << 
endl
 << endl;

326 
cout
 << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++" << 
endl
;

327 
cout
 << "+ Successful completion of testing for SparseLib++ +" << 
endl
;

328 
cout
 << "+ No errors detected in conversion or blas routines. +" << 
endl
;

329 
cout
 << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++" << 
endl
;

330 
cout
 << 
endl
 << endl;

331 
	}
}

	@testing/tsp.cc

31 #include 
	~<iostream
>

32 #include 
	~<sstream
>

33 #include 
	~<stdlib.h
>

35 #include 
	~"compcol_double.h
"

36 #include 
	~"comprow_double.h
"

37 #include 
	~"ilupre_double.h
"

38 #include 
	~"icpre_double.h
"

39 #include 
	~"iotext_double.h
"

41 
using
 
namespace
 
	gstd
;

43 struct 
	sduo
 {

44 long 
	mhigher
;

45 long 
	mlower
;

48 struct 
duo
 
	gresult
;

50 struct 
duo
* 
	$duoDiff
(long 
firstHigher
, long 
firstLower
, long 
secondHigher
, long 
secondLower
, long 
base
)

52 long 
h
 = 
firstHigher
 - 
secondHigher
;

53 long 
l
 = 
firstLower
 - 
secondLower
;

54 if (
h
 < 0)

55 return 
NULL
;

56 if (
l
 < 0) {

57 
l
 += 
base
;

58 --
h
;

60 
result
.
higher
 = 
h
;

61 
result
.
lower
 = 
l
;

62 return &
result
;

63 
	}
}

65 
	gstd
::
stringstream
 
decimalString
;

67 
	gstd
::
string
 
	$decimalFormat
(long 
number
, long 
base
)

69 
decimalString
.
	`str
("");

70 
decimalString
 << ".";

72 while (
number
 > 0) {

73 
number
 *= 10;

74 
decimalString
 << 
number
 / 
base
;

75 
number
 %= 
base
;

78 return 
decimalString
.
	`str
();

79 
	}
}

81 void 
	$printTimespec
(struct 
timespec
& 
ts_start
, struct timespec& 
ts_stop
, char* 
app
)

83 struct 
duo
* 
timeDuo
 = 
	`duoDiff
((long) 
ts_stop
.
tv_sec
, ts_stop.
tv_nsec
,

84 (long) 
ts_start
.
tv_sec
, ts_start.
tv_nsec
,

86 
time_t
 
elapsed_sec
 = (time_t) 
timeDuo
->
higher
;

87 long 
elapsed_nsec
 = 
timeDuo
->
lower
;

89 
std
::
cout
 << "Time " << 
app
 << ": "

90 << 
elapsed_sec
 << 
	`decimalFormat
(
elapsed_nsec
, 1000000000) << 
std
::
endl
;

91 
	}
}

93 int 
	$main
(int 
argc
, char * 
argv
[])

95 struct 
timespec
 
ts_start
, 
ts_stop
;

97 if (
argc
 < 6) {

98 
cerr
 << "Usage: A x y A*x A'*y (filenames)" << 
endl
;

99 
	`exit
(-1);

102 int 
verbose
 = 0;

103 int 
errcount
 = 0;

105 if (
argc
 > 6 ) {

106 if (
argv
[6][1] == 'v')

107 
verbose
 = 1;

109 
cerr
 << "Usage: A x y A*x A'*y (filenames)" << 
endl
;

114 char *
A_name
 = 
argv
[1];

115 char *
x_name
 = 
argv
[2];

116 char *
y_name
 = 
argv
[3];

117 char *
Ax_name
 =
argv
[4];

118 char *
Aty_name
 = 
argv
[5];

120 
CompCol_Mat_double
 
Acol
;

121 
CompRow_Mat_double
 
Arow
;

122 
Coord_Mat_double
 
Acoord
;

124 
VECTOR_double
 
x
, 
y
;

125 
VECTOR_double
 
Ax
, 
Aty
;

128 
	`readtxtfile_mat
(
A_name
, &
Acoord
);

129 
Acol
 = 
Acoord
;

130 
Arow
 = 
Acol
;

132 
	`readtxtfile_vec
(
x_name
, &
x
);

133 
	`readtxtfile_vec
(
y_name
, &
y
);

134 
	`readtxtfile_vec
(
Ax_name
, &
Ax
);

135 
	`readtxtfile_vec
(
Aty_name
, &
Aty
);

137 if (
verbose
)

139 
cout
 << "Dimensons: " << 
endl
;

140 
cout
 << " A ("<< 
Acoord
.
	`dim
(0) << "," << Acoord.dim(1) << ") ";

141 
cout
 << " x: (" << 
x
.
	`size
() << ") y: (" << 
y
.size() << ")" << 
endl
;

142 
cout
 << " A*x: " << 
Ax
.
	`size
() << 
endl
;

143 
cout
 << " A'*y:" << 
Aty
.
	`size
() << 
endl
;

146 if (
	`norm
(
Ax
 - 
Acol
*
x
) > 1e-8 )

148 
errcount
++;

149 if (
verbose
) 
cout
 << "A*x failed. (col)\n";

152 if (
	`norm
(
Aty
 - 
Acol
.
	`trans_mult
(
y
)) > 1e-8)

154 
errcount
++;

155 if (
verbose
) 
cout
 << "A'*y failed. (col) \n";

158 if (
	`norm
(
Ax
 - 
Acoord
*
x
) > 1e-8)

160 
errcount
++;

161 if (
verbose
) 
cout
 << "A*x failed. (coord)\n";

164 if (
	`norm
(
Aty
 - 
Acoord
.
	`trans_mult
(
y
)) > 1e-8)

166 
errcount
++;

167 if (
verbose
) 
cout
 << "A'*y failed. (coord)\n";

170 if (
	`norm
(
Ax
 - 
Arow
*
x
) > 1e-8)

172 
errcount
++;

173 if (
verbose
) 
cout
 << "A*x failed (row).\n";

176 if (
	`norm
(
Aty
 - 
Arow
.
	`trans_mult
(
y
)) > 1e-8)

178 
errcount
++;

179 if (
verbose
) 
cout
 << "A'*y failed (row).\n";

204 
	`clock_gettime
(
CLOCK_PROCESS_CPUTIME_ID
, &
ts_start
);

206 for (int 
repeat
=0; repeat<100000; ++repeat) {

209 
	`readtxtfile_mat
(
A_name
, &
Acoord
);

210 
Acol
 = 
Acoord
;

211 
Arow
 = 
Acol
;

213 
	`readtxtfile_vec
(
x_name
, &
x
);

214 
	`readtxtfile_vec
(
y_name
, &
y
);

215 
	`readtxtfile_vec
(
Ax_name
, &
Ax
);

216 
	`readtxtfile_vec
(
Aty_name
, &
Aty
);

219 if (
verbose
)

221 
cout
 << "Dimensons: " << 
endl
;

222 
cout
 << " A ("<< 
Acoord
.
	`dim
(0) << "," << Acoord.dim(1) << ") ";

223 
cout
 << " x: (" << 
x
.
	`size
() << ") y: (" << 
y
.size() << ")" << 
endl
;

224 
cout
 << " A*x: " << 
Ax
.
	`size
() << 
endl
;

225 
cout
 << " A'*y:" << 
Aty
.
	`size
() << 
endl
;

228 if (
	`norm
(
Ax
 - 
Acol
*
x
) > 1e-8 )

230 
errcount
++;

231 if (
verbose
) 
cout
 << "A*x failed. (col)\n";

234 if (
	`norm
(
Aty
 - 
Acol
.
	`trans_mult
(
y
)) > 1e-8)

236 
errcount
++;

237 if (
verbose
) 
cout
 << "A'*y failed. (col) \n";

240 if (
	`norm
(
Ax
 - 
Acoord
*
x
) > 1e-8)

242 
errcount
++;

243 if (
verbose
) 
cout
 << "A*x failed. (coord)\n";

246 if (
	`norm
(
Aty
 - 
Acoord
.
	`trans_mult
(
y
)) > 1e-8)

248 
errcount
++;

249 if (
verbose
) 
cout
 << "A'*y failed. (coord)\n";

252 if (
	`norm
(
Ax
 - 
Arow
*
x
) > 1e-8)

254 
errcount
++;

255 if (
verbose
) 
cout
 << "A*x failed (row).\n";

258 if (
	`norm
(
Aty
 - 
Arow
.
	`trans_mult
(
y
)) > 1e-8)

260 
errcount
++;

261 if (
verbose
) 
cout
 << "A'*y failed (row).\n";

281 
	`clock_gettime
(
CLOCK_PROCESS_CPUTIME_ID
, &
ts_stop
);

282 
	`printTimespec
(
ts_start
, 
ts_stop
, 
argv
[0]);

285 return 
errcount
;

286 
	}
}

	@testing/tspsm.cc

31 #include 
	~<iostream
>

32 #include 
	~<stdlib.h
>

34 #include 
	~"compcol_double.h
"

35 #include 
	~"comprow_double.h
"

36 #include 
	~"ilupre_double.h
"

37 #include 
	~"icpre_double.h
"

38 #include 
	~"iohb_double.h
"

39 #include 
	~"spblas.h
"

41 
using
 
namespace
 
	gstd
;

43 int 
	$main
()

59 int 
verbose
 =0;

61 if (
verbose
) 
cout
 << "Testing Sparse BLAS" << 
endl
;

63 int 
errcount
 = 0;

65 double 
val
[] = {1.0, 4.0, 5.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0};

66 int 
colind
[] = {0, 0, 1, 1, 2, 2, 3, 0, 4 };

67 int 
rowptr
[] = {0, 1, 3, 5, 7, 9};

69 
CompRow_Mat_double
 
	`Ar
(5,5,9,
val
,
rowptr
,
colind
);

70 int 
m
 = 
Ar
.
	`dim
(0), 
n
 = Ar.dim(1);

72 
VECTOR_double
 
	`b
(
n
), 
	`x
(
m
), 
	`y
(m);

74 for (int 
i
 = 0; i < 
m
; i++)

75 
	`x
(
i
) = i;

77 
b
 = 
Ar
 * 
x
;

79 
CompCol_Mat_double
 
Ac
;

80 
Ac
 = 
Ar
;

82 int 
descra
[9];

83 
descra
[0] = 0;

86 
descra
[1] = 1;

87 
descra
[2] = 0;

89 
y
 = 
b
;

90 
	`F77NAME
(
dcsrsm
) (0, 
m
, 1, 1, 
NULL
, 1.0,

91 
descra
, 
val
, 
colind
, 
rowptr
,

92 &
	`y
(0), 
m
, 0.0, &y(1), m,

93 
NULL
, 0);

95 if (
verbose
) 
cout
 << "CSRSM y-x " << 
	`norm
(
y
-
x
) << 
endl
;

97 if (
	`norm
(
y
-
x
) > 1.e-12) {

98 
errcount
++;

99 if (
verbose
) {

100 
cout
 << "b" << 
endl
 << 
b
 << endl;

101 
cout
 << "x" << 
endl
 << 
x
 << endl;

102 
cout
 << "y" << 
endl
 << 
y
 << endl;

107 
descra
[1] = 2;

108 
descra
[2] = 0;

110 
y
 = 
b
;

111 
	`F77NAME
(
dcscsm
) (1, 
m
, 1, 1, 
NULL
, 1.0,

112 
descra
, 
val
, 
colind
, 
rowptr
,

113 &
	`y
(0), 
m
, 0.0, &y(1), m,

114 
NULL
, 0);

116 if (
verbose
) 
cout
 << "CSCSM y-x " << 
	`norm
(
y
-
x
) << 
endl
;

118 if (
	`norm
(
y
-
x
) > 1.e-12) {

119 
errcount
++;

120 if (
verbose
) {

121 
cout
 << "b" << 
endl
 << 
b
 << endl;

122 
cout
 << "x" << 
endl
 << 
x
 << endl;

123 
cout
 << "y" << 
endl
 << 
y
 << endl;

127 
y
 = 
b
;

128 
	`F77NAME
(
dcsrsm
) (1, 
m
, 1, 1, 
NULL
, 1.0,

129 
descra
, &
Ac
.
	`val
(0), &Ac.
	`row_ind
(0), &Ac.
	`col_ptr
(0),

130 &
	`y
(0), 
m
, 0.0, &y(1), m,

131 
NULL
, 0);

133 if (
verbose
) 
cout
 << "CSRSM y-x " << 
	`norm
(
y
-
x
) << 
endl
;

135 if (
	`norm
(
y
-
x
) > 1.e-12) {

136 
errcount
++;

137 if (
verbose
) {

138 
cout
 << "b" << 
endl
 << 
b
 << endl;

139 
cout
 << "x" << 
endl
 << 
x
 << endl;

140 
cout
 << "y" << 
endl
 << 
y
 << endl;

145 
descra
[1] = 1;

146 
descra
[2] = 0;

148 
y
 = 
b
;

149 
	`F77NAME
(
dcscsm
) (0, 
m
, 1, 1, 
NULL
, 1.0,

150 
descra
, &
Ac
.
	`val
(0), &Ac.
	`row_ind
(0), &Ac.
	`col_ptr
(0),

151 &
	`y
(0), 
m
, 0.0, &y(1), m,

152 
NULL
, 0);

154 if (
verbose
) 
cout
 << "CSCSM y-x " << 
	`norm
(
y
-
x
) << 
endl
;

156 if (
	`norm
(
y
-
x
) > 1.e-12) {

157 
errcount
++;

158 if (
verbose
) {

159 
cout
 << "b" << 
endl
 << 
b
 << endl;

160 
cout
 << "x" << 
endl
 << 
x
 << endl;

161 
cout
 << "y" << 
endl
 << 
y
 << endl;

180 double 
uval
[] = {1.0, 4.0, 1.0, 7.0, 1.0, 9.0, 1.0, 1.0};

181 int 
ucolind
[] = {0, 0, 1, 1, 2, 2, 3, 4};

182 int 
urowptr
[] = {0, 1, 3, 5, 7, 8};

183 double 
xval
[] = {4.0, 7.0, 9.0 };

184 int 
xcolind
[] = {0, 1, 2 };

185 int 
xrowptr
[] = {0, 0, 1, 2, 3, 3 };

187 
CompRow_Mat_double
 
	`uAr
(5,5,8,
uval
,
urowptr
,
ucolind
);

188 
CompRow_Mat_double
 
	`xAr
(5,5,3,
xval
,
xrowptr
,
xcolind
);

190 
b
 = 
uAr
 * 
x
;

192 
CompCol_Mat_double
 
xAc
;

193 
xAc
 = 
xAr
;

195 
descra
[0] = 0;

198 
descra
[1] = 1;

199 
descra
[2] = 1;

201 
	`F77NAME
(
dcsrsm
) (0, 
m
, 1, 1, 
NULL
, 1.0,

202 
descra
, 
xval
, 
xcolind
, 
xrowptr
,

203 &
	`b
(0), 
m
, 0.0, &
	`y
(1), m,

204 
NULL
, 0);

206 if (
verbose
) 
cout
 << "CSRSM y-x " << 
	`norm
(
y
-
x
) << 
endl
;

208 if (
	`norm
(
y
-
x
) > 1.e-12) {

209 
errcount
++;

210 if (
verbose
) {

211 
cout
 << "b" << 
endl
 << 
b
 << endl;

212 
cout
 << "x" << 
endl
 << 
x
 << endl;

213 
cout
 << "y" << 
endl
 << 
y
 << endl;

217 
	`F77NAME
(
dcscsm
) (1, 
m
, 1, 1, 
NULL
, 1.0,

218 
descra
, 
xval
, 
xcolind
, 
xrowptr
,

219 &
	`b
(0), 
m
, 0.0, &
	`y
(1), m,

220 
NULL
, 0);

222 if (
verbose
) 
cout
 << "CSCSM y-x " << 
	`norm
(
y
-
x
) << 
endl
;

224 if (
	`norm
(
y
-
x
) > 1.e-12) {

225 
errcount
++;

226 if (
verbose
) {

227 
cout
 << "b" << 
endl
 << 
b
 << endl;

228 
cout
 << "x" << 
endl
 << 
x
 << endl;

229 
cout
 << "y" << 
endl
 << 
y
 << endl;

234 
descra
[1] = 2;

235 
descra
[2] = 1;

237 
	`F77NAME
(
dcsrsm
) (1, 
m
, 1, 1, 
NULL
, 1.0,

238 
descra
, &
xAc
.
	`val
(0), &xAc.
	`row_ind
(0), &xAc.
	`col_ptr
(0),

239 &
	`b
(0), 
m
, 0.0, &
	`y
(1), m,

240 
NULL
, 0);

242 if (
verbose
) 
cout
 << "CSRSM y-x " << 
	`norm
(
y
-
x
) << 
endl
;

244 if (
	`norm
(
y
-
x
) > 1.e-12) {

245 
errcount
++;

246 if (
verbose
) {

247 
cout
 << "b" << 
endl
 << 
b
 << endl;

248 
cout
 << "x" << 
endl
 << 
x
 << endl;

249 
cout
 << "y" << 
endl
 << 
y
 << endl;

254 
descra
[1] = 1;

255 
descra
[2] = 1;

257 
	`F77NAME
(
dcscsm
) (0, 
m
, 1, 1, 
NULL
, 1.0,

258 
descra
, &
xAc
.
	`val
(0), &xAc.
	`row_ind
(0), &xAc.
	`col_ptr
(0),

259 &
	`b
(0), 
m
, 0.0, &
	`y
(1), m,

260 
NULL
, 0);

262 if (
verbose
) 
cout
 << "CSCSM y-x " << 
	`norm
(
y
-
x
) << 
endl
;

264 if (
	`norm
(
y
-
x
) > 1.e-12) {

265 
errcount
++;

266 if (
verbose
) {

267 
cout
 << "b" << 
endl
 << 
b
 << endl;

268 
cout
 << "x" << 
endl
 << 
x
 << endl;

269 
cout
 << "y" << 
endl
 << 
y
 << endl;

288 double 
yval
[] = {1.0, 4.0, 5.0, 7.0, 8.0, 9.0, 10.0, 12.0};

289 int 
ycolind
[] = {0, 1, 1, 2, 2, 3, 3, 4};

290 int 
yrowptr
[] = {0, 2, 4, 6, 7, 8};

293 
CompRow_Mat_double
 
	`yAr
(5,5,8,
yval
,
yrowptr
,
ycolind
);

294 
b
 = 
yAr
 * 
x
;

296 
CompCol_Mat_double
 
yAc
;

297 
yAc
 = 
yAr
;

300 
descra
[1] = 2;

301 
descra
[2] = 0;

303 
	`F77NAME
(
dcsrsm
) (0, 
m
, 1, 1, 
NULL
, 1.0,

304 
descra
, 
yval
, 
ycolind
, 
yrowptr
,

305 &
	`b
(0), 
m
, 0.0, &
	`y
(1), m,

306 
NULL
, 0);

308 if (
verbose
) 
cout
 << "CSRSM y-x " << 
	`norm
(
y
-
x
) << 
endl
;

310 if (
	`norm
(
y
-
x
) > 1.e-12) {

311 
errcount
++;

312 if (
verbose
) {

313 
cout
 << "b" << 
endl
 << 
b
 << endl;

314 
cout
 << "x" << 
endl
 << 
x
 << endl;

315 
cout
 << "y" << 
endl
 << 
y
 << endl;

321 
descra
[1] = 1;

322 
descra
[2] = 0;

324 
	`F77NAME
(
dcscsm
) (1, 
m
, 1, 1, 
NULL
, 1.0,

325 
descra
, 
yval
, 
ycolind
, 
yrowptr
,

326 &
	`b
(0), 
m
, 0.0, &
	`y
(1), m,

327 
NULL
, 0);

329 if (
verbose
) 
cout
 << "CSCSM y-x " << 
	`norm
(
y
-
x
) << 
endl
;

331 if (
	`norm
(
y
-
x
) > 1.e-12) {

332 
errcount
++;

333 if (
verbose
) {

334 
cout
 << "b" << 
endl
 << 
b
 << endl;

335 
cout
 << "x" << 
endl
 << 
x
 << endl;

336 
cout
 << "y" << 
endl
 << 
y
 << endl;

340 
	`F77NAME
(
dcsrsm
) (1, 
m
, 1, 1, 
NULL
, 1.0,

341 
descra
, &
yAc
.
	`val
(0), &yAc.
	`row_ind
(0), &yAc.
	`col_ptr
(0),

342 &
	`b
(0), 
m
, 0.0, &
	`y
(1), m,

343 
NULL
, 0);

345 if (
verbose
) 
cout
 << "CSRSM y-x " << 
	`norm
(
y
-
x
) << 
endl
;

347 if (
	`norm
(
y
-
x
) > 1.e-12) {

348 
errcount
++;

349 if (
verbose
) {

350 
cout
 << "b" << 
endl
 << 
b
 << endl;

351 
cout
 << "x" << 
endl
 << 
x
 << endl;

352 
cout
 << "y" << 
endl
 << 
y
 << endl;

358 
descra
[1] = 2;

359 
descra
[2] = 0;

361 
	`F77NAME
(
dcscsm
) (0, 
m
, 1, 1, 
NULL
, 1.0,

362 
descra
, &
yAc
.
	`val
(0), &yAc.
	`row_ind
(0), &yAc.
	`col_ptr
(0),

363 &
	`b
(0), 
m
, 0.0, &
	`y
(1), m,

364 
NULL
, 0);

366 if (
verbose
) 
cout
 << "CSCSM y-x " << 
	`norm
(
y
-
x
) << 
endl
;

368 if (
	`norm
(
y
-
x
) > 1.e-12) {

369 
errcount
++;

370 if (
verbose
) {

371 
cout
 << "b" << 
endl
 << 
b
 << endl;

372 
cout
 << "x" << 
endl
 << 
x
 << endl;

373 
cout
 << "y" << 
endl
 << 
y
 << endl;

392 double 
zval
[] = {1.0, 4.0, 1.0, 7.0, 1.0, 9.0, 1.0, 1.0};

393 int 
zcolind
[] = {0, 1, 1, 2, 2, 3, 3, 4};

394 int 
zrowptr
[] = {0, 2, 4, 6, 7, 8};

395 double 
aval
[] = {4.0, 7.0, 9.0 };

396 int 
acolind
[] = {1, 2, 3 };

397 int 
arowptr
[] = {0, 1, 2, 3, 3, 3 };

400 
CompRow_Mat_double
 
	`zAr
(5,5,8,
zval
,
zrowptr
,
zcolind
);

401 
CompRow_Mat_double
 
	`aAr
(5,5,3,
aval
,
arowptr
,
acolind
);

403 
b
 = 
zAr
 * 
x
;

405 
CompCol_Mat_double
 
aAc
;

406 
aAc
 = 
aAr
;

408 
descra
[0] = 0;

411 
descra
[1] = 2;

412 
descra
[2] = 1;

414 
	`F77NAME
(
dcsrsm
) (0, 
m
, 1, 1, 
NULL
, 1.0,

415 
descra
, 
aval
, 
acolind
, 
arowptr
,

416 &
	`b
(0), 
m
, 0.0, &
	`y
(1), m,

417 
NULL
, 0);

419 if (
verbose
) 
cout
 << "CSRSM y-x " << 
	`norm
(
y
-
x
) << 
endl
;

421 if (
	`norm
(
y
-
x
) > 1.e-12) {

422 
errcount
++;

423 if (
verbose
) {

424 
cout
 << "b" << 
endl
 << 
b
 << endl;

425 
cout
 << "x" << 
endl
 << 
x
 << endl;

426 
cout
 << "y" << 
endl
 << 
y
 << endl;

430 
	`F77NAME
(
dcscsm
) (1, 
m
, 1, 1, 
NULL
, 1.0,

431 
descra
, 
aval
, 
acolind
, 
arowptr
,

432 &
	`b
(0), 
m
, 0.0, &
	`y
(1), m,

433 
NULL
, 0);

435 if (
verbose
) 
cout
 << "CSCSM y-x " << 
	`norm
(
y
-
x
) << 
endl
;

437 if (
	`norm
(
y
-
x
) > 1.e-12) {

438 
errcount
++;

439 if (
verbose
) {

440 
cout
 << "b" << 
endl
 << 
b
 << endl;

441 
cout
 << "x" << 
endl
 << 
x
 << endl;

442 
cout
 << "y" << 
endl
 << 
y
 << endl;

447 
descra
[1] = 1;

448 
descra
[2] = 1;

450 
	`F77NAME
(
dcsrsm
) (1, 
m
, 1, 1, 
NULL
, 1.0,

451 
descra
, &
aAc
.
	`val
(0), &aAc.
	`row_ind
(0), &aAc.
	`col_ptr
(0),

452 &
	`b
(0), 
m
, 0.0, &
	`y
(1), m,

453 
NULL
, 0);

455 if (
verbose
) 
cout
 << "CSRSM y-x " << 
	`norm
(
y
-
x
) << 
endl
;

457 if (
	`norm
(
y
-
x
) > 1.e-12) {

458 
errcount
++;

459 if (
verbose
) {

460 
cout
 << "b" << 
endl
 << 
b
 << endl;

461 
cout
 << "x" << 
endl
 << 
x
 << endl;

462 
cout
 << "y" << 
endl
 << 
y
 << endl;

467 
descra
[1] = 2;

468 
descra
[2] = 1;

470 
	`F77NAME
(
dcscsm
) (0, 
m
, 1, 1, 
NULL
, 1.0,

471 
descra
, &
aAc
.
	`val
(0), &aAc.
	`row_ind
(0), &aAc.
	`col_ptr
(0),

472 &
	`b
(0), 
m
, 0.0, &
	`y
(1), m,

473 
NULL
, 0);

475 if (
verbose
) 
cout
 << "CSCSM y-x " << 
	`norm
(
y
-
x
) << 
endl
;

477 if (
	`norm
(
y
-
x
) > 1.e-12) {

478 
errcount
++;

479 if (
verbose
) {

480 
cout
 << "b" << 
endl
 << 
b
 << endl;

481 
cout
 << "x" << 
endl
 << 
x
 << endl;

482 
cout
 << "y" << 
endl
 << 
y
 << endl;

486 if (
errcount
 > 0) {

487 
cout
 << "There were " << 
errcount
 << "errors" << 
endl
;

488 if (
verbose
 == 0) {

489 
cout
 << "Run again with -v to find out where" << 
endl
;

492 
cout
 << "++++++++++++++++++++++++++++++++++++++++++++++++++++++++" << 
endl
;

493 
cout
 << "+ Successful completion of testing for SparseLib++ +" << 
endl
;

494 
cout
 << "+ No errors detected in Sparse BLAS routines. +" << 
endl
;

495 
cout
 << "++++++++++++++++++++++++++++++++++++++++++++++++++++++++" << 
endl
;

496 
cout
 << 
endl
 << endl;

499 return 
errcount
;

500 
	}
}

	@/usr/include/alloca.h

19 #ifndef 
_ALLOCA_H


20 #define 
	#_ALLOCA_H
 1

	)

22 #include 
	~<features.h
>

24 #define 
	#__need_size_t


	)

25 #include 
	~<stddef.h
>

27 
	g__BEGIN_DECLS


30 #undef 
alloca


33 extern void *
	$alloca
 (
size_t
 
__size
) 
__THROW
;

35 #ifdef 
__GNUC__


36 #define 
	#alloca
(
size
) 
	`__builtin_alloca
 (size)

	)

39 
__END_DECLS


	@/usr/include/assert.h

24 #ifdef 
_ASSERT_H


26 #undef 
_ASSERT_H


27 #undef 
assert


28 #undef 
__ASSERT_VOID_CAST


30 #ifdef 
__USE_GNU


31 #undef 
assert_perror


36 #define 
	#_ASSERT_H
 1

	)

37 #include 
	~<features.h
>

39 #if 
defined
 
__cplusplus
 && 
__GNUC_PREREQ
 (2,95)

40 #define 
	#__ASSERT_VOID_CAST
 
static_cast
<void>

	)

42 #define 
	#__ASSERT_VOID_CAST
 (void)

	)

50 #ifdef 
NDEBUG


52 #define 
	#assert
(
expr
) (
	`__ASSERT_VOID_CAST
 (0))

	)

60 #ifdef 
__USE_GNU


61 #define 
	#assert_perror
(
errnum
) (
	`__ASSERT_VOID_CAST
 (0))

	)

66 
__BEGIN_DECLS


69 extern void 
	$__assert_fail
 (
__const
 char *
__assertion
, __const char *
__file
,

70 unsigned int 
__line
, 
__const
 char *
__function
)

71 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

74 extern void 
	$__assert_perror_fail
 (int 
__errnum
, 
__const
 char *
__file
,

75 unsigned int 
__line
,

76 
__const
 char *
__function
)

77 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

82 extern void 
	$__assert
 (const char *
__assertion
, const char *
__file
, int 
__line
)

83 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

86 
__END_DECLS


88 #define 
	#assert
(
expr
) \

89 ((
expr
) \

90 ? 
	`__ASSERT_VOID_CAST
 (0) \

91 : 
	`__assert_fail
 (
	`__STRING
(
expr
), 
__FILE__
, 
__LINE__
, 
__ASSERT_FUNCTION
))

	)

93 #ifdef 
__USE_GNU


94 #define 
	#assert_perror
(
errnum
) \

95 (!(
errnum
) \

96 ? 
	`__ASSERT_VOID_CAST
 (0) \

97 : 
	`__assert_perror_fail
 ((
errnum
), 
__FILE__
, 
__LINE__
, 
__ASSERT_FUNCTION
))

	)

105 #if 
defined
 
__cplusplus
 ? 
	`__GNUC_PREREQ
 (2, 6) : __GNUC_PREREQ (2, 4)

106 #define 
	#__ASSERT_FUNCTION
 
__PRETTY_FUNCTION__


	)

108 #if 
defined
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L

109 #define 
	#__ASSERT_FUNCTION
 
__func__


	)

111 #define 
	#__ASSERT_FUNCTION
 ((
__const
 char *) 0)

	)

	@/usr/include/complex.h

23 #ifndef 
_COMPLEX_H


24 #define 
	#_COMPLEX_H
 1

	)

26 #include 
	~<features.h
>

29 #include 
	~<bits/mathdef.h
>

31 
	g__BEGIN_DECLS


36 #if 
__GNUC_PREREQ
 (2, 7) && !__GNUC_PREREQ (2, 97)

37 #define 
	#_Complex
 
__complex__


	)

40 #define 
	#complex
 
_Complex


	)

45 #define 
	#_Complex_I
 (
__extension__
 1.0
iF
)

	)

49 #undef 
I


50 #define 
	#I
 
_Complex_I


	)

57 #define 
	#__MATHCALL
(
function
, 
args
) \

58 
	`__MATHDECL
 (
_Mdouble_complex_
,
function
, 
args
)

	)

59 #define 
	#__MATHDECL
(
type
, 
function
, 
args
) \

60 
	`__MATHDECL_1
(
type
, 
function
, 
args
); \

61 
	`__MATHDECL_1
(
type
, 
	`__CONCAT
(
__
,
function
), 
args
)

	)

62 #define 
	#__MATHDECL_1
(
type
, 
function
, 
args
) \

63 extern 
type
 
	`__MATH_PRECNAME
(
function
) 
args
 
__THROW


	)

65 #define 
	#_Mdouble_
 double

	)

66 #define 
	#__MATH_PRECNAME
(
name
) 
	)
name

67 #include 
	~<bits/cmathcalls.h
>

68 #undef 
_Mdouble_


69 #undef 
__MATH_PRECNAME


72 #ifndef 
_Mfloat_


73 #define 
	#_Mfloat_
 float

	)

75 #define 
	#_Mdouble_
 
_Mfloat_


	)

76 #ifdef 
__STDC__


77 #define 
	#__MATH_PRECNAME
(
name
) name##
f


	)

79 #define 
	#__MATH_PRECNAME
(
name
) name 
f


	)

81 #include 
	~<bits/cmathcalls.h
>

82 #undef 
_Mdouble_


83 #undef 
__MATH_PRECNAME


87 #if (
__STDC__
 - 0 || 
__GNUC__
 - 0) \

88 && (!
defined
 
__NO_LONG_DOUBLE_MATH
 || defined 
__LDBL_COMPAT
)

89 #ifdef 
__LDBL_COMPAT


90 #undef 
__MATHDECL_1


91 #define 
	#__MATHDECL_1
(
type
, 
function
, 
args
) \

92 extern 
type
 
	`__REDIRECT_NTH
(
	`__MATH_PRECNAME
(
function
), 
args
, function)

	)

95 #ifndef 
_Mlong_double_


96 #define 
	#_Mlong_double_
 long double

	)

98 #define 
	#_Mdouble_
 
_Mlong_double_


	)

99 #ifdef 
__STDC__


100 #define 
	#__MATH_PRECNAME
(
name
) name##
l


	)

102 #define 
	#__MATH_PRECNAME
(
name
) name 
l


	)

104 #include 
	~<bits/cmathcalls.h
>

106 #undef 
_Mdouble_


107 #undef 
__MATH_PRECNAME


108 #undef 
__MATHDECL_1


109 #undef 
__MATHDECL


110 #undef 
__MATHCALL


112 
__END_DECLS


	@/usr/include/errno.h

23 #ifndef 
_ERRNO_H


27 #ifndef 
__need_Emath


28 #define 
	#_ERRNO_H
 1

	)

29 #include 
	~<features.h
>

32 
	g__BEGIN_DECLS


36 #include 
	~<bits/errno.h
>

37 #undef 
__need_Emath


39 #ifdef 
_ERRNO_H


46 #ifndef 
errno


47 extern int 
errno
;

50 #ifdef 
__USE_GNU


55 extern char *
program_invocation_name
, *
program_invocation_short_name
;

59 
	g__END_DECLS


67 #if 
defined
 
__USE_GNU
 || defined 
__need_error_t


68 #ifndef 
__error_t_defined


69 typedef int 
	terror_t
;

70 #define 
	#__error_t_defined
 1

	)

72 #undef 
__need_error_t


	@/usr/include/math.h

25 #ifndef 
_MATH_H


26 #define 
	#_MATH_H
 1

	)

28 #include 
	~<features.h
>

30 
	g__BEGIN_DECLS


34 #include 
	~<bits/huge_val.h
>

35 #ifdef 
__USE_ISOC99


36 #include 
	~<bits/huge_valf.h
>

37 #include 
	~<bits/huge_vall.h
>

40 #include 
	~<bits/inf.h
>

43 #include 
	~<bits/nan.h
>

47 #include 
	~<bits/mathdef.h
>

54 #define 
	#__MATHCALL
(
function
,
suffix
, 
args
) \

55 
	`__MATHDECL
 (
_Mdouble_
,
function
,
suffix
, 
args
)

	)

56 #define 
	#__MATHDECL
(
type
, 
function
,
suffix
, 
args
) \

57 
	`__MATHDECL_1
(
type
, 
function
,
suffix
, 
args
); \

58 
	`__MATHDECL_1
(
type
, 
	`__CONCAT
(
__
,
function
),
suffix
, 
args
)

	)

59 #define 
	#__MATHCALLX
(
function
,
suffix
, 
args
, 
attrib
) \

60 
	`__MATHDECLX
 (
_Mdouble_
,
function
,
suffix
, 
args
, 
attrib
)

	)

61 #define 
	#__MATHDECLX
(
type
, 
function
,
suffix
, 
args
, 
attrib
) \

62 
	`__MATHDECL_1
(
type
, 
function
,
suffix
, 
args
) 
	`__attribute__
 (
attrib
); \

63 
	`__MATHDECL_1
(
type
, 
	`__CONCAT
(
__
,
function
),
suffix
, 
args
) 
	`__attribute__
 (
attrib
)

	)

64 #define 
	#__MATHDECL_1
(
type
, 
function
,
suffix
, 
args
) \

65 extern 
type
 
	`__MATH_PRECNAME
(
function
,
suffix
) 
args
 
__THROW


	)

67 #define 
	#_Mdouble_
 double

	)

68 #define 
	#__MATH_PRECNAME
(
name
,
r
) 
	`__CONCAT
(name,r)

	)

69 #define 
	#_Mdouble_BEGIN_NAMESPACE
 
__BEGIN_NAMESPACE_STD


	)

70 #define 
	#_Mdouble_END_NAMESPACE
 
__END_NAMESPACE_STD


	)

71 #include 
	~<bits/mathcalls.h
>

72 #undef 
_Mdouble_


73 #undef 
_Mdouble_BEGIN_NAMESPACE


74 #undef 
_Mdouble_END_NAMESPACE


75 #undef 
__MATH_PRECNAME


77 #if 
defined
 
__USE_MISC
 || defined 
__USE_ISOC99


83 #ifndef 
_Mfloat_


84 #define 
	#_Mfloat_
 float

	)

86 #define 
	#_Mdouble_
 
_Mfloat_


	)

87 #ifdef 
__STDC__


88 #define 
	#__MATH_PRECNAME
(
name
,
r
) name##
f
##
	)
r

90 #define 
	#__MATH_PRECNAME
(
name
,
r
) name 
f
 
	)
r

92 #define 
	#_Mdouble_BEGIN_NAMESPACE
 
__BEGIN_NAMESPACE_C99


	)

93 #define 
	#_Mdouble_END_NAMESPACE
 
__END_NAMESPACE_C99


	)

94 #include 
	~<bits/mathcalls.h
>

95 #undef 
_Mdouble_


96 #undef 
_Mdouble_BEGIN_NAMESPACE


97 #undef 
_Mdouble_END_NAMESPACE


98 #undef 
__MATH_PRECNAME


100 #if (
__STDC__
 - 0 || 
__GNUC__
 - 0) \

101 && (!
defined
 
__NO_LONG_DOUBLE_MATH
 || defined 
__LDBL_COMPAT
)

102 #ifdef 
__LDBL_COMPAT


104 #ifdef 
__USE_ISOC99


105 extern float 
	$__nldbl_nexttowardf
 (float 
__x
, long double 
__y
)

106 
__THROW
 
	`__attribute__
 ((
__const__
));

107 #ifdef 
__REDIRECT_NTH


108 extern float 
	`__REDIRECT_NTH
 (
nexttowardf
, (float 
__x
, long double 
__y
),

109 
__nldbl_nexttowardf
)

110 
	`__attribute__
 ((
__const__
));

111 extern double 
	`__REDIRECT_NTH
 (
nexttoward
, (double 
__x
, long double 
__y
),

112 
nextafter
) 
	`__attribute__
 ((
__const__
));

113 extern long double 
	`__REDIRECT_NTH
 (
nexttowardl
,

114 (long double 
__x
, long double 
__y
),

115 
nextafter
) 
	`__attribute__
 ((
__const__
));

122 #undef 
__MATHDECL_1


123 #define 
	#__MATHDECL_2
(
type
, 
function
,
suffix
, 
args
, 
alias
) \

124 extern 
type
 
	`__REDIRECT_NTH
(
	`__MATH_PRECNAME
(
function
,
suffix
), \

125 
args
, 
alias
)

	)

126 #define 
	#__MATHDECL_1
(
type
, 
function
,
suffix
, 
args
) \

127 
	`__MATHDECL_2
(
type
, 
function
,
suffix
, 
args
, 
	`__CONCAT
(function,suffix))

	)

130 #ifndef 
_Mlong_double_


131 #define 
	#_Mlong_double_
 long double

	)

133 #define 
	#_Mdouble_
 
_Mlong_double_


	)

134 #ifdef 
__STDC__


135 #define 
	#__MATH_PRECNAME
(
name
,
r
) name##
l
##
	)
r

137 #define 
	#__MATH_PRECNAME
(
name
,
r
) name 
l
 
	)
r

139 #define 
	#_Mdouble_BEGIN_NAMESPACE
 
__BEGIN_NAMESPACE_C99


	)

140 #define 
	#_Mdouble_END_NAMESPACE
 
__END_NAMESPACE_C99


	)

141 #include 
	~<bits/mathcalls.h
>

142 #undef 
_Mdouble_


143 #undef 
_Mdouble_BEGIN_NAMESPACE


144 #undef 
_Mdouble_END_NAMESPACE


145 #undef 
__MATH_PRECNAME


150 #undef 
__MATHDECL_1


151 #undef 
__MATHDECL


152 #undef 
__MATHCALL


155 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN


157 extern int 
signgam
;

162 #ifdef 
__USE_ISOC99


200 
FP_NAN
,

201 #define 
	#FP_NAN
 
FP_NAN


	)

202 
FP_INFINITE
,

203 #define 
	#FP_INFINITE
 
FP_INFINITE


	)

204 
FP_ZERO
,

205 #define 
	#FP_ZERO
 
FP_ZERO


	)

206 
FP_SUBNORMAL
,

207 #define 
	#FP_SUBNORMAL
 
FP_SUBNORMAL


	)

208 
FP_NORMAL


209 #define 
	#FP_NORMAL
 
FP_NORMAL


	)

213 #ifdef 
__NO_LONG_DOUBLE_MATH


214 #define 
	#fpclassify
(
x
) \

215 (sizeof (
x
) == sizeof (float) ? 
	`__fpclassifyf
 (x) : 
	`__fpclassify
 (x))

	)

217 #define 
	#fpclassify
(
x
) \

218 (sizeof (
x
) == sizeof (float) \

219 ? 
	`__fpclassifyf
 (
x
) \

220 : sizeof (
x
) == sizeof (double) \

221 ? 
	`__fpclassify
 (
x
) : 
	`__fpclassifyl
 (x))

	)

225 #ifdef 
__NO_LONG_DOUBLE_MATH


226 #define 
	#signbit
(
x
) \

227 (sizeof (
x
) == sizeof (float) ? 
	`__signbitf
 (x) : 
	`__signbit
 (x))

	)

229 #define 
	#signbit
(
x
) \

230 (sizeof (
x
) == sizeof (float) \

231 ? 
	`__signbitf
 (
x
) \

232 : sizeof (
x
) == sizeof (double) \

233 ? 
	`__signbit
 (
x
) : 
	`__signbitl
 (x))

	)

237 #ifdef 
__NO_LONG_DOUBLE_MATH


238 #define 
	#isfinite
(
x
) \

239 (sizeof (
x
) == sizeof (float) ? 
	`__finitef
 (x) : 
	`__finite
 (x))

	)

241 #define 
	#isfinite
(
x
) \

242 (sizeof (
x
) == sizeof (float) \

243 ? 
	`__finitef
 (
x
) \

244 : sizeof (
x
) == sizeof (double) \

245 ? 
	`__finite
 (
x
) : 
	`__finitel
 (x))

	)

249 #define 
	#isnormal
(
x
) (
	`fpclassify
 (x) == 
FP_NORMAL
)

	)

253 #ifdef 
__NO_LONG_DOUBLE_MATH


254 #define 
	#isnan
(
x
) \

255 (sizeof (
x
) == sizeof (float) ? 
	`__isnanf
 (x) : 
	`__isnan
 (x))

	)

257 #define 
	#isnan
(
x
) \

258 (sizeof (
x
) == sizeof (float) \

259 ? 
	`__isnanf
 (
x
) \

260 : sizeof (
x
) == sizeof (double) \

261 ? 
	`__isnan
 (
x
) : 
	`__isnanl
 (x))

	)

265 #ifdef 
__NO_LONG_DOUBLE_MATH


266 #define 
	#isinf
(
x
) \

267 (sizeof (
x
) == sizeof (float) ? 
	`__isinff
 (x) : 
	`__isinf
 (x))

	)

269 #define 
	#isinf
(
x
) \

270 (sizeof (
x
) == sizeof (float) \

271 ? 
	`__isinff
 (
x
) \

272 : sizeof (
x
) == sizeof (double) \

273 ? 
	`__isinf
 (
x
) : 
	`__isinfl
 (x))

	)

277 #define 
	#MATH_ERRNO
 1

	)

278 #define 
	#MATH_ERREXCEPT
 2

	)

283 #ifndef 
__FAST_MATH__


284 #define 
	#math_errhandling
 (
MATH_ERRNO
 | 
MATH_ERREXCEPT
)

	)

289 #ifdef 
__USE_MISC


293 
_IEEE_
 = -1,

294 
_SVID_
,

295 
_XOPEN_
,

296 
_POSIX_
,

297 
_ISOC_


298 } 
	t_LIB_VERSION_TYPE
;

303 extern 
_LIB_VERSION_TYPE
 
_LIB_VERSION
;

307 #ifdef 
__USE_SVID


313 #ifdef 
__cplusplus


314 struct 
__exception


316 struct 
exception


319 int 
type
;

320 char *
name
;

321 double 
arg1
;

322 double 
arg2
;

323 double 
retval
;

324 
	}
};

326 #ifdef 
__cplusplus


327 extern int 
	$matherr
 (struct 
__exception
 *
__exc
) 
	`throw
 ();

329 extern int 
	`matherr
 (struct 
exception
 *
__exc
);

332 #define 
	#X_TLOSS
 1.41484755040568800000e+16

	)

335 #define 
	#DOMAIN
 1

	)

336 #define 
	#SING
 2

	)

337 #define 
	#OVERFLOW
 3

	)

338 #define 
	#UNDERFLOW
 4

	)

339 #define 
	#TLOSS
 5

	)

340 #define 
	#PLOSS
 6

	)

343 #define 
	#HUGE
 3.40282347e+38F

	)

347 #ifdef 
__USE_XOPEN


349 #define 
	#MAXFLOAT
 3.40282347e+38F

	)

356 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN


357 #define 
	#M_E
 2.7182818284590452354

	)

358 #define 
	#M_LOG2E
 1.4426950408889634074

	)

359 #define 
	#M_LOG10E
 0.43429448190325182765

	)

360 #define 
	#M_LN2
 0.69314718055994530942

	)

361 #define 
	#M_LN10
 2.30258509299404568402

	)

362 #define 
	#M_PI
 3.14159265358979323846

	)

363 #define 
	#M_PI_2
 1.57079632679489661923

	)

364 #define 
	#M_PI_4
 0.78539816339744830962

	)

365 #define 
	#M_1_PI
 0.31830988618379067154

	)

366 #define 
	#M_2_PI
 0.63661977236758134308

	)

367 #define 
	#M_2_SQRTPI
 1.12837916709551257390

	)

368 #define 
	#M_SQRT2
 1.41421356237309504880

	)

369 #define 
	#M_SQRT1_2
 0.70710678118654752440

	)

375 #ifdef 
__USE_GNU


376 #define 
	#M_El
 2.7182818284590452353602874713526625L

	)

377 #define 
	#M_LOG2El
 1.4426950408889634073599246810018921L

	)

378 #define 
	#M_LOG10El
 0.4342944819032518276511289189166051L

	)

379 #define 
	#M_LN2l
 0.6931471805599453094172321214581766L

	)

380 #define 
	#M_LN10l
 2.3025850929940456840179914546843642L

	)

381 #define 
	#M_PIl
 3.1415926535897932384626433832795029L

	)

382 #define 
	#M_PI_2l
 1.5707963267948966192313216916397514L

	)

383 #define 
	#M_PI_4l
 0.7853981633974483096156608458198757L

	)

384 #define 
	#M_1_PIl
 0.3183098861837906715377675267450287L

	)

385 #define 
	#M_2_PIl
 0.6366197723675813430755350534900574L

	)

386 #define 
	#M_2_SQRTPIl
 1.1283791670955125738961589031215452L

	)

387 #define 
	#M_SQRT2l
 1.4142135623730950488016887242096981L

	)

388 #define 
	#M_SQRT1_2l
 0.7071067811865475244008443621048490L

	)

395 #if 
defined
 
__STRICT_ANSI__
 && !defined 
__NO_MATH_INLINES


396 #define 
	#__NO_MATH_INLINES
 1

	)

399 #if 
defined
 
__USE_ISOC99
 && 
	`__GNUC_PREREQ
(2,97)

406 #define 
	#isgreater
(
x
, 
y
) 
	`__builtin_isgreater
(x, y)

	)

407 #define 
	#isgreaterequal
(
x
, 
y
) 
	`__builtin_isgreaterequal
(x, y)

	)

408 #define 
	#isless
(
x
, 
y
) 
	`__builtin_isless
(x, y)

	)

409 #define 
	#islessequal
(
x
, 
y
) 
	`__builtin_islessequal
(x, y)

	)

410 #define 
	#islessgreater
(
x
, 
y
) 
	`__builtin_islessgreater
(x, y)

	)

411 #define 
	#isunordered
(
u
, 
v
) 
	`__builtin_isunordered
(u, v)

	)

415 #ifdef 
__USE_EXTERN_INLINES


416 #include 
	~<bits/mathinline.h
>

419 #ifdef 
__USE_ISOC99


423 #ifndef 
isgreater


424 #define 
	#isgreater
(
x
, 
y
) \

425 (
__extension__
 \

426 ({ 
	`__typeof__
(
x
) 
__x
 = (x); __typeof__(
y
) 
__y
 = (y); \

427 !
	`isunordered
 (
__x
, 
__y
) && __x > __y; 
	}
}))

	)

431 #ifndef 
isgreaterequal


432 #define 
	#isgreaterequal
(
x
, 
y
) \

433 (
__extension__
 \

434 ({ 
	`__typeof__
(
x
) 
__x
 = (x); __typeof__(
y
) 
__y
 = (y); \

435 !
	`isunordered
 (
__x
, 
__y
) && __x >= __y; }))

	)

439 #ifndef 
isless


440 #define 
	#isless
(
x
, 
y
) \

441 (
__extension__
 \

442 ({ 
	`__typeof__
(
x
) 
__x
 = (x); __typeof__(
y
) 
__y
 = (y); \

443 !
	`isunordered
 (
__x
, 
__y
) && __x < __y; }))

	)

447 #ifndef 
islessequal


448 #define 
	#islessequal
(
x
, 
y
) \

449 (
__extension__
 \

450 ({ 
	`__typeof__
(
x
) 
__x
 = (x); __typeof__(
y
) 
__y
 = (y); \

451 !
	`isunordered
 (
__x
, 
__y
) && __x <= __y; }))

	)

455 #ifndef 
islessgreater


456 #define 
	#islessgreater
(
x
, 
y
) \

457 (
__extension__
 \

458 ({ 
	`__typeof__
(
x
) 
__x
 = (x); __typeof__(
y
) 
__y
 = (y); \

459 !
	`isunordered
 (
__x
, 
__y
) && (__x < __y || __y < __x); }))

	)

463 #ifndef 
isunordered


464 #define 
	#isunordered
(
u
, 
v
) \

465 (
__extension__
 \

466 ({ 
	`__typeof__
(
u
) 
__u
 = (u); __typeof__(
v
) 
__v
 = (v); \

467 
	`fpclassify
 (
__u
) == 
FP_NAN
 || fpclassify (
__v
) == FP_NAN; }))

	)

472 
	g__END_DECLS


	@/usr/include/stdio.h

24 #ifndef 
_STDIO_H


26 #if !
defined
 
__need_FILE
 && !defined 
__need___FILE


27 #define 
	#_STDIO_H
 1

	)

28 #include 
	~<features.h
>

30 
	g__BEGIN_DECLS


32 #define 
	#__need_size_t


	)

33 #define 
	#__need_NULL


	)

34 #include 
	~<stddef.h
>

36 #include 
	~<bits/types.h
>

37 #define 
	#__need_FILE


	)

38 #define 
	#__need___FILE


	)

42 #if !
defined
 
__FILE_defined
 && defined 
__need_FILE


45 struct 
	g_IO_FILE
;

47 
__BEGIN_NAMESPACE_STD


49 typedef struct 
_IO_FILE
 
	tFILE
;

50 
	g__END_NAMESPACE_STD


51 #if 
defined
 
__USE_LARGEFILE64
 || defined 
__USE_SVID
 || defined 
__USE_POSIX
 \

52 || 
defined
 
	g__USE_BSD
 || defined 
	g__USE_ISOC99
 || defined 
	g__USE_XOPEN
 \

53 || 
defined
 
__USE_POSIX2


54 
	$__USING_NAMESPACE_STD
(
FILE
)

57 #define 
	#__FILE_defined
 1

	)

59 #undef 
__need_FILE


62 #if !
defined
 
____FILE_defined
 && defined 
__need___FILE


65 typedef struct 
_IO_FILE
 
	t__FILE
;

67 #define 
	#____FILE_defined
 1

	)

69 #undef 
__need___FILE


72 #ifdef 
_STDIO_H


73 #define 
	#_STDIO_USES_IOSTREAM


	)

75 #include 
	~<libio.h
>

77 #if 
defined
 
__USE_XOPEN
 || defined 
__USE_XOPEN2K8


78 #ifdef 
__GNUC__


79 #ifndef 
_VA_LIST_DEFINED


80 typedef 
_G_va_list
 
	tva_list
;

81 #define 
	#_VA_LIST_DEFINED


	)

84 #include 
	~<stdarg.h
>

88 #ifdef 
__USE_XOPEN2K8


89 #ifndef 
__off_t_defined


90 #ifndef 
__USE_FILE_OFFSET64


91 typedef 
__off_t
 
	toff_t
;

93 typedef 
__off64_t
 
	toff_t
;

95 #define 
	#__off_t_defined


	)

97 #if 
defined
 
__USE_LARGEFILE64
 && !defined 
__off64_t_defined


98 typedef 
__off64_t
 
	toff64_t
;

99 #define 
	#__off64_t_defined


	)

102 #ifndef 
__ssize_t_defined


103 typedef 
__ssize_t
 
	tssize_t
;

104 #define 
	#__ssize_t_defined


	)

109 
__BEGIN_NAMESPACE_STD


110 #ifndef 
__USE_FILE_OFFSET64


111 typedef 
_G_fpos_t
 
	tfpos_t
;

113 typedef 
_G_fpos64_t
 
	tfpos_t
;

115 
__END_NAMESPACE_STD


116 #ifdef 
__USE_LARGEFILE64


117 typedef 
_G_fpos64_t
 
	tfpos64_t
;

121 #define 
	#_IOFBF
 0

	)

122 #define 
	#_IOLBF
 1

	)

123 #define 
	#_IONBF
 2

	)

127 #ifndef 
BUFSIZ


128 #define 
	#BUFSIZ
 
_IO_BUFSIZ


	)

134 #ifndef 
EOF


135 #define 
	#EOF
 (-1)

	)

141 #define 
	#SEEK_SET
 0

	)

142 #define 
	#SEEK_CUR
 1

	)

143 #define 
	#SEEK_END
 2

	)

146 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN


148 #define 
	#P_tmpdir
 "/tmp"

	)

161 #include 
	~<bits/stdio_lim.h
>

165 extern struct 
_IO_FILE
 *
stdin
;

166 extern struct 
_IO_FILE
 *
stdout
;

167 extern struct 
_IO_FILE
 *
stderr
;

168 #ifdef 
__STDC__


170 #define 
	#stdin
 
stdin


	)

171 #define 
	#stdout
 
stdout


	)

172 #define 
	#stderr
 
stderr


	)

175 
__BEGIN_NAMESPACE_STD


177 extern int 
	$remove
 (
__const
 char *
__filename
) 
__THROW
;

179 extern int 
	$rename
 (
__const
 char *
__old
, __const char *
__new
) 
__THROW
;

180 
__END_NAMESPACE_STD


182 #ifdef 
__USE_ATFILE


184 extern int 
	$renameat
 (int 
__oldfd
, 
__const
 char *
__old
, int 
__newfd
,

185 
__const
 char *
__new
) 
__THROW
;

188 
__BEGIN_NAMESPACE_STD


193 #ifndef 
__USE_FILE_OFFSET64


194 extern 
FILE
 *
	$tmpfile
 (void) 
__wur
;

196 #ifdef 
__REDIRECT


197 extern 
FILE
 *
	`__REDIRECT
 (
tmpfile
, (void), 
tmpfile64
) 
__wur
;

199 #define 
	#tmpfile
 
tmpfile64


	)

203 #ifdef 
__USE_LARGEFILE64


204 extern 
FILE
 *
	$tmpfile64
 (void) 
__wur
;

208 extern char *
	$tmpnam
 (char *
__s
) 
__THROW
 
__wur
;

209 
__END_NAMESPACE_STD


211 #ifdef 
__USE_MISC


214 extern char *
	$tmpnam_r
 (char *
__s
) 
__THROW
 
__wur
;

218 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN


226 extern char *
	$tempnam
 (
__const
 char *
__dir
, __const char *
__pfx
)

227 
__THROW
 
__attribute_malloc__
 
__wur
;

231 
__BEGIN_NAMESPACE_STD


236 extern int 
	`fclose
 (
FILE
 *
__stream
);

241 extern int 
	`fflush
 (
FILE
 *
__stream
);

242 
__END_NAMESPACE_STD


244 #ifdef 
__USE_MISC


251 extern int 
	`fflush_unlocked
 (
FILE
 *
__stream
);

254 #ifdef 
__USE_GNU


261 extern int 
	`fcloseall
 (void);

265 
__BEGIN_NAMESPACE_STD


266 #ifndef 
__USE_FILE_OFFSET64


271 extern 
FILE
 *
	$fopen
 (
__const
 char *
__restrict
 
__filename
,

272 
__const
 char *
__restrict
 
__modes
) 
__wur
;

277 extern 
FILE
 *
	$freopen
 (
__const
 char *
__restrict
 
__filename
,

278 
__const
 char *
__restrict
 
__modes
,

279 
FILE
 *
__restrict
 
__stream
) 
__wur
;

281 #ifdef 
__REDIRECT


282 extern 
FILE
 *
	`__REDIRECT
 (
fopen
, (
__const
 char *
__restrict
 
__filename
,

283 
__const
 char *
__restrict
 
__modes
), 
fopen64
)

284 
__wur
;

285 extern 
FILE
 *
	`__REDIRECT
 (
freopen
, (
__const
 char *
__restrict
 
__filename
,

286 
__const
 char *
__restrict
 
__modes
,

287 
FILE
 *
__restrict
 
__stream
), 
freopen64
)

288 
__wur
;

290 #define 
	#fopen
 
fopen64


	)

291 #define 
	#freopen
 
freopen64


	)

294 
__END_NAMESPACE_STD


295 #ifdef 
__USE_LARGEFILE64


296 extern 
FILE
 *
	$fopen64
 (
__const
 char *
__restrict
 
__filename
,

297 
__const
 char *
__restrict
 
__modes
) 
__wur
;

298 extern 
FILE
 *
	$freopen64
 (
__const
 char *
__restrict
 
__filename
,

299 
__const
 char *
__restrict
 
__modes
,

300 
FILE
 *
__restrict
 
__stream
) 
__wur
;

303 #ifdef 
__USE_POSIX


305 extern 
FILE
 *
	$fdopen
 (int 
__fd
, 
__const
 char *
__modes
) 
__THROW
 
__wur
;

308 #ifdef 
__USE_GNU


311 extern 
FILE
 *
	$fopencookie
 (void *
__restrict
 
__magic_cookie
,

312 
__const
 char *
__restrict
 
__modes
,

313 
_IO_cookie_io_functions_t
 
__io_funcs
) 
__THROW
 
__wur
;

316 #ifdef 
__USE_XOPEN2K8


318 extern 
FILE
 *
	$fmemopen
 (void *
__s
, 
size_t
 
__len
, 
__const
 char *
__modes
)

319 
__THROW
 
__wur
;

324 extern 
FILE
 *
	$open_memstream
 (char **
__bufloc
, 
size_t
 *
__sizeloc
) 
__THROW
 
__wur
;

328 
__BEGIN_NAMESPACE_STD


331 extern void 
	$setbuf
 (
FILE
 *
__restrict
 
__stream
, char *__restrict 
__buf
) 
__THROW
;

335 extern int 
	$setvbuf
 (
FILE
 *
__restrict
 
__stream
, char *__restrict 
__buf
,

336 int 
__modes
, 
size_t
 
__n
) 
__THROW
;

337 
__END_NAMESPACE_STD


339 #ifdef 
__USE_BSD


342 extern void 
	$setbuffer
 (
FILE
 *
__restrict
 
__stream
, char *__restrict 
__buf
,

343 
size_t
 
__size
) 
__THROW
;

346 extern void 
	$setlinebuf
 (
FILE
 *
__stream
) 
__THROW
;

350 
__BEGIN_NAMESPACE_STD


355 extern int 
	`fprintf
 (
FILE
 *
__restrict
 
__stream
,

356 
__const
 char *
__restrict
 
__format
, ...);

361 extern int 
	`printf
 (
__const
 char *
__restrict
 
__format
, ...);

363 extern int 
	$sprintf
 (char *
__restrict
 
__s
,

364 
__const
 char *
__restrict
 
__format
, ...) 
__THROW
;

370 extern int 
	`vfprintf
 (
FILE
 *
__restrict
 
__s
, 
__const
 char *__restrict 
__format
,

371 
_G_va_list
 
__arg
);

376 extern int 
	`vprintf
 (
__const
 char *
__restrict
 
__format
, 
_G_va_list
 
__arg
);

378 extern int 
	$vsprintf
 (char *
__restrict
 
__s
, 
__const
 char *__restrict 
__format
,

379 
_G_va_list
 
__arg
) 
__THROW
;

380 
__END_NAMESPACE_STD


382 #if 
defined
 
__USE_BSD
 || defined 
__USE_ISOC99
 || defined 
__USE_UNIX98


383 
__BEGIN_NAMESPACE_C99


385 extern int 
	$snprintf
 (char *
__restrict
 
__s
, 
size_t
 
__maxlen
,

386 
__const
 char *
__restrict
 
__format
, ...)

387 
__THROW
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 3, 4)));

389 extern int 
	$vsnprintf
 (char *
__restrict
 
__s
, 
size_t
 
__maxlen
,

390 
__const
 char *
__restrict
 
__format
, 
_G_va_list
 
__arg
)

391 
__THROW
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 3, 0)));

392 
__END_NAMESPACE_C99


395 #ifdef 
__USE_GNU


398 extern int 
	$vasprintf
 (char **
__restrict
 
__ptr
, 
__const
 char *__restrict 
__f
,

399 
_G_va_list
 
__arg
)

400 
__THROW
 
	`__attribute__
 ((
	$__format__
 (
__printf__
, 2, 0))) 
__wur
;

401 extern int 
	$__asprintf
 (char **
__restrict
 
__ptr
,

402 
__const
 char *
__restrict
 
__fmt
, ...)

403 
__THROW
 
	`__attribute__
 ((
	$__format__
 (
__printf__
, 2, 3))) 
__wur
;

404 extern int 
	$asprintf
 (char **
__restrict
 
__ptr
,

405 
__const
 char *
__restrict
 
__fmt
, ...)

406 
__THROW
 
	`__attribute__
 ((
	$__format__
 (
__printf__
, 2, 3))) 
__wur
;

409 #ifdef 
__USE_XOPEN2K8


416 extern int 
	$vdprintf
 (int 
__fd
, 
__const
 char *
__restrict
 
__fmt
,

417 
_G_va_list
 
__arg
)

418 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 0)));

419 extern int 
	$dprintf
 (int 
__fd
, 
__const
 char *
__restrict
 
__fmt
, ...)

420 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 3)));

424 
__BEGIN_NAMESPACE_STD


429 extern int 
	$fscanf
 (
FILE
 *
__restrict
 
__stream
,

430 
__const
 char *
__restrict
 
__format
, ...) 
__wur
;

435 extern int 
	$scanf
 (
__const
 char *
__restrict
 
__format
, ...) 
__wur
;

437 extern int 
	$sscanf
 (
__const
 char *
__restrict
 
__s
,

438 
__const
 char *
__restrict
 
__format
, ...) 
__THROW
;

440 #if 
defined
 
__USE_ISOC99
 && !defined 
__USE_GNU
 \

441 && (!
defined
 
__LDBL_COMPAT
 || !defined 
__REDIRECT
) \

442 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

443 #ifdef 
__REDIRECT


447 extern int 
	`__REDIRECT
 (
fscanf
, (
FILE
 *
__restrict
 
__stream
,

448 
__const
 char *
__restrict
 
__format
, ...),

449 
__isoc99_fscanf
) 
__wur
;

450 extern int 
	`__REDIRECT
 (
scanf
, (
__const
 char *
__restrict
 
__format
, ...),

451 
__isoc99_scanf
) 
__wur
;

452 extern int 
	`__REDIRECT
 (
sscanf
, (
__const
 char *
__restrict
 
__s
,

453 
__const
 char *
__restrict
 
__format
, ...),

454 
__isoc99_sscanf
) 
__THROW
;

456 extern int 
	$__isoc99_fscanf
 (
FILE
 *
__restrict
 
__stream
,

457 
__const
 char *
__restrict
 
__format
, ...) 
__wur
;

458 extern int 
	$__isoc99_scanf
 (
__const
 char *
__restrict
 
__format
, ...) 
__wur
;

459 extern int 
	$__isoc99_sscanf
 (
__const
 char *
__restrict
 
__s
,

460 
__const
 char *
__restrict
 
__format
, ...) 
__THROW
;

461 #define 
	#fscanf
 
__isoc99_fscanf


	)

462 #define 
	#scanf
 
__isoc99_scanf


	)

463 #define 
	#sscanf
 
__isoc99_sscanf


	)

467 
__END_NAMESPACE_STD


469 #ifdef 
__USE_ISOC99


470 
__BEGIN_NAMESPACE_C99


475 extern int 
	$vfscanf
 (
FILE
 *
__restrict
 
__s
, 
__const
 char *__restrict 
__format
,

476 
_G_va_list
 
__arg
)

477 
	`__attribute__
 ((
	$__format__
 (
__scanf__
, 2, 0))) 
__wur
;

483 extern int 
	$vscanf
 (
__const
 char *
__restrict
 
__format
, 
_G_va_list
 
__arg
)

484 
	`__attribute__
 ((
	$__format__
 (
__scanf__
, 1, 0))) 
__wur
;

487 extern int 
	$vsscanf
 (
__const
 char *
__restrict
 
__s
,

488 
__const
 char *
__restrict
 
__format
, 
_G_va_list
 
__arg
)

489 
__THROW
 
	`__attribute__
 ((
	`__format__
 (
__scanf__
, 2, 0)));

491 #if !
defined
 
__USE_GNU
 \

492 && (!
defined
 
__LDBL_COMPAT
 || !defined 
__REDIRECT
) \

493 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

494 #ifdef 
__REDIRECT


498 extern int 
	`__REDIRECT
 (
vfscanf
,

499 (
FILE
 *
__restrict
 
__s
,

500 
__const
 char *
__restrict
 
__format
, 
_G_va_list
 
__arg
),

501 
__isoc99_vfscanf
)

502 
	`__attribute__
 ((
	$__format__
 (
__scanf__
, 2, 0))) 
__wur
;

503 extern int 
	`__REDIRECT
 (
vscanf
, (
__const
 char *
__restrict
 
__format
,

504 
_G_va_list
 
__arg
), 
__isoc99_vscanf
)

505 
	`__attribute__
 ((
	$__format__
 (
__scanf__
, 1, 0))) 
__wur
;

506 extern int 
	`__REDIRECT
 (
vsscanf
,

507 (
__const
 char *
__restrict
 
__s
,

508 
__const
 char *
__restrict
 
__format
, 
_G_va_list
 
__arg
),

509 
__isoc99_vsscanf
)

510 
__THROW
 
	`__attribute__
 ((
	`__format__
 (
__scanf__
, 2, 0)));

512 extern int 
	$__isoc99_vfscanf
 (
FILE
 *
__restrict
 
__s
,

513 
__const
 char *
__restrict
 
__format
,

514 
_G_va_list
 
__arg
) 
__wur
;

515 extern int 
	$__isoc99_vscanf
 (
__const
 char *
__restrict
 
__format
,

516 
_G_va_list
 
__arg
) 
__wur
;

517 extern int 
	$__isoc99_vsscanf
 (
__const
 char *
__restrict
 
__s
,

518 
__const
 char *
__restrict
 
__format
,

519 
_G_va_list
 
__arg
) 
__THROW
;

520 #define 
	#vfscanf
 
__isoc99_vfscanf


	)

521 #define 
	#vscanf
 
__isoc99_vscanf


	)

522 #define 
	#vsscanf
 
__isoc99_vsscanf


	)

526 
__END_NAMESPACE_C99


530 
__BEGIN_NAMESPACE_STD


535 extern int 
	`fgetc
 (
FILE
 *
__stream
);

536 extern int 
	`getc
 (
FILE
 *
__stream
);

542 extern int 
	`getchar
 (void);

543 
__END_NAMESPACE_STD


547 #define 
	#getc
(
_fp
) 
	`_IO_getc
 (_fp)

	)

549 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


554 extern int 
	`getc_unlocked
 (
FILE
 *
__stream
);

555 extern int 
	`getchar_unlocked
 (void);

558 #ifdef 
__USE_MISC


565 extern int 
	`fgetc_unlocked
 (
FILE
 *
__stream
);

569 
__BEGIN_NAMESPACE_STD


577 extern int 
	`fputc
 (int 
__c
, 
FILE
 *
__stream
);

578 extern int 
	`putc
 (int 
__c
, 
FILE
 *
__stream
);

584 extern int 
	`putchar
 (int 
__c
);

585 
__END_NAMESPACE_STD


589 #define 
	#putc
(
_ch
, 
_fp
) 
	`_IO_putc
 (_ch, _fp)

	)

591 #ifdef 
__USE_MISC


598 extern int 
	`fputc_unlocked
 (int 
__c
, 
FILE
 *
__stream
);

601 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


606 extern int 
	`putc_unlocked
 (int 
__c
, 
FILE
 *
__stream
);

607 extern int 
	`putchar_unlocked
 (int 
__c
);

611 #if 
defined
 
__USE_SVID
 || defined 
__USE_MISC
 \

612 || (
defined
 
__USE_XOPEN
 && !defined 
__USE_XOPEN2K
)

614 extern int 
	`getw
 (
FILE
 *
__stream
);

617 extern int 
	`putw
 (int 
__w
, 
FILE
 *
__stream
);

621 
__BEGIN_NAMESPACE_STD


626 extern char *
	$fgets
 (char *
__restrict
 
__s
, int 
__n
, 
FILE
 *__restrict 
__stream
)

627 
__wur
;

634 extern char *
	$gets
 (char *
__s
) 
__wur
;

635 
__END_NAMESPACE_STD


637 #ifdef 
__USE_GNU


644 extern char *
	$fgets_unlocked
 (char *
__restrict
 
__s
, int 
__n
,

645 
FILE
 *
__restrict
 
__stream
) 
__wur
;

649 #ifdef 
__USE_XOPEN2K8


660 extern 
_IO_ssize_t
 
	$__getdelim
 (char **
__restrict
 
__lineptr
,

661 
size_t
 *
__restrict
 
__n
, int 
__delimiter
,

662 
FILE
 *
__restrict
 
__stream
) 
__wur
;

663 extern 
_IO_ssize_t
 
	$getdelim
 (char **
__restrict
 
__lineptr
,

664 
size_t
 *
__restrict
 
__n
, int 
__delimiter
,

665 
FILE
 *
__restrict
 
__stream
) 
__wur
;

673 extern 
_IO_ssize_t
 
	$getline
 (char **
__restrict
 
__lineptr
,

674 
size_t
 *
__restrict
 
__n
,

675 
FILE
 *
__restrict
 
__stream
) 
__wur
;

679 
__BEGIN_NAMESPACE_STD


684 extern int 
	`fputs
 (
__const
 char *
__restrict
 
__s
, 
FILE
 *__restrict 
__stream
);

690 extern int 
	`puts
 (
__const
 char *
__s
);

697 extern int 
	`ungetc
 (int 
__c
, 
FILE
 *
__stream
);

704 extern 
size_t
 
	$fread
 (void *
__restrict
 
__ptr
, 
size_t
 
__size
,

705 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
) 
__wur
;

710 extern 
size_t
 
	$fwrite
 (
__const
 void *
__restrict
 
__ptr
, 
size_t
 
__size
,

711 
size_t
 
__n
, 
FILE
 *
__restrict
 
__s
) 
__wur
;

712 
__END_NAMESPACE_STD


714 #ifdef 
__USE_GNU


721 extern int 
	`fputs_unlocked
 (
__const
 char *
__restrict
 
__s
,

722 
FILE
 *
__restrict
 
__stream
);

725 #ifdef 
__USE_MISC


732 extern 
size_t
 
	$fread_unlocked
 (void *
__restrict
 
__ptr
, 
size_t
 
__size
,

733 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
) 
__wur
;

734 extern 
size_t
 
	$fwrite_unlocked
 (
__const
 void *
__restrict
 
__ptr
, 
size_t
 
__size
,

735 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
) 
__wur
;

739 
__BEGIN_NAMESPACE_STD


744 extern int 
	`fseek
 (
FILE
 *
__stream
, long int 
__off
, int 
__whence
);

749 extern long int 
	$ftell
 (
FILE
 *
__stream
) 
__wur
;

754 extern void 
	`rewind
 (
FILE
 *
__stream
);

755 
__END_NAMESPACE_STD


762 #if 
defined
 
__USE_LARGEFILE
 || defined 
__USE_XOPEN2K


763 #ifndef 
__USE_FILE_OFFSET64


768 extern int 
	`fseeko
 (
FILE
 *
__stream
, 
__off_t
 
__off
, int 
__whence
);

773 extern 
__off_t
 
	$ftello
 (
FILE
 *
__stream
) 
__wur
;

775 #ifdef 
__REDIRECT


776 extern int 
	`__REDIRECT
 (
fseeko
,

777 (
FILE
 *
__stream
, 
__off64_t
 
__off
, int 
__whence
),

778 
fseeko64
);

779 extern 
__off64_t
 
	`__REDIRECT
 (
ftello
, (
FILE
 *
__stream
), 
ftello64
);

781 #define 
	#fseeko
 
fseeko64


	)

782 #define 
	#ftello
 
ftello64


	)

787 
__BEGIN_NAMESPACE_STD


788 #ifndef 
__USE_FILE_OFFSET64


793 extern int 
	`fgetpos
 (
FILE
 *
__restrict
 
__stream
, 
fpos_t
 *__restrict 
__pos
);

798 extern int 
	`fsetpos
 (
FILE
 *
__stream
, 
__const
 
fpos_t
 *
__pos
);

800 #ifdef 
__REDIRECT


801 extern int 
	`__REDIRECT
 (
fgetpos
, (
FILE
 *
__restrict
 
__stream
,

802 
fpos_t
 *
__restrict
 
__pos
), 
fgetpos64
);

803 extern int 
	`__REDIRECT
 (
fsetpos
,

804 (
FILE
 *
__stream
, 
__const
 
fpos_t
 *
__pos
), 
fsetpos64
);

806 #define 
	#fgetpos
 
fgetpos64


	)

807 #define 
	#fsetpos
 
fsetpos64


	)

810 
__END_NAMESPACE_STD


812 #ifdef 
__USE_LARGEFILE64


813 extern int 
	`fseeko64
 (
FILE
 *
__stream
, 
__off64_t
 
__off
, int 
__whence
);

814 extern 
__off64_t
 
	$ftello64
 (
FILE
 *
__stream
) 
__wur
;

815 extern int 
	`fgetpos64
 (
FILE
 *
__restrict
 
__stream
, 
fpos64_t
 *__restrict 
__pos
);

816 extern int 
	`fsetpos64
 (
FILE
 *
__stream
, 
__const
 
fpos64_t
 *
__pos
);

819 
__BEGIN_NAMESPACE_STD


821 extern void 
	$clearerr
 (
FILE
 *
__stream
) 
__THROW
;

823 extern int 
	$feof
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

825 extern int 
	$ferror
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

826 
__END_NAMESPACE_STD


828 #ifdef 
__USE_MISC


830 extern void 
	$clearerr_unlocked
 (
FILE
 *
__stream
) 
__THROW
;

831 extern int 
	$feof_unlocked
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

832 extern int 
	$ferror_unlocked
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

836 
__BEGIN_NAMESPACE_STD


841 extern void 
	`perror
 (
__const
 char *
__s
);

842 
__END_NAMESPACE_STD


848 #include 
	~<bits/sys_errlist.h
>

851 #ifdef 
__USE_POSIX


853 extern int 
	$fileno
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

856 #ifdef 
__USE_MISC


858 extern int 
	$fileno_unlocked
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

862 #if (
defined
 
__USE_POSIX2
 || defined 
__USE_SVID
 || defined 
__USE_BSD
 || \

863 
defined
 
__USE_MISC
)

868 extern 
FILE
 *
	$popen
 (
__const
 char *
__command
, __const char *
__modes
) 
__wur
;

874 extern int 
	`pclose
 (
FILE
 *
__stream
);

878 #ifdef 
__USE_POSIX


880 extern char *
	$ctermid
 (char *
__s
) 
__THROW
;

884 #ifdef 
__USE_XOPEN


886 extern char *
	`cuserid
 (char *
__s
);

890 #ifdef 
__USE_GNU


891 struct 
obstack
;

894 extern int 
	$obstack_printf
 (struct 
obstack
 *
__restrict
 
__obstack
,

895 
__const
 char *
__restrict
 
__format
, ...)

896 
__THROW
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 3)));

897 extern int 
	$obstack_vprintf
 (struct 
obstack
 *
__restrict
 
__obstack
,

898 
__const
 char *
__restrict
 
__format
,

899 
_G_va_list
 
__args
)

900 
__THROW
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 0)));

904 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


908 extern void 
	$flockfile
 (
FILE
 *
__stream
) 
__THROW
;

912 extern int 
	$ftrylockfile
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

915 extern void 
	$funlockfile
 (
FILE
 *
__stream
) 
__THROW
;

918 #if 
defined
 
__USE_XOPEN
 && !defined 
__USE_XOPEN2K
 && !defined 
__USE_GNU


922 #define 
	#__need_getopt


	)

923 #include 
	~<getopt.h
>

928 #ifdef 
__USE_EXTERN_INLINES


929 #include 
	~<bits/stdio.h
>

931 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__extern_always_inline


932 #include 
	~<bits/stdio2.h
>

934 #ifdef 
__LDBL_COMPAT


935 #include 
	~<bits/stdio-ldbl.h
>

938 
__END_DECLS


	@/usr/include/stdlib.h

23 #ifndef 
_STDLIB_H


25 #include 
	~<features.h
>

28 #define 
	#__need_size_t


	)

29 #ifndef 
__need_malloc_and_calloc


30 #define 
	#__need_wchar_t


	)

31 #define 
	#__need_NULL


	)

33 #include 
	~<stddef.h
>

35 
	g__BEGIN_DECLS


37 #ifndef 
__need_malloc_and_calloc


38 #define 
	#_STDLIB_H
 1

	)

40 #if (
defined
 
__USE_XOPEN
 || defined 
__USE_XOPEN2K8
) && !defined 
_SYS_WAIT_H


42 #include 
	~<bits/waitflags.h
>

43 #include 
	~<bits/waitstatus.h
>

45 #ifdef 
__USE_BSD


50 #if 
defined
 
__GNUC__
 && !defined 
__cplusplus


51 #define 
	#__WAIT_INT
(
status
) \

52 (
	`__extension__
 (((union { 
	`__typeof
(
status
) 
__in
; int 
__i
; }) \

53 { .
__in
 = (
status
) }).
__i
))

	)

55 #define 
	#__WAIT_INT
(
status
) (*(int *) &(status))

	)

63 #if !
defined
 
__GNUC__
 || __GNUC__ < 2 || defined 
__cplusplus


64 #define 
	#__WAIT_STATUS
 void *

	)

65 #define 
	#__WAIT_STATUS_DEFN
 void *

	)

70 union 
wait
 *
	m__uptr
;

71 int *
	m__iptr
;

72 } 
	t__WAIT_STATUS
 
	t__attribute__
 ((
	t__transparent_union__
));

73 #define 
	#__WAIT_STATUS_DEFN
 int *

	)

78 #define 
	#__WAIT_INT
(
status
) (status)

	)

79 #define 
	#__WAIT_STATUS
 int *

	)

80 #define 
	#__WAIT_STATUS_DEFN
 int *

	)

85 #define 
	#WEXITSTATUS
(
status
) 
	`__WEXITSTATUS
 (
	`__WAIT_INT
 (status))

	)

86 #define 
	#WTERMSIG
(
status
) 
	`__WTERMSIG
 (
	`__WAIT_INT
 (status))

	)

87 #define 
	#WSTOPSIG
(
status
) 
	`__WSTOPSIG
 (
	`__WAIT_INT
 (status))

	)

88 #define 
	#WIFEXITED
(
status
) 
	`__WIFEXITED
 (
	`__WAIT_INT
 (status))

	)

89 #define 
	#WIFSIGNALED
(
status
) 
	`__WIFSIGNALED
 (
	`__WAIT_INT
 (status))

	)

90 #define 
	#WIFSTOPPED
(
status
) 
	`__WIFSTOPPED
 (
	`__WAIT_INT
 (status))

	)

91 #ifdef 
__WIFCONTINUED


92 #define 
	#WIFCONTINUED
(
status
) 
	`__WIFCONTINUED
 (
	`__WAIT_INT
 (status))

	)

96 
__BEGIN_NAMESPACE_STD


100 int 
	mquot
;

101 int 
	mrem
;

102 } 
	tdiv_t
;

105 #ifndef 
__ldiv_t_defined


108 long int 
	mquot
;

109 long int 
	mrem
;

110 } 
	tldiv_t
;

111 #define 
	#__ldiv_t_defined
 1

	)

113 
	g__END_NAMESPACE_STD


115 #if 
defined
 
__USE_ISOC99
 && !defined 
__lldiv_t_defined


116 
__BEGIN_NAMESPACE_C99


118 
__extension__
 typedef struct

120 long long int 
	mquot
;

121 long long int 
	mrem
;

122 } 
	tlldiv_t
;

123 #define 
	#__lldiv_t_defined
 1

	)

124 
	g__END_NAMESPACE_C99


129 #define 
	#RAND_MAX
 2147483647

	)

134 #define 
	#EXIT_FAILURE
 1

	)

135 #define 
	#EXIT_SUCCESS
 0

	)

139 #define 
	#MB_CUR_MAX
 (
	`__ctype_get_mb_cur_max
 ())

	)

140 extern 
size_t
 
	$__ctype_get_mb_cur_max
 (void) 
__THROW
 
__wur
;

143 
__BEGIN_NAMESPACE_STD


145 extern double 
	$atof
 (
__const
 char *
__nptr
)

146 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

148 extern int 
	$atoi
 (
__const
 char *
__nptr
)

149 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

151 extern long int 
	$atol
 (
__const
 char *
__nptr
)

152 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

153 
__END_NAMESPACE_STD


155 #if 
defined
 
__USE_ISOC99
 || (defined 
__GLIBC_HAVE_LONG_LONG
 && defined 
__USE_MISC
)

156 
__BEGIN_NAMESPACE_C99


158 
__extension__
 extern long long int 
	$atoll
 (
__const
 char *
__nptr
)

159 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

160 
__END_NAMESPACE_C99


163 
__BEGIN_NAMESPACE_STD


165 extern double 
	$strtod
 (
__const
 char *
__restrict
 
__nptr
,

166 char **
__restrict
 
__endptr
)

167 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

168 
__END_NAMESPACE_STD


170 #ifdef 
__USE_ISOC99


171 
__BEGIN_NAMESPACE_C99


173 extern float 
	$strtof
 (
__const
 char *
__restrict
 
__nptr
,

174 char **
__restrict
 
__endptr
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

176 extern long double 
	$strtold
 (
__const
 char *
__restrict
 
__nptr
,

177 char **
__restrict
 
__endptr
)

178 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

179 
__END_NAMESPACE_C99


182 
__BEGIN_NAMESPACE_STD


184 extern long int 
	$strtol
 (
__const
 char *
__restrict
 
__nptr
,

185 char **
__restrict
 
__endptr
, int 
__base
)

186 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

188 extern unsigned long int 
	$strtoul
 (
__const
 char *
__restrict
 
__nptr
,

189 char **
__restrict
 
__endptr
, int 
__base
)

190 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

191 
__END_NAMESPACE_STD


193 #if 
defined
 
__GLIBC_HAVE_LONG_LONG
 && defined 
__USE_BSD


195 
__extension__


196 extern long long int 
	$strtoq
 (
__const
 char *
__restrict
 
__nptr
,

197 char **
__restrict
 
__endptr
, int 
__base
)

198 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

200 
__extension__


201 extern unsigned long long int 
	$strtouq
 (
__const
 char *
__restrict
 
__nptr
,

202 char **
__restrict
 
__endptr
, int 
__base
)

203 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

206 #if 
defined
 
__USE_ISOC99
 || (defined 
__GLIBC_HAVE_LONG_LONG
 && defined 
__USE_MISC
)

207 
__BEGIN_NAMESPACE_C99


209 
__extension__


210 extern long long int 
	$strtoll
 (
__const
 char *
__restrict
 
__nptr
,

211 char **
__restrict
 
__endptr
, int 
__base
)

212 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

214 
__extension__


215 extern unsigned long long int 
	$strtoull
 (
__const
 char *
__restrict
 
__nptr
,

216 char **
__restrict
 
__endptr
, int 
__base
)

217 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

218 
__END_NAMESPACE_C99


222 #ifdef 
__USE_GNU


236 #include 
	~<xlocale.h
>

240 extern long int 
	$strtol_l
 (
__const
 char *
__restrict
 
__nptr
,

241 char **
__restrict
 
__endptr
, int 
__base
,

242 
__locale_t
 
__loc
) 
__THROW
 
	`__nonnull
 ((1, 4)) 
__wur
;

244 extern unsigned long int 
	$strtoul_l
 (
__const
 char *
__restrict
 
__nptr
,

245 char **
__restrict
 
__endptr
,

246 int 
__base
, 
__locale_t
 
__loc
)

247 
__THROW
 
	`__nonnull
 ((1, 4)) 
__wur
;

249 
__extension__


250 extern long long int 
	$strtoll_l
 (
__const
 char *
__restrict
 
__nptr
,

251 char **
__restrict
 
__endptr
, int 
__base
,

252 
__locale_t
 
__loc
)

253 
__THROW
 
	`__nonnull
 ((1, 4)) 
__wur
;

255 
__extension__


256 extern unsigned long long int 
	$strtoull_l
 (
__const
 char *
__restrict
 
__nptr
,

257 char **
__restrict
 
__endptr
,

258 int 
__base
, 
__locale_t
 
__loc
)

259 
__THROW
 
	`__nonnull
 ((1, 4)) 
__wur
;

261 extern double 
	$strtod_l
 (
__const
 char *
__restrict
 
__nptr
,

262 char **
__restrict
 
__endptr
, 
__locale_t
 
__loc
)

263 
__THROW
 
	`__nonnull
 ((1, 3)) 
__wur
;

265 extern float 
	$strtof_l
 (
__const
 char *
__restrict
 
__nptr
,

266 char **
__restrict
 
__endptr
, 
__locale_t
 
__loc
)

267 
__THROW
 
	`__nonnull
 ((1, 3)) 
__wur
;

269 extern long double 
	$strtold_l
 (
__const
 char *
__restrict
 
__nptr
,

270 char **
__restrict
 
__endptr
,

271 
__locale_t
 
__loc
)

272 
__THROW
 
	`__nonnull
 ((1, 3)) 
__wur
;

276 #ifdef 
__USE_EXTERN_INLINES


277 
__BEGIN_NAMESPACE_STD


278 
__extern_inline
 double

279 
	`__NTH
 (
	$atof
 (
__const
 char *
__nptr
))

281 return 
	`strtod
 (
__nptr
, (char **) 
NULL
);

282 
	}
}

283 
__extern_inline
 int

284 
__NTH
 (
	$atoi
 (
__const
 char *
__nptr
))

286 return (int) 
	`strtol
 (
__nptr
, (char **) 
NULL
, 10);

287 
	}
}

288 
__extern_inline
 long int

289 
__NTH
 (
	$atol
 (
__const
 char *
__nptr
))

291 return 
	`strtol
 (
__nptr
, (char **) 
NULL
, 10);

292 
	}
}

293 
	g__END_NAMESPACE_STD


295 #if 
defined
 
__USE_MISC
 || defined 
__USE_ISOC99


296 
__BEGIN_NAMESPACE_C99


297 
__extension__
 
__extern_inline
 long long int

298 
__NTH
 (
	$atoll
 (
__const
 char *
__nptr
))

300 return 
	`strtoll
 (
__nptr
, (char **) 
NULL
, 10);

301 
	}
}

302 
	g__END_NAMESPACE_C99


307 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN_EXTENDED


311 extern char *
	$l64a
 (long int 
__n
) 
__THROW
 
__wur
;

314 extern long int 
	$a64l
 (
__const
 char *
__s
)

315 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

319 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_BSD


320 #include 
	~<sys/types.h
>

327 extern long int 
	$random
 (void) 
__THROW
;

330 extern void 
	$srandom
 (unsigned int 
__seed
) 
__THROW
;

336 extern char *
	$initstate
 (unsigned int 
__seed
, char *
__statebuf
,

337 
size_t
 
__statelen
) 
__THROW
 
	`__nonnull
 ((2));

341 extern char *
	$setstate
 (char *
__statebuf
) 
__THROW
 
	`__nonnull
 ((1));

344 #ifdef 
__USE_MISC


349 struct 
	srandom_data


351 
int32_t
 *
fptr
;

352 
int32_t
 *
rptr
;

353 
int32_t
 *
state
;

354 int 
rand_type
;

355 int 
rand_deg
;

356 int 
rand_sep
;

357 
int32_t
 *
end_ptr
;

360 extern int 
	$random_r
 (struct 
random_data
 *
__restrict
 
__buf
,

361 
int32_t
 *
__restrict
 
__result
) 
__THROW
 
	`__nonnull
 ((1, 2));

363 extern int 
	$srandom_r
 (unsigned int 
__seed
, struct 
random_data
 *
__buf
)

364 
__THROW
 
	`__nonnull
 ((2));

366 extern int 
	$initstate_r
 (unsigned int 
__seed
, char *
__restrict
 
__statebuf
,

367 
size_t
 
__statelen
,

368 struct 
random_data
 *
__restrict
 
__buf
)

369 
__THROW
 
	`__nonnull
 ((2, 4));

371 extern int 
	$setstate_r
 (char *
__restrict
 
__statebuf
,

372 struct 
random_data
 *
__restrict
 
__buf
)

373 
__THROW
 
	`__nonnull
 ((1, 2));

378 
__BEGIN_NAMESPACE_STD


380 extern int 
	$rand
 (void) 
__THROW
;

382 extern void 
	$srand
 (unsigned int 
__seed
) 
__THROW
;

383 
__END_NAMESPACE_STD


385 #ifdef 
__USE_POSIX


387 extern int 
	$rand_r
 (unsigned int *
__seed
) 
__THROW
;

391 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN


395 extern double 
	$drand48
 (void) 
__THROW
;

396 extern double 
	$erand48
 (unsigned short int 
__xsubi
[3]) 
__THROW
 
	`__nonnull
 ((1));

399 extern long int 
	$lrand48
 (void) 
__THROW
;

400 extern long int 
	$nrand48
 (unsigned short int 
__xsubi
[3])

401 
__THROW
 
	`__nonnull
 ((1));

404 extern long int 
	$mrand48
 (void) 
__THROW
;

405 extern long int 
	$jrand48
 (unsigned short int 
__xsubi
[3])

406 
__THROW
 
	`__nonnull
 ((1));

409 extern void 
	$srand48
 (long int 
__seedval
) 
__THROW
;

410 extern unsigned short int *
	$seed48
 (unsigned short int 
__seed16v
[3])

411 
__THROW
 
	`__nonnull
 ((1));

412 extern void 
	$lcong48
 (unsigned short int 
__param
[7]) 
__THROW
 
	`__nonnull
 ((1));

414 #ifdef 
__USE_MISC


418 struct 
	sdrand48_data


420 unsigned short int 
__x
[3];

421 unsigned short int 
__old_x
[3];

422 unsigned short int 
__c
;

423 unsigned short int 
__init
;

424 unsigned long long int 
__a
;

428 extern int 
	$drand48_r
 (struct 
drand48_data
 *
__restrict
 
__buffer
,

429 double *
__restrict
 
__result
) 
__THROW
 
	`__nonnull
 ((1, 2));

430 extern int 
	$erand48_r
 (unsigned short int 
__xsubi
[3],

431 struct 
drand48_data
 *
__restrict
 
__buffer
,

432 double *
__restrict
 
__result
) 
__THROW
 
	`__nonnull
 ((1, 2));

435 extern int 
	$lrand48_r
 (struct 
drand48_data
 *
__restrict
 
__buffer
,

436 long int *
__restrict
 
__result
)

437 
__THROW
 
	`__nonnull
 ((1, 2));

438 extern int 
	$nrand48_r
 (unsigned short int 
__xsubi
[3],

439 struct 
drand48_data
 *
__restrict
 
__buffer
,

440 long int *
__restrict
 
__result
)

441 
__THROW
 
	`__nonnull
 ((1, 2));

444 extern int 
	$mrand48_r
 (struct 
drand48_data
 *
__restrict
 
__buffer
,

445 long int *
__restrict
 
__result
)

446 
__THROW
 
	`__nonnull
 ((1, 2));

447 extern int 
	$jrand48_r
 (unsigned short int 
__xsubi
[3],

448 struct 
drand48_data
 *
__restrict
 
__buffer
,

449 long int *
__restrict
 
__result
)

450 
__THROW
 
	`__nonnull
 ((1, 2));

453 extern int 
	$srand48_r
 (long int 
__seedval
, struct 
drand48_data
 *
__buffer
)

454 
__THROW
 
	`__nonnull
 ((2));

456 extern int 
	$seed48_r
 (unsigned short int 
__seed16v
[3],

457 struct 
drand48_data
 *
__buffer
) 
__THROW
 
	`__nonnull
 ((1, 2));

459 extern int 
	$lcong48_r
 (unsigned short int 
__param
[7],

460 struct 
drand48_data
 *
__buffer
)

461 
__THROW
 
	`__nonnull
 ((1, 2));

467 #ifndef 
__malloc_and_calloc_defined


468 #define 
	#__malloc_and_calloc_defined


	)

469 
__BEGIN_NAMESPACE_STD


471 extern void *
	$malloc
 (
size_t
 
__size
) 
__THROW
 
__attribute_malloc__
 
__wur
;

473 extern void *
	$calloc
 (
size_t
 
__nmemb
, size_t 
__size
)

474 
__THROW
 
__attribute_malloc__
 
__wur
;

475 
__END_NAMESPACE_STD


478 #ifndef 
__need_malloc_and_calloc


479 
__BEGIN_NAMESPACE_STD


485 extern void *
	$realloc
 (void *
__ptr
, 
size_t
 
__size
)

486 
__THROW
 
__attribute_warn_unused_result__
;

488 extern void 
	$free
 (void *
__ptr
) 
__THROW
;

489 
__END_NAMESPACE_STD


491 #ifdef 
__USE_MISC


493 extern void 
	$cfree
 (void *
__ptr
) 
__THROW
;

496 #if 
defined
 
__USE_GNU
 || defined 
__USE_BSD
 || defined 
__USE_MISC


497 #include 
	~<alloca.h
>

500 #if (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K
) \

501 || 
defined
 
__USE_BSD


503 extern void *
	$valloc
 (
size_t
 
__size
) 
__THROW
 
__attribute_malloc__
 
__wur
;

506 #ifdef 
__USE_XOPEN2K


508 extern int 
	$posix_memalign
 (void **
__memptr
, 
size_t
 
__alignment
, size_t 
__size
)

509 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

512 
__BEGIN_NAMESPACE_STD


514 extern void 
	$abort
 (void) 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

518 extern int 
	`atexit
 (void (*
__func
) (void)) 
__THROW
 
	`__nonnull
 ((1));

520 #ifdef 
__USE_GNU


524 #ifdef 
__cplusplus


525 extern "C++" int 
	`at_quick_exit
 (void (*
__func
) (void))

526 
__THROW
 
	`__asm
 ("at_quick_exit") 
	`__nonnull
 ((1));

528 extern int 
	`at_quick_exit
 (void (*
__func
) (void)) 
__THROW
 
	`__nonnull
 ((1));

531 
__END_NAMESPACE_STD


533 #ifdef 
__USE_MISC


536 extern int 
	`on_exit
 (void (*
__func
) (int 
__status
, void *
__arg
), void *__arg)

537 
__THROW
 
	`__nonnull
 ((1));

540 
__BEGIN_NAMESPACE_STD


544 extern void 
	$exit
 (int 
__status
) 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

546 #ifdef 
__USE_GNU


552 extern void 
	$quick_exit
 (int 
__status
) 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

554 
__END_NAMESPACE_STD


556 #ifdef 
__USE_ISOC99


557 
__BEGIN_NAMESPACE_C99


560 extern void 
	$_Exit
 (int 
__status
) 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

561 
__END_NAMESPACE_C99


565 
__BEGIN_NAMESPACE_STD


567 extern char *
	$getenv
 (
__const
 char *
__name
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

568 
__END_NAMESPACE_STD


572 extern char *
	$__secure_getenv
 (
__const
 char *
__name
)

573 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

575 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN


579 extern int 
	$putenv
 (char *
__string
) 
__THROW
 
	`__nonnull
 ((1));

582 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN2K


585 extern int 
	$setenv
 (
__const
 char *
__name
, __const char *
__value
, int 
__replace
)

586 
__THROW
 
	`__nonnull
 ((2));

589 extern int 
	$unsetenv
 (
__const
 char *
__name
) 
__THROW
 
	`__nonnull
 ((1));

592 #ifdef 
__USE_MISC


596 extern int 
	$clearenv
 (void) 
__THROW
;

600 #if 
defined
 
__USE_MISC
 \

601 || (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K
)

606 extern char *
	$mktemp
 (char *
__template
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

609 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED
 \

610 || 
defined
 
__USE_XOPEN2K8


619 #ifndef 
__USE_FILE_OFFSET64


620 extern int 
	$mkstemp
 (char *
__template
) 
	`__nonnull
 ((1)) 
__wur
;

622 #ifdef 
__REDIRECT


623 extern int 
	`__REDIRECT
 (
mkstemp
, (char *
__template
), 
mkstemp64
)

624 
	`__nonnull
 ((1)) 
__wur
;

626 #define 
	#mkstemp
 
mkstemp64


	)

629 #ifdef 
__USE_LARGEFILE64


630 extern int 
	$mkstemp64
 (char *
__template
) 
	`__nonnull
 ((1)) 
__wur
;

634 #ifdef 
__USE_MISC


641 #ifndef 
__USE_FILE_OFFSET64


642 extern int 
	$mkstemps
 (char *
__template
, int 
__suffixlen
) 
	`__nonnull
 ((1)) 
__wur
;

644 #ifdef 
__REDIRECT


645 extern int 
	`__REDIRECT
 (
mkstemps
, (char *
__template
, int 
__suffixlen
),

646 
mkstemps64
) 
	`__nonnull
 ((1)) 
__wur
;

648 #define 
	#mkstemps
 
mkstemps64


	)

651 #ifdef 
__USE_LARGEFILE64


652 extern int 
	$mkstemps64
 (char *
__template
, int 
__suffixlen
)

653 
	`__nonnull
 ((1)) 
__wur
;

657 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN2K8


663 extern char *
	$mkdtemp
 (char *
__template
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

666 #ifdef 
__USE_GNU


673 #ifndef 
__USE_FILE_OFFSET64


674 extern int 
	$mkostemp
 (char *
__template
, int 
__flags
) 
	`__nonnull
 ((1)) 
__wur
;

676 #ifdef 
__REDIRECT


677 extern int 
	`__REDIRECT
 (
mkostemp
, (char *
__template
, int 
__flags
), 
mkostemp64
)

678 
	`__nonnull
 ((1)) 
__wur
;

680 #define 
	#mkostemp
 
mkostemp64


	)

683 #ifdef 
__USE_LARGEFILE64


684 extern int 
	$mkostemp64
 (char *
__template
, int 
__flags
) 
	`__nonnull
 ((1)) 
__wur
;

693 #ifndef 
__USE_FILE_OFFSET64


694 extern int 
	$mkostemps
 (char *
__template
, int 
__suffixlen
, int 
__flags
)

695 
	`__nonnull
 ((1)) 
__wur
;

697 #ifdef 
__REDIRECT


698 extern int 
	`__REDIRECT
 (
mkostemps
, (char *
__template
, int 
__suffixlen
,

699 int 
__flags
), 
mkostemps64
)

700 
	`__nonnull
 ((1)) 
__wur
;

702 #define 
	#mkostemps
 
mkostemps64


	)

705 #ifdef 
__USE_LARGEFILE64


706 extern int 
	$mkostemps64
 (char *
__template
, int 
__suffixlen
, int 
__flags
)

707 
	`__nonnull
 ((1)) 
__wur
;

712 
__BEGIN_NAMESPACE_STD


717 extern int 
	$system
 (
__const
 char *
__command
) 
__wur
;

718 
__END_NAMESPACE_STD


721 #ifdef 
__USE_GNU


724 extern char *
	$canonicalize_file_name
 (
__const
 char *
__name
)

725 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

728 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED


734 extern char *
	$realpath
 (
__const
 char *
__restrict
 
__name
,

735 char *
__restrict
 
__resolved
) 
__THROW
 
__wur
;

740 #ifndef 
__COMPAR_FN_T


741 #define 
	#__COMPAR_FN_T


	)

742 typedef int (*
	t__compar_fn_t
) (
	t__const
 void *, __const void *);

744 #ifdef 
__USE_GNU


745 typedef 
__compar_fn_t
 
	tcomparison_fn_t
;

748 #ifdef 
__USE_GNU


749 typedef int (*
	t__compar_d_fn_t
) (
	t__const
 void *, __const void *, void *);

752 
__BEGIN_NAMESPACE_STD


755 extern void *
	$bsearch
 (
__const
 void *
__key
, __const void *
__base
,

756 
size_t
 
__nmemb
, size_t 
__size
, 
__compar_fn_t
 
__compar
)

757 
	`__nonnull
 ((1, 2, 5)) 
__wur
;

761 extern void 
	$qsort
 (void *
__base
, 
size_t
 
__nmemb
, size_t 
__size
,

762 
__compar_fn_t
 
__compar
) 
	`__nonnull
 ((1, 4));

763 #ifdef 
__USE_GNU


764 extern void 
	$qsort_r
 (void *
__base
, 
size_t
 
__nmemb
, size_t 
__size
,

765 
__compar_d_fn_t
 
__compar
, void *
__arg
)

766 
	`__nonnull
 ((1, 4));

771 extern int 
	$abs
 (int 
__x
) 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

772 extern long int 
	$labs
 (long int 
__x
) 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

773 
__END_NAMESPACE_STD


775 #ifdef 
__USE_ISOC99


776 
__extension__
 extern long long int 
	$llabs
 (long long int 
__x
)

777 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

781 
__BEGIN_NAMESPACE_STD


785 extern 
div_t
 
	$div
 (int 
__numer
, int 
__denom
)

786 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

787 extern 
ldiv_t
 
	$ldiv
 (long int 
__numer
, long int 
__denom
)

788 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

789 
__END_NAMESPACE_STD


791 #ifdef 
__USE_ISOC99


792 
__BEGIN_NAMESPACE_C99


793 
__extension__
 extern 
lldiv_t
 
	$lldiv
 (long long int 
__numer
,

794 long long int 
__denom
)

795 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

796 
__END_NAMESPACE_C99


800 #if (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K
) \

801 || 
defined
 
__USE_SVID


808 extern char *
	$ecvt
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

809 int *
__restrict
 
__sign
) 
__THROW
 
	`__nonnull
 ((3, 4)) 
__wur
;

814 extern char *
	$fcvt
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

815 int *
__restrict
 
__sign
) 
__THROW
 
	`__nonnull
 ((3, 4)) 
__wur
;

820 extern char *
	$gcvt
 (double 
__value
, int 
__ndigit
, char *
__buf
)

821 
__THROW
 
	`__nonnull
 ((3)) 
__wur
;

824 #ifdef 
__USE_MISC


826 extern char *
	$qecvt
 (long double 
__value
, int 
__ndigit
,

827 int *
__restrict
 
__decpt
, int *__restrict 
__sign
)

828 
__THROW
 
	`__nonnull
 ((3, 4)) 
__wur
;

829 extern char *
	$qfcvt
 (long double 
__value
, int 
__ndigit
,

830 int *
__restrict
 
__decpt
, int *__restrict 
__sign
)

831 
__THROW
 
	`__nonnull
 ((3, 4)) 
__wur
;

832 extern char *
	$qgcvt
 (long double 
__value
, int 
__ndigit
, char *
__buf
)

833 
__THROW
 
	`__nonnull
 ((3)) 
__wur
;

838 extern int 
	$ecvt_r
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

839 int *
__restrict
 
__sign
, char *__restrict 
__buf
,

840 
size_t
 
__len
) 
__THROW
 
	`__nonnull
 ((3, 4, 5));

841 extern int 
	$fcvt_r
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

842 int *
__restrict
 
__sign
, char *__restrict 
__buf
,

843 
size_t
 
__len
) 
__THROW
 
	`__nonnull
 ((3, 4, 5));

845 extern int 
	$qecvt_r
 (long double 
__value
, int 
__ndigit
,

846 int *
__restrict
 
__decpt
, int *__restrict 
__sign
,

847 char *
__restrict
 
__buf
, 
size_t
 
__len
)

848 
__THROW
 
	`__nonnull
 ((3, 4, 5));

849 extern int 
	$qfcvt_r
 (long double 
__value
, int 
__ndigit
,

850 int *
__restrict
 
__decpt
, int *__restrict 
__sign
,

851 char *
__restrict
 
__buf
, 
size_t
 
__len
)

852 
__THROW
 
	`__nonnull
 ((3, 4, 5));

857 
__BEGIN_NAMESPACE_STD


860 extern int 
	$mblen
 (
__const
 char *
__s
, 
size_t
 
__n
) 
__THROW
 
__wur
;

863 extern int 
	$mbtowc
 (
wchar_t
 *
__restrict
 
__pwc
,

864 
__const
 char *
__restrict
 
__s
, 
size_t
 
__n
) 
__THROW
 
__wur
;

867 extern int 
	$wctomb
 (char *
__s
, 
wchar_t
 
__wchar
) 
__THROW
 
__wur
;

871 extern 
size_t
 
	$mbstowcs
 (
wchar_t
 *
__restrict
 
__pwcs
,

872 
__const
 char *
__restrict
 
__s
, 
size_t
 
__n
) 
__THROW
;

874 extern 
size_t
 
	$wcstombs
 (char *
__restrict
 
__s
,

875 
__const
 
wchar_t
 *
__restrict
 
__pwcs
, 
size_t
 
__n
)

876 
__THROW
;

877 
__END_NAMESPACE_STD


880 #ifdef 
__USE_SVID


885 extern int 
	$rpmatch
 (
__const
 char *
__response
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

889 #if 
defined
 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K8


896 extern int 
	$getsubopt
 (char **
__restrict
 
__optionp
,

897 char *
__const
 *
__restrict
 
__tokens
,

898 char **
__restrict
 
__valuep
)

899 
__THROW
 
	`__nonnull
 ((1, 2, 3)) 
__wur
;

903 #ifdef 
__USE_XOPEN


905 extern void 
	$setkey
 (
__const
 char *
__key
) 
__THROW
 
	`__nonnull
 ((1));

911 #ifdef 
__USE_XOPEN2KXSI


913 extern int 
	$posix_openpt
 (int 
__oflag
) 
__wur
;

916 #ifdef 
__USE_XOPEN


921 extern int 
	$grantpt
 (int 
__fd
) 
__THROW
;

925 extern int 
	$unlockpt
 (int 
__fd
) 
__THROW
;

930 extern char *
	$ptsname
 (int 
__fd
) 
__THROW
 
__wur
;

933 #ifdef 
__USE_GNU


937 extern int 
	$ptsname_r
 (int 
__fd
, char *
__buf
, 
size_t
 
__buflen
)

938 
__THROW
 
	`__nonnull
 ((2));

941 extern int 
	`getpt
 (void);

944 #ifdef 
__USE_BSD


948 extern int 
	$getloadavg
 (double 
__loadavg
[], int 
__nelem
)

949 
__THROW
 
	`__nonnull
 ((1));

954 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__extern_always_inline


955 #include 
	~<bits/stdlib.h
>

957 #ifdef 
__LDBL_COMPAT


958 #include 
	~<bits/stdlib-ldbl.h
>

962 #undef 
__need_malloc_and_calloc


964 
__END_DECLS


	@/usr/include/string.h

24 #ifndef 
_STRING_H


25 #define 
	#_STRING_H
 1

	)

27 #include 
	~<features.h
>

29 
	g__BEGIN_DECLS


32 #define 
	#__need_size_t


	)

33 #define 
	#__need_NULL


	)

34 #include 
	~<stddef.h
>

37 #if 
defined
 
__cplusplus
 && 
__GNUC_PREREQ
 (4, 4)

38 #define 
	#__CORRECT_ISO_CPP_STRING_H_PROTO


	)

42 
__BEGIN_NAMESPACE_STD


44 extern void *
	$memcpy
 (void *
__restrict
 
__dest
,

45 
__const
 void *
__restrict
 
__src
, 
size_t
 
__n
)

46 
__THROW
 
	`__nonnull
 ((1, 2));

49 extern void *
	$memmove
 (void *
__dest
, 
__const
 void *
__src
, 
size_t
 
__n
)

50 
__THROW
 
	`__nonnull
 ((1, 2));

51 
__END_NAMESPACE_STD


56 #if 
defined
 
__USE_SVID
 || defined 
__USE_BSD
 || defined 
__USE_XOPEN


57 extern void *
	$memccpy
 (void *
__restrict
 
__dest
, 
__const
 void *__restrict 
__src
,

58 int 
__c
, 
size_t
 
__n
)

59 
__THROW
 
	`__nonnull
 ((1, 2));

63 
__BEGIN_NAMESPACE_STD


65 extern void *
	$memset
 (void *
__s
, int 
__c
, 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1));

68 extern int 
	$memcmp
 (
__const
 void *
__s1
, __const void *
__s2
, 
size_t
 
__n
)

69 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

72 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


75 extern void *
	`memchr
 (void *
__s
, int 
__c
, 
size_t
 
__n
)

76 
__THROW
 
	`__asm
 ("memchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

77 extern 
__const
 void *
	`memchr
 (__const void *
__s
, int 
__c
, 
size_t
 
__n
)

78 
__THROW
 
	`__asm
 ("memchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

80 #ifdef 
__OPTIMIZE__


81 
__extern_always_inline
 void *

82 
	`memchr
 (void *
__s
, int 
__c
, 
size_t
 
__n
) 
__THROW


84 return 
	`__builtin_memchr
 (
__s
, 
__c
, 
__n
);

87 
__extern_always_inline
 
__const
 void *

88 
	`memchr
 (
__const
 void *
__s
, int 
__c
, 
size_t
 
__n
) 
__THROW


90 return 
	`__builtin_memchr
 (
__s
, 
__c
, 
__n
);

93 
	}
}

95 extern void *
	$memchr
 (
__const
 void *
__s
, int 
__c
, 
size_t
 
__n
)

96 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

98 
__END_NAMESPACE_STD


100 #ifdef 
__USE_GNU


103 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


104 extern "C++" void *
	$rawmemchr
 (void *
__s
, int 
__c
)

105 
__THROW
 
	`__asm
 ("rawmemchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

106 extern "C++" 
__const
 void *
	$rawmemchr
 (
__const
 void *
__s
, int 
__c
)

107 
__THROW
 
	`__asm
 ("rawmemchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

109 extern void *
	$rawmemchr
 (
__const
 void *
__s
, int 
__c
)

110 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

114 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


115 extern "C++" void *
	$memrchr
 (void *
__s
, int 
__c
, 
size_t
 
__n
)

116 
__THROW
 
	`__asm
 ("memrchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

117 extern "C++" 
__const
 void *
	$memrchr
 (
__const
 void *
__s
, int 
__c
, 
size_t
 
__n
)

118 
__THROW
 
	`__asm
 ("memrchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

120 extern void *
	$memrchr
 (
__const
 void *
__s
, int 
__c
, 
size_t
 
__n
)

121 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

126 
__BEGIN_NAMESPACE_STD


128 extern char *
	$strcpy
 (char *
__restrict
 
__dest
, 
__const
 char *__restrict 
__src
)

129 
__THROW
 
	`__nonnull
 ((1, 2));

131 extern char *
	$strncpy
 (char *
__restrict
 
__dest
,

132 
__const
 char *
__restrict
 
__src
, 
size_t
 
__n
)

133 
__THROW
 
	`__nonnull
 ((1, 2));

136 extern char *
	$strcat
 (char *
__restrict
 
__dest
, 
__const
 char *__restrict 
__src
)

137 
__THROW
 
	`__nonnull
 ((1, 2));

139 extern char *
	$strncat
 (char *
__restrict
 
__dest
, 
__const
 char *__restrict 
__src
,

140 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1, 2));

143 extern int 
	$strcmp
 (
__const
 char *
__s1
, __const char *
__s2
)

144 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

146 extern int 
	$strncmp
 (
__const
 char *
__s1
, __const char *
__s2
, 
size_t
 
__n
)

147 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

150 extern int 
	$strcoll
 (
__const
 char *
__s1
, __const char *
__s2
)

151 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

153 extern 
size_t
 
	$strxfrm
 (char *
__restrict
 
__dest
,

154 
__const
 char *
__restrict
 
__src
, 
size_t
 
__n
)

155 
__THROW
 
	`__nonnull
 ((2));

156 
__END_NAMESPACE_STD


158 #ifdef 
__USE_XOPEN2K8


162 #include 
	~<xlocale.h
>

165 extern int 
	$strcoll_l
 (
__const
 char *
__s1
, __const char *
__s2
, 
__locale_t
 
__l
)

166 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2, 3));

168 extern 
size_t
 
	$strxfrm_l
 (char *
__dest
, 
__const
 char *
__src
, 
size_t
 
__n
,

169 
__locale_t
 
__l
) 
__THROW
 
	`__nonnull
 ((2, 4));

172 #if 
defined
 
__USE_SVID
 || defined 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED
 \

173 || 
defined
 
__USE_XOPEN2K8


175 extern char *
	$strdup
 (
__const
 char *
__s
)

176 
__THROW
 
__attribute_malloc__
 
	`__nonnull
 ((1));

182 #if 
defined
 
__USE_XOPEN2K8


183 extern char *
	$strndup
 (
__const
 char *
__string
, 
size_t
 
__n
)

184 
__THROW
 
__attribute_malloc__
 
	`__nonnull
 ((1));

187 #if 
defined
 
__USE_GNU
 && defined 
__GNUC__


189 #define 
	#strdupa
(
s
) \

190 (
__extension__
 \

192 
__const
 char *
__old
 = (
s
); \

193 
size_t
 
__len
 = 
	`strlen
 (
__old
) + 1; \

194 char *
__new
 = (char *) 
	`__builtin_alloca
 (
__len
); \

195 (char *) 
	`memcpy
 (
__new
, 
__old
, 
__len
); \

196 
	}
}))

	)

199 #define 
	#strndupa
(
s
, 
n
) \

200 (
__extension__
 \

202 
__const
 char *
__old
 = (
s
); \

203 
size_t
 
__len
 = 
	`strnlen
 (
__old
, (
n
)); \

204 char *
__new
 = (char *) 
	`__builtin_alloca
 (
__len
 + 1); \

205 
__new
[
__len
] = '\0'; \

206 (char *) 
	`memcpy
 (
__new
, 
__old
, 
__len
); \

207 }))

	)

210 
	g__BEGIN_NAMESPACE_STD


212 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


215 extern char *
strchr
 (char *
__s
, int 
__c
)

216 
__THROW
 
__asm
 ("strchr") 
__attribute_pure__
 
__nonnull
 ((1));

217 extern 
__const
 char *
strchr
 (__const char *
__s
, int 
__c
)

218 
__THROW
 
__asm
 ("strchr") 
__attribute_pure__
 
__nonnull
 ((1));

220 #ifdef 
__OPTIMIZE__


221 
__extern_always_inline
 char *

222 
strchr
 (char *
__s
, int 
__c
) 
	g__THROW


224 return 
__builtin_strchr
 (
__s
, 
__c
);

227 
__extern_always_inline
 
__const
 char *

228 
strchr
 (
__const
 char *
__s
, int 
__c
) 
	g__THROW


230 return 
__builtin_strchr
 (
__s
, 
__c
);

235 extern char *
	$strchr
 (
__const
 char *
__s
, int 
__c
)

236 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

239 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


242 extern char *
	`strrchr
 (char *
__s
, int 
__c
)

243 
__THROW
 
	`__asm
 ("strrchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

244 extern 
__const
 char *
	`strrchr
 (__const char *
__s
, int 
__c
)

245 
__THROW
 
	`__asm
 ("strrchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

247 #ifdef 
__OPTIMIZE__


248 
__extern_always_inline
 char *

249 
	`strrchr
 (char *
__s
, int 
__c
) 
__THROW


251 return 
	`__builtin_strrchr
 (
__s
, 
__c
);

254 
__extern_always_inline
 
__const
 char *

255 
	`strrchr
 (
__const
 char *
__s
, int 
__c
) 
__THROW


257 return 
	`__builtin_strrchr
 (
__s
, 
__c
);

260 
	}
}

262 extern char *
	$strrchr
 (
__const
 char *
__s
, int 
__c
)

263 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

265 
__END_NAMESPACE_STD


267 #ifdef 
__USE_GNU


270 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


271 extern "C++" char *
	$strchrnul
 (char *
__s
, int 
__c
)

272 
__THROW
 
	`__asm
 ("strchrnul") 
__attribute_pure__
 
	`__nonnull
 ((1));

273 extern "C++" 
__const
 char *
	$strchrnul
 (
__const
 char *
__s
, int 
__c
)

274 
__THROW
 
	`__asm
 ("strchrnul") 
__attribute_pure__
 
	`__nonnull
 ((1));

276 extern char *
	$strchrnul
 (
__const
 char *
__s
, int 
__c
)

277 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

281 
__BEGIN_NAMESPACE_STD


284 extern 
size_t
 
	$strcspn
 (
__const
 char *
__s
, __const char *
__reject
)

285 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

288 extern 
size_t
 
	$strspn
 (
__const
 char *
__s
, __const char *
__accept
)

289 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

291 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


294 extern char *
	`strpbrk
 (char *
__s
, 
__const
 char *
__accept
)

295 
__THROW
 
	`__asm
 ("strpbrk") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

296 extern 
__const
 char *
	`strpbrk
 (__const char *
__s
, __const char *
__accept
)

297 
__THROW
 
	`__asm
 ("strpbrk") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

299 #ifdef 
__OPTIMIZE__


300 
__extern_always_inline
 char *

301 
	`strpbrk
 (char *
__s
, 
__const
 char *
__accept
) 
__THROW


303 return 
	`__builtin_strpbrk
 (
__s
, 
__accept
);

306 
__extern_always_inline
 
__const
 char *

307 
	`strpbrk
 (
__const
 char *
__s
, __const char *
__accept
) 
__THROW


309 return 
	`__builtin_strpbrk
 (
__s
, 
__accept
);

312 
	}
}

314 extern char *
	$strpbrk
 (
__const
 char *
__s
, __const char *
__accept
)

315 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

318 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


321 extern char *
	`strstr
 (char *
__haystack
, 
__const
 char *
__needle
)

322 
__THROW
 
	`__asm
 ("strstr") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

323 extern 
__const
 char *
	`strstr
 (__const char *
__haystack
,

324 
__const
 char *
__needle
)

325 
__THROW
 
	`__asm
 ("strstr") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

327 #ifdef 
__OPTIMIZE__


328 
__extern_always_inline
 char *

329 
	`strstr
 (char *
__haystack
, 
__const
 char *
__needle
) 
__THROW


331 return 
	`__builtin_strstr
 (
__haystack
, 
__needle
);

334 
__extern_always_inline
 
__const
 char *

335 
	`strstr
 (
__const
 char *
__haystack
, __const char *
__needle
) 
__THROW


337 return 
	`__builtin_strstr
 (
__haystack
, 
__needle
);

340 
	}
}

342 extern char *
	$strstr
 (
__const
 char *
__haystack
, __const char *
__needle
)

343 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

348 extern char *
	$strtok
 (char *
__restrict
 
__s
, 
__const
 char *__restrict 
__delim
)

349 
__THROW
 
	`__nonnull
 ((2));

350 
__END_NAMESPACE_STD


354 extern char *
	$__strtok_r
 (char *
__restrict
 
__s
,

355 
__const
 char *
__restrict
 
__delim
,

356 char **
__restrict
 
__save_ptr
)

357 
__THROW
 
	`__nonnull
 ((2, 3));

358 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


359 extern char *
	$strtok_r
 (char *
__restrict
 
__s
, 
__const
 char *__restrict 
__delim
,

360 char **
__restrict
 
__save_ptr
)

361 
__THROW
 
	`__nonnull
 ((2, 3));

364 #ifdef 
__USE_GNU


366 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


367 extern "C++" char *
	$strcasestr
 (char *
__haystack
, 
__const
 char *
__needle
)

368 
__THROW
 
	`__asm
 ("strcasestr") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

369 extern "C++" 
__const
 char *
	$strcasestr
 (
__const
 char *
__haystack
,

370 
__const
 char *
__needle
)

371 
__THROW
 
	`__asm
 ("strcasestr") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

373 extern char *
	$strcasestr
 (
__const
 char *
__haystack
, __const char *
__needle
)

374 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

378 #ifdef 
__USE_GNU


382 extern void *
	$memmem
 (
__const
 void *
__haystack
, 
size_t
 
__haystacklen
,

383 
__const
 void *
__needle
, 
size_t
 
__needlelen
)

384 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 3));

388 extern void *
	$__mempcpy
 (void *
__restrict
 
__dest
,

389 
__const
 void *
__restrict
 
__src
, 
size_t
 
__n
)

390 
__THROW
 
	`__nonnull
 ((1, 2));

391 extern void *
	$mempcpy
 (void *
__restrict
 
__dest
,

392 
__const
 void *
__restrict
 
__src
, 
size_t
 
__n
)

393 
__THROW
 
	`__nonnull
 ((1, 2));

397 
__BEGIN_NAMESPACE_STD


399 extern 
size_t
 
	$strlen
 (
__const
 char *
__s
)

400 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

401 
__END_NAMESPACE_STD


403 #ifdef 
__USE_XOPEN2K8


406 extern 
size_t
 
	$strnlen
 (
__const
 char *
__string
, 
size_t
 
__maxlen
)

407 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

411 
__BEGIN_NAMESPACE_STD


413 extern char *
	$strerror
 (int 
__errnum
) 
__THROW
;

414 
__END_NAMESPACE_STD


415 #if 
defined
 
__USE_XOPEN2K
 || defined 
__USE_MISC


423 #if 
defined
 
__USE_XOPEN2K
 && !defined 
__USE_GNU


426 #ifdef 
__REDIRECT_NTH


427 extern int 
	`__REDIRECT_NTH
 (
strerror_r
,

428 (int 
__errnum
, char *
__buf
, 
size_t
 
__buflen
),

429 
__xpg_strerror_r
) 
	`__nonnull
 ((2));

431 extern int 
	$__xpg_strerror_r
 (int 
__errnum
, char *
__buf
, 
size_t
 
__buflen
)

432 
__THROW
 
	`__nonnull
 ((2));

433 #define 
	#strerror_r
 
__xpg_strerror_r


	)

438 extern char *
	$strerror_r
 (int 
__errnum
, char *
__buf
, 
size_t
 
__buflen
)

439 
__THROW
 
	`__nonnull
 ((2));

443 #ifdef 
__USE_XOPEN2K8


445 extern char *
	$strerror_l
 (int 
__errnum
, 
__locale_t
 
__l
) 
__THROW
;

451 extern void 
	$__bzero
 (void *
__s
, 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1));

453 #ifdef 
__USE_BSD


455 extern void 
	$bcopy
 (
__const
 void *
__src
, void *
__dest
, 
size_t
 
__n
)

456 
__THROW
 
	`__nonnull
 ((1, 2));

459 extern void 
	$bzero
 (void *
__s
, 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1));

462 extern int 
	$bcmp
 (
__const
 void *
__s1
, __const void *
__s2
, 
size_t
 
__n
)

463 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

466 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


469 extern char *
	`index
 (char *
__s
, int 
__c
)

470 
__THROW
 
	`__asm
 ("index") 
__attribute_pure__
 
	`__nonnull
 ((1));

471 extern 
__const
 char *
	`index
 (__const char *
__s
, int 
__c
)

472 
__THROW
 
	`__asm
 ("index") 
__attribute_pure__
 
	`__nonnull
 ((1));

474 #if 
defined
 
__OPTIMIZE__
 && !defined 
__CORRECT_ISO_CPP_STRINGS_H_PROTO


475 
__extern_always_inline
 char *

476 
	`index
 (char *
__s
, int 
__c
) 
__THROW


478 return 
	`__builtin_index
 (
__s
, 
__c
);

481 
__extern_always_inline
 
__const
 char *

482 
	`index
 (
__const
 char *
__s
, int 
__c
) 
__THROW


484 return 
	`__builtin_index
 (
__s
, 
__c
);

487 
	}
}

489 extern char *
	$index
 (
__const
 char *
__s
, int 
__c
)

490 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

494 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


497 extern char *
	`rindex
 (char *
__s
, int 
__c
)

498 
__THROW
 
	`__asm
 ("rindex") 
__attribute_pure__
 
	`__nonnull
 ((1));

499 extern 
__const
 char *
	`rindex
 (__const char *
__s
, int 
__c
)

500 
__THROW
 
	`__asm
 ("rindex") 
__attribute_pure__
 
	`__nonnull
 ((1));

502 #if 
defined
 
__OPTIMIZE__
 && !defined 
__CORRECT_ISO_CPP_STRINGS_H_PROTO


503 
__extern_always_inline
 char *

504 
	`rindex
 (char *
__s
, int 
__c
) 
__THROW


506 return 
	`__builtin_rindex
 (
__s
, 
__c
);

509 
__extern_always_inline
 
__const
 char *

510 
	`rindex
 (
__const
 char *
__s
, int 
__c
) 
__THROW


512 return 
	`__builtin_rindex
 (
__s
, 
__c
);

515 
	}
}

517 extern char *
	$rindex
 (
__const
 char *
__s
, int 
__c
)

518 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

523 extern int 
	$ffs
 (int 
__i
) 
__THROW
 
	`__attribute__
 ((
__const__
));

527 #ifdef 
__USE_GNU


528 extern int 
	$ffsl
 (long int 
__l
) 
__THROW
 
	`__attribute__
 ((
__const__
));

529 #ifdef 
__GNUC__


530 
__extension__
 extern int 
	$ffsll
 (long long int 
__ll
)

531 
__THROW
 
	`__attribute__
 ((
__const__
));

536 extern int 
	$strcasecmp
 (
__const
 char *
__s1
, __const char *
__s2
)

537 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

540 extern int 
	$strncasecmp
 (
__const
 char *
__s1
, __const char *
__s2
, 
size_t
 
__n
)

541 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

544 #ifdef 
__USE_GNU


547 extern int 
	$strcasecmp_l
 (
__const
 char *
__s1
, __const char *
__s2
,

548 
__locale_t
 
__loc
)

549 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2, 3));

551 extern int 
	$strncasecmp_l
 (
__const
 char *
__s1
, __const char *
__s2
,

552 
size_t
 
__n
, 
__locale_t
 
__loc
)

553 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2, 4));

556 #ifdef 
__USE_BSD


559 extern char *
	$strsep
 (char **
__restrict
 
__stringp
,

560 
__const
 char *
__restrict
 
__delim
)

561 
__THROW
 
	`__nonnull
 ((1, 2));

564 #ifdef 
__USE_XOPEN2K8


566 extern char *
	$strsignal
 (int 
__sig
) 
__THROW
;

569 extern char *
	$__stpcpy
 (char *
__restrict
 
__dest
, 
__const
 char *__restrict 
__src
)

570 
__THROW
 
	`__nonnull
 ((1, 2));

571 extern char *
	$stpcpy
 (char *
__restrict
 
__dest
, 
__const
 char *__restrict 
__src
)

572 
__THROW
 
	`__nonnull
 ((1, 2));

576 extern char *
	$__stpncpy
 (char *
__restrict
 
__dest
,

577 
__const
 char *
__restrict
 
__src
, 
size_t
 
__n
)

578 
__THROW
 
	`__nonnull
 ((1, 2));

579 extern char *
	$stpncpy
 (char *
__restrict
 
__dest
,

580 
__const
 char *
__restrict
 
__src
, 
size_t
 
__n
)

581 
__THROW
 
	`__nonnull
 ((1, 2));

584 #ifdef 
__USE_GNU


586 extern int 
	$strverscmp
 (
__const
 char *
__s1
, __const char *
__s2
)

587 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

590 extern char *
	$strfry
 (char *
__string
) 
__THROW
 
	`__nonnull
 ((1));

593 extern void *
	$memfrob
 (void *
__s
, 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1));

595 #ifndef 
basename


600 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


601 extern "C++" char *
	$basename
 (char *
__filename
)

602 
__THROW
 
	`__asm
 ("basename") 
	`__nonnull
 ((1));

603 extern "C++" 
__const
 char *
	$basename
 (
__const
 char *
__filename
)

604 
__THROW
 
	`__asm
 ("basename") 
	`__nonnull
 ((1));

606 extern char *
	$basename
 (
__const
 char *
__filename
) 
__THROW
 
	`__nonnull
 ((1));

612 #if 
defined
 
__GNUC__
 && __GNUC__ >= 2

613 #if 
defined
 
__OPTIMIZE__
 && !defined 
__OPTIMIZE_SIZE__
 \

614 && !
defined
 
__NO_INLINE__
 && !defined 
__cplusplus


634 #include 
	~<bits/string.h
>

637 #include 
	~<bits/string2.h
>

640 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__extern_always_inline


642 #include 
	~<bits/string3.h
>

646 
__END_DECLS


	@/usr/include/bits/cmathcalls.h

44 #ifndef 
_COMPLEX_H


48 #define 
	#_Mdouble_complex_
 
_Mdouble_
 
_Complex


	)

54 
__MATHCALL
 (
cacos
, (
_Mdouble_complex_
 
__z
));

56 
__MATHCALL
 (
casin
, (
_Mdouble_complex_
 
__z
));

58 
__MATHCALL
 (
catan
, (
_Mdouble_complex_
 
__z
));

61 
__MATHCALL
 (
ccos
, (
_Mdouble_complex_
 
__z
));

63 
__MATHCALL
 (
csin
, (
_Mdouble_complex_
 
__z
));

65 
__MATHCALL
 (
ctan
, (
_Mdouble_complex_
 
__z
));

71 
__MATHCALL
 (
cacosh
, (
_Mdouble_complex_
 
__z
));

73 
__MATHCALL
 (
casinh
, (
_Mdouble_complex_
 
__z
));

75 
__MATHCALL
 (
catanh
, (
_Mdouble_complex_
 
__z
));

78 
__MATHCALL
 (
ccosh
, (
_Mdouble_complex_
 
__z
));

80 
__MATHCALL
 (
csinh
, (
_Mdouble_complex_
 
__z
));

82 
__MATHCALL
 (
ctanh
, (
_Mdouble_complex_
 
__z
));

88 
__MATHCALL
 (
cexp
, (
_Mdouble_complex_
 
__z
));

91 
__MATHCALL
 (
clog
, (
_Mdouble_complex_
 
__z
));

93 #ifdef 
__USE_GNU


96 
__MATHCALL
 (
clog10
, (
_Mdouble_complex_
 
__z
));

102 
__MATHCALL
 (
cpow
, (
_Mdouble_complex_
 
__x
, _Mdouble_complex_ 
__y
));

105 
__MATHCALL
 (
csqrt
, (
_Mdouble_complex_
 
__z
));

111 
__MATHDECL
 (
_Mdouble_
,
cabs
, (
_Mdouble_complex_
 
__z
));

114 
__MATHDECL
 (
_Mdouble_
,
carg
, (
_Mdouble_complex_
 
__z
));

117 
__MATHCALL
 (
conj
, (
_Mdouble_complex_
 
__z
));

120 
__MATHCALL
 (
cproj
, (
_Mdouble_complex_
 
__z
));

126 
__MATHDECL
 (
_Mdouble_
,
cimag
, (
_Mdouble_complex_
 
__z
));

129 
__MATHDECL
 (
_Mdouble_
,
creal
, (
_Mdouble_complex_
 
__z
));

135 #if 
defined
 
__GNUC__
 && !
__GNUC_PREREQ
 (2, 97) && defined 
__OPTIMIZE__
 \

136 && 
defined
 
__extern_inline


139 
__extern_inline
 
_Mdouble_


140 
	$__MATH_PRECNAME
(
cimag
) (
_Mdouble_complex_
 
__z
) 
__THROW


142 return 
__imag__
 
__z
;

143 
	}
}

146 
__extern_inline
 
_Mdouble_


147 
	$__MATH_PRECNAME
(
creal
) (
_Mdouble_complex_
 
__z
) 
__THROW


149 return 
__real__
 
__z
;

150 
	}
}

153 
__extern_inline
 
_Mdouble_complex_


154 
	$__MATH_PRECNAME
(
conj
) (
_Mdouble_complex_
 
__z
) 
__THROW


156 return 
__extension__
 ~
__z
;

157 
	}
}

	@/usr/include/bits/errno.h

20 #ifdef 
_ERRNO_H


22 #undef 
EDOM


23 #undef 
EILSEQ


24 #undef 
ERANGE


25 #include 
	~<linux/errno.h
>

28 #define 
	#ENOTSUP
 
EOPNOTSUPP


	)

31 #ifndef 
ECANCELED


32 #define 
	#ECANCELED
 125

	)

36 #ifndef 
EOWNERDEAD


37 #define 
	#EOWNERDEAD
 130

	)

38 #define 
	#ENOTRECOVERABLE
 131

	)

41 #ifndef 
ERFKILL


42 #define 
	#ERFKILL
 132

	)

45 #ifndef 
__ASSEMBLER__


47 extern int *
	$__errno_location
 (void) 
__THROW
 
	`__attribute__
 ((
__const__
));

49 #if !
defined
 
_LIBC
 || defined 
_LIBC_REENTRANT


51 #define 
	#errno
 (*
	`__errno_location
 ())

	)

56 #if !
defined
 
_ERRNO_H
 && defined 
__need_Emath


60 #define 
	#EDOM
 33

	)

61 #define 
	#EILSEQ
 84

	)

62 #define 
	#ERANGE
 34

	)

	@/usr/include/bits/huge_val.h

22 #ifndef 
_MATH_H


28 #if 
__GNUC_PREREQ
(3,3)

29 #define 
	#HUGE_VAL
 (
	`__builtin_huge_val
())

	)

30 #elif 
__GNUC_PREREQ
(2,96)

31 #define 
	#HUGE_VAL
 (
__extension__
 0x1.0
p2047
)

	)

32 #elif 
defined
 
__GNUC__


34 #define 
	#HUGE_VAL
 \

35 (
__extension__
 \

36 ((union { unsigned 
__l
 
	`__attribute__
((
	`__mode__
(
__DI__
))); double 
__d
; }) \

37 { 
__l
: 0x7ff0000000000000ULL }).
__d
)

	)

41 #include 
	~<endian.h
>

43 typedef union { unsigned char 
	m__c
[8]; double 
	m__d
; } 
	t__huge_val_t
;

45 #if 
__BYTE_ORDER
 == 
__BIG_ENDIAN


46 #define 
	#__HUGE_VAL_bytes
 { 0x7f, 0xf0, 0, 0, 0, 0, 0, 0 }

	)

48 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


49 #define 
	#__HUGE_VAL_bytes
 { 0, 0, 0, 0, 0, 0, 0xf0, 0x7f }

	)

52 static 
__huge_val_t
 
	g__huge_val
 = { 
__HUGE_VAL_bytes
 };

53 #define 
	#HUGE_VAL
 (
__huge_val
.
__d
)

	)

	@/usr/include/bits/huge_valf.h

22 #ifndef 
_MATH_H


28 #if 
__GNUC_PREREQ
(3,3)

29 #define 
	#HUGE_VALF
 (
	`__builtin_huge_valf
())

	)

30 #elif 
__GNUC_PREREQ
(2,96)

31 #define 
	#HUGE_VALF
 (
__extension__
 0x1.0
p255f
)

	)

32 #elif 
defined
 
__GNUC__


34 #define 
	#HUGE_VALF
 \

35 (
__extension__
 \

36 ((union { unsigned 
__l
 
	`__attribute__
((
	`__mode__
(
__SI__
))); float 
__d
; }) \

37 { 
__l
: 0x7f800000UL }).
__d
)

	)

41 typedef union { unsigned char 
	m__c
[4]; float 
	m__f
; } 
	t__huge_valf_t
;

43 #if 
__BYTE_ORDER
 == 
__BIG_ENDIAN


44 #define 
	#__HUGE_VALF_bytes
 { 0x7f, 0x80, 0, 0 }

	)

46 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


47 #define 
	#__HUGE_VALF_bytes
 { 0, 0, 0x80, 0x7f }

	)

50 static 
__huge_valf_t
 
	g__huge_valf
 = { 
__HUGE_VALF_bytes
 };

51 #define 
	#HUGE_VALF
 (
__huge_valf
.
__f
)

	)

	@/usr/include/bits/huge_vall.h

21 #ifndef 
_MATH_H


25 #if 
__GNUC_PREREQ
(3,3)

26 #define 
	#HUGE_VALL
 (
	`__builtin_huge_vall
())

	)

28 #define 
	#HUGE_VALL
 ((long double) 
HUGE_VAL
)

	)

	@/usr/include/bits/inf.h

20 #ifndef 
_MATH_H


26 #if 
__GNUC_PREREQ
(3,3)

27 #define 
	#INFINITY
 (
	`__builtin_inff
())

	)

29 #define 
	#INFINITY
 
HUGE_VALF


	)

	@/usr/include/bits/mathcalls.h

46 #ifndef 
_MATH_H


53 
_Mdouble_BEGIN_NAMESPACE


55 
__MATHCALL
 (
acos
,, (
_Mdouble_
 
__x
));

57 
__MATHCALL
 (
asin
,, (
_Mdouble_
 
__x
));

59 
__MATHCALL
 (
atan
,, (
_Mdouble_
 
__x
));

61 
__MATHCALL
 (
atan2
,, (
_Mdouble_
 
__y
, _Mdouble_ 
__x
));

64 
__MATHCALL
 (
cos
,, (
_Mdouble_
 
__x
));

66 
__MATHCALL
 (
sin
,, (
_Mdouble_
 
__x
));

68 
__MATHCALL
 (
tan
,, (
_Mdouble_
 
__x
));

73 
__MATHCALL
 (
cosh
,, (
_Mdouble_
 
__x
));

75 
__MATHCALL
 (
sinh
,, (
_Mdouble_
 
__x
));

77 
__MATHCALL
 (
tanh
,, (
_Mdouble_
 
__x
));

78 
	g_Mdouble_END_NAMESPACE


80 #ifdef 
__USE_GNU


82 
__MATHDECL
 (void,
sincos
,,

83 (
_Mdouble_
 
__x
, _Mdouble_ *
__sinx
, _Mdouble_ *
__cosx
));

86 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_ISOC99


87 
__BEGIN_NAMESPACE_C99


89 
__MATHCALL
 (
acosh
,, (
_Mdouble_
 
__x
));

91 
__MATHCALL
 (
asinh
,, (
_Mdouble_
 
__x
));

93 
__MATHCALL
 (
atanh
,, (
_Mdouble_
 
__x
));

94 
	g__END_NAMESPACE_C99


99 
_Mdouble_BEGIN_NAMESPACE


101 
__MATHCALL
 (
exp
,, (
_Mdouble_
 
__x
));

104 
__MATHCALL
 (
frexp
,, (
_Mdouble_
 
__x
, int *
__exponent
));

107 
__MATHCALL
 (
ldexp
,, (
_Mdouble_
 
__x
, int 
__exponent
));

110 
__MATHCALL
 (
log
,, (
_Mdouble_
 
__x
));

113 
__MATHCALL
 (
log10
,, (
_Mdouble_
 
__x
));

116 
__MATHCALL
 (
modf
,, (
_Mdouble_
 
__x
, _Mdouble_ *
__iptr
));

117 
	g_Mdouble_END_NAMESPACE


119 #ifdef 
__USE_GNU


121 
__MATHCALL
 (
exp10
,, (
_Mdouble_
 
__x
));

123 
__MATHCALL
 (
pow10
,, (
_Mdouble_
 
__x
));

126 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_ISOC99


127 
__BEGIN_NAMESPACE_C99


129 
__MATHCALL
 (
expm1
,, (
_Mdouble_
 
__x
));

132 
__MATHCALL
 (
log1p
,, (
_Mdouble_
 
__x
));

135 
__MATHCALL
 (
logb
,, (
_Mdouble_
 
__x
));

136 
	g__END_NAMESPACE_C99


139 #ifdef 
__USE_ISOC99


140 
__BEGIN_NAMESPACE_C99


142 
__MATHCALL
 (
exp2
,, (
_Mdouble_
 
__x
));

145 
__MATHCALL
 (
log2
,, (
_Mdouble_
 
__x
));

146 
	g__END_NAMESPACE_C99


152 
_Mdouble_BEGIN_NAMESPACE


154 
__MATHCALL
 (
pow
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
));

157 
__MATHCALL
 (
sqrt
,, (
_Mdouble_
 
__x
));

158 
	g_Mdouble_END_NAMESPACE


160 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN
 || defined 
__USE_ISOC99


161 
__BEGIN_NAMESPACE_C99


163 
__MATHCALL
 (
hypot
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
));

164 
	g__END_NAMESPACE_C99


167 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_ISOC99


168 
__BEGIN_NAMESPACE_C99


170 
__MATHCALL
 (
cbrt
,, (
_Mdouble_
 
__x
));

171 
	g__END_NAMESPACE_C99


177 
_Mdouble_BEGIN_NAMESPACE


179 
__MATHCALLX
 (
ceil
,, (
_Mdouble_
 
__x
), (
__const__
));

182 
__MATHCALLX
 (
fabs
,, (
_Mdouble_
 
__x
), (
__const__
));

185 
__MATHCALLX
 (
floor
,, (
_Mdouble_
 
__x
), (
__const__
));

188 
__MATHCALL
 (
fmod
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
));

193 
__MATHDECL_1
 (int,
__isinf
,, (
_Mdouble_
 
__value
)) 
__attribute__
 ((
__const__
));

196 
__MATHDECL_1
 (int,
__finite
,, (
_Mdouble_
 
__value
)) 
__attribute__
 ((
__const__
));

197 
	g_Mdouble_END_NAMESPACE


199 #ifdef 
__USE_MISC


202 
__MATHDECL_1
 (int,
isinf
,, (
_Mdouble_
 
__value
)) 
__attribute__
 ((
__const__
));

205 
__MATHDECL_1
 (int,
finite
,, (
_Mdouble_
 
__value
)) 
__attribute__
 ((
__const__
));

208 
__MATHCALL
 (
drem
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
));

212 
__MATHCALL
 (
significand
,, (
_Mdouble_
 
__x
));

215 #if 
defined
 
__USE_MISC
 || defined 
__USE_ISOC99


216 
__BEGIN_NAMESPACE_C99


218 
__MATHCALLX
 (
copysign
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
), (
__const__
));

219 
	g__END_NAMESPACE_C99


222 #ifdef 
__USE_ISOC99


223 
__BEGIN_NAMESPACE_C99


225 
__MATHCALLX
 (
nan
,, (
__const
 char *
__tagb
), (
__const__
));

226 
	g__END_NAMESPACE_C99


231 
__MATHDECL_1
 (int,
__isnan
,, (
_Mdouble_
 
__value
)) 
__attribute__
 ((
__const__
));

233 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN


235 
__MATHDECL_1
 (int,
isnan
,, (
_Mdouble_
 
__value
)) 
__attribute__
 ((
__const__
));

238 
__MATHCALL
 (
j0
,, (
_Mdouble_
));

239 
__MATHCALL
 (
j1
,, (
_Mdouble_
));

240 
__MATHCALL
 (
jn
,, (int, 
_Mdouble_
));

241 
__MATHCALL
 (
y0
,, (
_Mdouble_
));

242 
__MATHCALL
 (
y1
,, (
_Mdouble_
));

243 
__MATHCALL
 (
yn
,, (int, 
_Mdouble_
));

247 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN
 || defined 
__USE_ISOC99


248 
__BEGIN_NAMESPACE_C99


250 
__MATHCALL
 (
erf
,, (
_Mdouble_
));

251 
__MATHCALL
 (
erfc
,, (
_Mdouble_
));

252 
__MATHCALL
 (
lgamma
,, (
_Mdouble_
));

253 
	g__END_NAMESPACE_C99


256 #ifdef 
__USE_ISOC99


257 
__BEGIN_NAMESPACE_C99


259 
__MATHCALL
 (
tgamma
,, (
_Mdouble_
));

260 
	g__END_NAMESPACE_C99


263 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN


265 
__MATHCALL
 (
gamma
,, (
_Mdouble_
));

268 #ifdef 
__USE_MISC


272 
__MATHCALL
 (
lgamma
,
_r
, (
_Mdouble_
, int *
__signgamp
));

276 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_ISOC99


277 
__BEGIN_NAMESPACE_C99


280 
__MATHCALL
 (
rint
,, (
_Mdouble_
 
__x
));

283 
__MATHCALLX
 (
nextafter
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
), (
__const__
));

284 #if 
defined
 
__USE_ISOC99
 && !defined 
__LDBL_COMPAT


285 
__MATHCALLX
 (
nexttoward
,, (
_Mdouble_
 
__x
, long double 
__y
), (
__const__
));

289 
__MATHCALL
 (
remainder
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
));

291 #if 
defined
 
__USE_MISC
 || defined 
__USE_ISOC99


293 
__MATHCALL
 (
scalbn
,, (
_Mdouble_
 
__x
, int 
__n
));

297 
__MATHDECL
 (int,
ilogb
,, (
_Mdouble_
 
__x
));

300 #ifdef 
__USE_ISOC99


302 
__MATHCALL
 (
scalbln
,, (
_Mdouble_
 
__x
, long int 
__n
));

306 
__MATHCALL
 (
nearbyint
,, (
_Mdouble_
 
__x
));

310 
__MATHCALLX
 (
round
,, (
_Mdouble_
 
__x
), (
__const__
));

314 
__MATHCALLX
 (
trunc
,, (
_Mdouble_
 
__x
), (
__const__
));

319 
__MATHCALL
 (
remquo
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
, int *
__quo
));

326 
__MATHDECL
 (long int,
lrint
,, (
_Mdouble_
 
__x
));

327 
__MATHDECL
 (long long int,
llrint
,, (
_Mdouble_
 
__x
));

331 
__MATHDECL
 (long int,
lround
,, (
_Mdouble_
 
__x
));

332 
__MATHDECL
 (long long int,
llround
,, (
_Mdouble_
 
__x
));

336 
__MATHCALL
 (
fdim
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
));

339 
__MATHCALL
 (
fmax
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
));

342 
__MATHCALL
 (
fmin
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
));

346 
__MATHDECL_1
 (int, 
__fpclassify
,, (
_Mdouble_
 
__value
))

347 
__attribute__
 ((
__const__
));

350 
__MATHDECL_1
 (int, 
__signbit
,, (
_Mdouble_
 
__value
))

351 
__attribute__
 ((
__const__
));

355 
__MATHCALL
 (
fma
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
, _Mdouble_ 
__z
));

358 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_ISOC99


359 
	g__END_NAMESPACE_C99


362 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED


364 
__MATHCALL
 (
scalb
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__n
));

	@/usr/include/bits/mathdef.h

19 #if !
defined
 
_MATH_H
 && !defined 
_COMPLEX_H


23 #if 
defined
 
__USE_ISOC99
 && defined 
_MATH_H
 && !defined 
_MATH_H_MATHDEF


24 #define 
	#_MATH_H_MATHDEF
 1

	)

26 #include 
	~<bits/wordsize.h
>

28 #if 
__WORDSIZE
 == 64 || (
defined
 
__FLT_EVAL_METHOD__
 && __FLT_EVAL_METHOD__ == 0)

31 typedef float 
	tfloat_t
;

32 typedef double 
	tdouble_t
;

38 typedef long double 
	tfloat_t
;

40 typedef long double 
	tdouble_t
;

45 #define 
	#FP_ILOGB0
 (-2147483647 - 1)

	)

46 #define 
	#FP_ILOGBNAN
 (-2147483647 - 1)

	)

	@/usr/include/bits/mathinline.h

21 #ifndef 
_MATH_H


25 #include 
	~<bits/wordsize.h
>

27 #ifndef 
__extern_inline


28 #define 
	#__MATH_INLINE
 
__inline


	)

30 #define 
	#__MATH_INLINE
 
__extern_inline


	)

34 #if 
defined
 
__USE_ISOC99
 && defined 
__GNUC__
 && __GNUC__ >= 2

37 
__MATH_INLINE
 int

38 
__NTH
 (
	$__signbitf
 (float 
__x
))

40 #if 
__WORDSIZE
 == 32

41 
__extension__
 union { float 
__f
; int 
__i
; } 
__u
 = { __f: 
__x
 };

42 return 
__u
.
__i
 < 0;

44 int 
__m
;

45 
	`__asm
 ("pmovmskb %1, %0" : "=r" (
__m
) : "x" (
__x
));

46 return 
__m
 & 0x8;

48 
	}
}

49 
__MATH_INLINE
 int

50 
__NTH
 (
	$__signbit
 (double 
__x
))

52 #if 
__WORDSIZE
 == 32

53 
__extension__
 union { double 
__d
; int 
__i
[2]; } 
__u
 = { __d: 
__x
 };

54 return 
__u
.
__i
[1] < 0;

56 int 
__m
;

57 
	`__asm
 ("pmovmskb %1, %0" : "=r" (
__m
) : "x" (
__x
));

58 return 
__m
 & 0x80;

60 
	}
}

61 
__MATH_INLINE
 int

62 
__NTH
 (
	$__signbitl
 (long double 
__x
))

64 
__extension__
 union { long double 
__l
; int 
__i
[3]; } 
__u
 = { __l: 
__x
 };

65 return (
__u
.
__i
[2] & 0x8000) != 0;

66 
	}
}

	@/usr/include/bits/nan.h

20 #ifndef 
_MATH_H


27 #if 
__GNUC_PREREQ
(3,3)

29 #define 
	#NAN
 (
	`__builtin_nanf
 (""))

	)

31 #elif 
defined
 
__GNUC__


33 #define 
	#NAN
 \

34 (
__extension__
 \

35 ((union { unsigned 
__l
 
	`__attribute__
 ((
	`__mode__
 (
__SI__
))); float 
__d
; }) \

36 { 
__l
: 0x7fc00000UL }).
__d
)

	)

40 #include 
	~<endian.h
>

42 #if 
__BYTE_ORDER
 == 
__BIG_ENDIAN


43 #define 
	#__nan_bytes
 { 0x7f, 0xc0, 0, 0 }

	)

45 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


46 #define 
	#__nan_bytes
 { 0, 0, 0xc0, 0x7f }

	)

49 static union { unsigned char 
	m__c
[4]; float 
	m__d
; } 
__nan_union


50 
	g__attribute_used__
 = { 
__nan_bytes
 };

51 #define 
	#NAN
 (
__nan_union
.
__d
)

	)

	@/usr/include/bits/stdio-ldbl.h

20 #ifndef 
_STDIO_H


24 
__BEGIN_NAMESPACE_STD


25 
	$__LDBL_REDIR_DECL
 (
fprintf
)

26 
	$__LDBL_REDIR_DECL
 (
printf
)

27 
	$__LDBL_REDIR_DECL
 (
sprintf
)

28 
	$__LDBL_REDIR_DECL
 (
vfprintf
)

29 
	$__LDBL_REDIR_DECL
 (
vprintf
)

30 
	$__LDBL_REDIR_DECL
 (
vsprintf
)

31 #if 
defined
 
__USE_ISOC99
 && !defined 
__USE_GNU
 \

32 && !
defined
 
__REDIRECT
 \

33 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

34 
	$__LDBL_REDIR1_DECL
 (
fscanf
, 
__nldbl___isoc99_fscanf
)

35 
	$__LDBL_REDIR1_DECL
 (
scanf
, 
__nldbl___isoc99_scanf
)

36 
	$__LDBL_REDIR1_DECL
 (
sscanf
, 
__nldbl___isoc99_sscanf
)

38 
	$__LDBL_REDIR_DECL
 (
fscanf
)

39 
	$__LDBL_REDIR_DECL
 (
scanf
)

40 
	$__LDBL_REDIR_DECL
 (
sscanf
)

42 
__END_NAMESPACE_STD


44 #if 
defined
 
__USE_BSD
 || defined 
__USE_ISOC99
 || defined 
__USE_UNIX98


45 
__BEGIN_NAMESPACE_C99


46 
	$__LDBL_REDIR_DECL
 (
snprintf
)

47 
	$__LDBL_REDIR_DECL
 (
vsnprintf
)

48 
__END_NAMESPACE_C99


51 #ifdef 
__USE_ISOC99


52 
__BEGIN_NAMESPACE_C99


53 #if !
defined
 
__USE_GNU
 && !defined 
__REDIRECT
 \

54 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

55 
	$__LDBL_REDIR1_DECL
 (
vfscanf
, 
__nldbl___isoc99_vfscanf
)

56 
	$__LDBL_REDIR1_DECL
 (
vscanf
, 
__nldbl___isoc99_vscanf
)

57 
	$__LDBL_REDIR1_DECL
 (
vsscanf
, 
__nldbl___isoc99_vsscanf
)

59 
	$__LDBL_REDIR_DECL
 (
vfscanf
)

60 
	$__LDBL_REDIR_DECL
 (
vsscanf
)

61 
	$__LDBL_REDIR_DECL
 (
vscanf
)

63 
__END_NAMESPACE_C99


66 #ifdef 
__USE_GNU


67 
	$__LDBL_REDIR_DECL
 (
vdprintf
)

68 
	$__LDBL_REDIR_DECL
 (
dprintf
)

69 
	$__LDBL_REDIR_DECL
 (
vasprintf
)

70 
	$__LDBL_REDIR_DECL
 (
__asprintf
)

71 
	$__LDBL_REDIR_DECL
 (
asprintf
)

72 
	$__LDBL_REDIR_DECL
 (
obstack_printf
)

73 
	$__LDBL_REDIR_DECL
 (
obstack_vprintf
)

76 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__extern_always_inline


77 
	$__LDBL_REDIR_DECL
 (
__sprintf_chk
)

78 
	$__LDBL_REDIR_DECL
 (
__vsprintf_chk
)

79 #if 
defined
 
__USE_BSD
 || defined 
__USE_ISOC99
 || defined 
__USE_UNIX98


80 
	$__LDBL_REDIR_DECL
 (
__snprintf_chk
)

81 
	$__LDBL_REDIR_DECL
 (
__vsnprintf_chk
)

83 #if 
__USE_FORTIFY_LEVEL
 > 1

84 
	$__LDBL_REDIR_DECL
 (
__fprintf_chk
)

85 
	$__LDBL_REDIR_DECL
 (
__printf_chk
)

86 
	$__LDBL_REDIR_DECL
 (
__vfprintf_chk
)

87 
	$__LDBL_REDIR_DECL
 (
__vprintf_chk
)

88 #ifdef 
__USE_GNU


89 
	$__LDBL_REDIR_DECL
 (
__asprintf_chk
)

90 
	$__LDBL_REDIR_DECL
 (
__vasprintf_chk
)

91 
	$__LDBL_REDIR_DECL
 (
__dprintf_chk
)

92 
	$__LDBL_REDIR_DECL
 (
__vdprintf_chk
)

93 
	$__LDBL_REDIR_DECL
 (
__obstack_printf_chk
)

94 
	$__LDBL_REDIR_DECL
 (
__obstack_vprintf_chk
)

	@/usr/include/bits/stdio.h

20 #ifndef 
_STDIO_H


24 #ifndef 
__extern_inline


25 #define 
	#__STDIO_INLINE
 
inline


	)

27 #define 
	#__STDIO_INLINE
 
__extern_inline


	)

31 #ifdef 
__USE_EXTERN_INLINES


34 #if !(
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__extern_always_inline
)

36 
__STDIO_INLINE
 int

37 
	$vprintf
 (
__const
 char *
__restrict
 
__fmt
, 
_G_va_list
 
__arg
)

39 return 
	`vfprintf
 (
stdout
, 
__fmt
, 
__arg
);

40 
	}
}

44 
__STDIO_INLINE
 int

45 
	$getchar
 (void)

47 return 
	`_IO_getc
 (
stdin
);

48 
	}
}

51 #ifdef 
__USE_MISC


53 
__STDIO_INLINE
 int

54 
	$fgetc_unlocked
 (
FILE
 *
__fp
)

56 return 
	`_IO_getc_unlocked
 (
__fp
);

57 
	}
}

61 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


63 
__STDIO_INLINE
 int

64 
	$getc_unlocked
 (
FILE
 *
__fp
)

66 return 
	`_IO_getc_unlocked
 (
__fp
);

67 
	}
}

70 
__STDIO_INLINE
 int

71 
	$getchar_unlocked
 (void)

73 return 
	`_IO_getc_unlocked
 (
stdin
);

74 
	}
}

79 
__STDIO_INLINE
 int

80 
	$putchar
 (int 
__c
)

82 return 
	`_IO_putc
 (
__c
, 
stdout
);

83 
	}
}

86 #ifdef 
__USE_MISC


88 
__STDIO_INLINE
 int

89 
	$fputc_unlocked
 (int 
__c
, 
FILE
 *
__stream
)

91 return 
	`_IO_putc_unlocked
 (
__c
, 
__stream
);

92 
	}
}

96 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


98 
__STDIO_INLINE
 int

99 
	$putc_unlocked
 (int 
__c
, 
FILE
 *
__stream
)

101 return 
	`_IO_putc_unlocked
 (
__c
, 
__stream
);

102 
	}
}

105 
__STDIO_INLINE
 int

106 
	$putchar_unlocked
 (int 
__c
)

108 return 
	`_IO_putc_unlocked
 (
__c
, 
stdout
);

109 
	}
}

113 #ifdef 
__USE_GNU


115 
__STDIO_INLINE
 
_IO_ssize_t


116 
	$getline
 (char **
__lineptr
, 
size_t
 *
__n
, 
FILE
 *
__stream
)

118 return 
	`__getdelim
 (
__lineptr
, 
__n
, '\n', 
__stream
);

119 
	}
}

123 #ifdef 
__USE_MISC


125 
__STDIO_INLINE
 int

126 
__NTH
 (
	$feof_unlocked
 (
FILE
 *
__stream
))

128 return 
	`_IO_feof_unlocked
 (
__stream
);

129 
	}
}

132 
__STDIO_INLINE
 int

133 
__NTH
 (
	$ferror_unlocked
 (
FILE
 *
__stream
))

135 return 
	`_IO_ferror_unlocked
 (
__stream
);

136 
	}
}

142 #if 
defined
 
__USE_MISC
 && defined 
__GNUC__
 && defined 
__OPTIMIZE__
 \

143 && !
defined
 
	g__cplusplus


145 #define 
	#fread_unlocked
(
ptr
, 
size
, 
n
, 
stream
) \

146 (
	`__extension__
 ((
	`__builtin_constant_p
 (
size
) && __builtin_constant_p (
n
) \

147 && (
size_t
) (
size
) * (size_t) (
n
) <= 8 \

148 && (
size_t
) (
size
) != 0) \

149 ? ({ char *
__ptr
 = (char *) (
ptr
); \

150 
FILE
 *
__stream
 = (
stream
); \

151 
size_t
 
__cnt
; \

152 for (
__cnt
 = (
size_t
) (
size
) * (size_t) (
n
); \

153 
__cnt
 > 0; --__cnt) \

155 int 
__c
 = 
	`_IO_getc_unlocked
 (
__stream
); \

156 if (
__c
 == 
EOF
) \

158 *
__ptr
++ = 
__c
; \

160 ((
size_t
) (
size
) * (size_t) (
n
) - 
__cnt
) \

161 / (
size_t
) (
size
); }) \

162 : (((
	`__builtin_constant_p
 (
size
) && (
size_t
) (size) == 0) \

163 || (
	`__builtin_constant_p
 (
n
) && (
size_t
) (n) == 0)) \

165 ? ((void) (
ptr
), (void) (
stream
), (void) (
size
), \

166 (void) (
n
), (
size_t
) 0) \

167 : 
	`fread_unlocked
 (
ptr
, 
size
, 
n
, 
stream
))))

	)

169 #define 
	#fwrite_unlocked
(
ptr
, 
size
, 
n
, 
stream
) \

170 (
	`__extension__
 ((
	`__builtin_constant_p
 (
size
) && __builtin_constant_p (
n
) \

171 && (
size_t
) (
size
) * (size_t) (
n
) <= 8 \

172 && (
size_t
) (
size
) != 0) \

173 ? ({ const char *
__ptr
 = (const char *) (
ptr
); \

174 
FILE
 *
__stream
 = (
stream
); \

175 
size_t
 
__cnt
; \

176 for (
__cnt
 = (
size_t
) (
size
) * (size_t) (
n
); \

177 
__cnt
 > 0; --__cnt) \

178 if (
	`_IO_putc_unlocked
 (*
__ptr
++, 
__stream
) == 
EOF
) \

180 ((
size_t
) (
size
) * (size_t) (
n
) - 
__cnt
) \

181 / (
size_t
) (
size
); }) \

182 : (((
	`__builtin_constant_p
 (
size
) && (
size_t
) (size) == 0) \

183 || (
	`__builtin_constant_p
 (
n
) && (
size_t
) (n) == 0)) \

185 ? ((void) (
ptr
), (void) (
stream
), (void) (
size
), \

186 (void) (
n
), (
size_t
) 0) \

187 : 
	`fwrite_unlocked
 (
ptr
, 
size
, 
n
, 
stream
))))

	)

191 #undef 
__STDIO_INLINE


	@/usr/include/bits/stdio2.h

20 #ifndef 
_STDIO_H


24 extern int 
	$__sprintf_chk
 (char *
__restrict
 
__s
, int 
__flag
, 
size_t
 
__slen
,

25 
__const
 char *
__restrict
 
__format
, ...) 
__THROW
;

26 extern int 
	$__vsprintf_chk
 (char *
__restrict
 
__s
, int 
__flag
, 
size_t
 
__slen
,

27 
__const
 char *
__restrict
 
__format
,

28 
_G_va_list
 
__ap
) 
__THROW
;

30 #ifdef 
__va_arg_pack


31 
__extern_always_inline
 int

32 
	`__NTH
 (
	$sprintf
 (char *
__restrict
 
__s
, 
__const
 char *__restrict 
__fmt
, ...))

34 return 
	`__builtin___sprintf_chk
 (
__s
, 
__USE_FORTIFY_LEVEL
 - 1,

35 
	`__bos
 (
__s
), 
__fmt
, 
	`__va_arg_pack
 ());

36 
	}
}

37 #elif !
defined
 
__cplusplus


38 #define 
	#sprintf
(
str
, ...) \

39 
	`__builtin___sprintf_chk
 (
str
, 
__USE_FORTIFY_LEVEL
 - 1, 
	`__bos
 (str), \

40 
__VA_ARGS__
)

	)

43 
__extern_always_inline
 int

44 
__NTH
 (
	$vsprintf
 (char *
__restrict
 
__s
, 
__const
 char *__restrict 
__fmt
,

45 
_G_va_list
 
__ap
))

47 return 
	`__builtin___vsprintf_chk
 (
__s
, 
__USE_FORTIFY_LEVEL
 - 1,

48 
	`__bos
 (
__s
), 
__fmt
, 
__ap
);

49 
	}
}

51 #if 
defined
 
__USE_BSD
 || defined 
__USE_ISOC99
 || defined 
__USE_UNIX98


53 extern int 
	$__snprintf_chk
 (char *
__restrict
 
__s
, 
size_t
 
__n
, int 
__flag
,

54 
size_t
 
__slen
, 
__const
 char *
__restrict
 
__format
,

55 ...) 
__THROW
;

56 extern int 
	$__vsnprintf_chk
 (char *
__restrict
 
__s
, 
size_t
 
__n
, int 
__flag
,

57 
size_t
 
__slen
, 
__const
 char *
__restrict
 
__format
,

58 
_G_va_list
 
__ap
) 
__THROW
;

60 #ifdef 
__va_arg_pack


61 
__extern_always_inline
 int

62 
	`__NTH
 (
	$snprintf
 (char *
__restrict
 
__s
, 
size_t
 
__n
,

63 
__const
 char *
__restrict
 
__fmt
, ...))

65 return 
	`__builtin___snprintf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

66 
	`__bos
 (
__s
), 
__fmt
, 
	`__va_arg_pack
 ());

67 
	}
}

68 #elif !
defined
 
__cplusplus


69 #define 
	#snprintf
(
str
, 
len
, ...) \

70 
	`__builtin___snprintf_chk
 (
str
, 
len
, 
__USE_FORTIFY_LEVEL
 - 1, 
	`__bos
 (str), \

71 
__VA_ARGS__
)

	)

74 
__extern_always_inline
 int

75 
__NTH
 (
	$vsnprintf
 (char *
__restrict
 
__s
, 
size_t
 
__n
,

76 
__const
 char *
__restrict
 
__fmt
, 
_G_va_list
 
__ap
))

78 return 
	`__builtin___vsnprintf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

79 
	`__bos
 (
__s
), 
__fmt
, 
__ap
);

80 
	}
}

84 #if 
__USE_FORTIFY_LEVEL
 > 1

86 extern int 
__fprintf_chk
 (
FILE
 *
__restrict
 
__stream
, int 
__flag
,

87 
__const
 char *
__restrict
 
__format
, ...);

88 extern int 
__printf_chk
 (int 
__flag
, 
__const
 char *
__restrict
 
__format
, ...);

89 extern int 
__vfprintf_chk
 (
FILE
 *
__restrict
 
__stream
, int 
__flag
,

90 
__const
 char *
__restrict
 
__format
, 
_G_va_list
 
__ap
);

91 extern int 
__vprintf_chk
 (int 
__flag
, 
__const
 char *
__restrict
 
__format
,

92 
_G_va_list
 
__ap
);

94 #ifdef 
__va_arg_pack


95 
__extern_always_inline
 int

96 
	$fprintf
 (
FILE
 *
__restrict
 
__stream
, 
__const
 char *__restrict 
__fmt
, ...)

98 return 
	`__fprintf_chk
 (
__stream
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

99 
	`__va_arg_pack
 ());

100 
	}
}

102 
__extern_always_inline
 int

103 
	$printf
 (
__const
 char *
__restrict
 
__fmt
, ...)

105 return 
	`__printf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
	`__va_arg_pack
 ());

106 
	}
}

107 #elif !
defined
 
__cplusplus


108 #define 
	#printf
(...) \

109 
	`__printf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

110 #define 
	#fprintf
(
stream
, ...) \

111 
	`__fprintf_chk
 (
stream
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

114 
__extern_always_inline
 int

115 
	$vprintf
 (
__const
 char *
__restrict
 
__fmt
, 
_G_va_list
 
__ap
)

117 #ifdef 
__USE_EXTERN_INLINES


118 return 
	`__vfprintf_chk
 (
stdout
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__ap
);

120 return 
	`__vprintf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__ap
);

122 
	}
}

124 
__extern_always_inline
 int

125 
	$vfprintf
 (
FILE
 *
__restrict
 
__stream
,

126 
__const
 char *
__restrict
 
__fmt
, 
_G_va_list
 
__ap
)

128 return 
	`__vfprintf_chk
 (
__stream
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__ap
);

129 
	}
}

131 #ifdef 
__USE_GNU


133 extern int 
	$__asprintf_chk
 (char **
__restrict
 
__ptr
, int 
__flag
,

134 
__const
 char *
__restrict
 
__fmt
, ...)

135 
__THROW
 
	`__attribute__
 ((
	$__format__
 (
__printf__
, 3, 4))) 
__wur
;

136 extern int 
	$__vasprintf_chk
 (char **
__restrict
 
__ptr
, int 
__flag
,

137 
__const
 char *
__restrict
 
__fmt
, 
_G_va_list
 
__arg
)

138 
__THROW
 
	`__attribute__
 ((
	$__format__
 (
__printf__
, 3, 0))) 
__wur
;

139 extern int 
	$__dprintf_chk
 (int 
__fd
, int 
__flag
, 
__const
 char *
__restrict
 
__fmt
,

140 ...) 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 3, 4)));

141 extern int 
	$__vdprintf_chk
 (int 
__fd
, int 
__flag
,

142 
__const
 char *
__restrict
 
__fmt
, 
_G_va_list
 
__arg
)

143 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 3, 0)));

144 extern int 
	$__obstack_printf_chk
 (struct 
obstack
 *
__restrict
 
__obstack
,

145 int 
__flag
, 
__const
 char *
__restrict
 
__format
,

147 
__THROW
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 3, 4)));

148 extern int 
	$__obstack_vprintf_chk
 (struct 
obstack
 *
__restrict
 
__obstack
,

149 int 
__flag
,

150 
__const
 char *
__restrict
 
__format
,

151 
_G_va_list
 
__args
)

152 
__THROW
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 3, 0)));

154 #ifdef 
__va_arg_pack


155 
__extern_always_inline
 int

156 
	`__NTH
 (
	$asprintf
 (char **
__restrict
 
__ptr
, 
__const
 char *__restrict 
__fmt
, ...))

158 return 
	`__asprintf_chk
 (
__ptr
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

159 
	`__va_arg_pack
 ());

160 
	}
}

162 
__extern_always_inline
 int

163 
__NTH
 (
	$__asprintf
 (char **
__restrict
 
__ptr
, 
__const
 char *__restrict 
__fmt
,

166 return 
	`__asprintf_chk
 (
__ptr
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

167 
	`__va_arg_pack
 ());

168 
	}
}

170 
__extern_always_inline
 int

171 
	$dprintf
 (int 
__fd
, 
__const
 char *
__restrict
 
__fmt
, ...)

173 return 
	`__dprintf_chk
 (
__fd
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

174 
	`__va_arg_pack
 ());

175 
	}
}

177 
__extern_always_inline
 int

178 
__NTH
 (
	$obstack_printf
 (struct 
obstack
 *
__restrict
 
__obstack
,

179 
__const
 char *
__restrict
 
__fmt
, ...))

181 return 
	`__obstack_printf_chk
 (
__obstack
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

182 
	`__va_arg_pack
 ());

183 
	}
}

184 #elif !
defined
 
__cplusplus


185 #define 
	#asprintf
(
ptr
, ...) \

186 
	`__asprintf_chk
 (
ptr
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

187 #define 
	#__asprintf
(
ptr
, ...) \

188 
	`__asprintf_chk
 (
ptr
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

189 #define 
	#dprintf
(
fd
, ...) \

190 
	`__dprintf_chk
 (
fd
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

191 #define 
	#obstack_printf
(
obstack
, ...) \

192 
	`__obstack_printf_chk
 (
obstack
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

195 
__extern_always_inline
 int

196 
__NTH
 (
	$vasprintf
 (char **
__restrict
 
__ptr
, 
__const
 char *__restrict 
__fmt
,

197 
_G_va_list
 
__ap
))

199 return 
	`__vasprintf_chk
 (
__ptr
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__ap
);

200 
	}
}

202 
__extern_always_inline
 int

203 
	$vdprintf
 (int 
__fd
, 
__const
 char *
__restrict
 
__fmt
, 
_G_va_list
 
__ap
)

205 return 
	`__vdprintf_chk
 (
__fd
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__ap
);

206 
	}
}

208 
__extern_always_inline
 int

209 
__NTH
 (
	$obstack_vprintf
 (struct 
obstack
 *
__restrict
 
__obstack
,

210 
__const
 char *
__restrict
 
__fmt
, 
_G_va_list
 
__ap
))

212 return 
	`__obstack_vprintf_chk
 (
__obstack
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

213 
__ap
);

214 
	}
}

220 extern char *
	$__gets_chk
 (char *
__str
, 
size_t
) 
__wur
;

221 extern char *
	`__REDIRECT
 (
__gets_warn
, (char *
__str
), 
gets
)

222 
__wur
 
	`__warnattr
 ("please use fgets or getline instead, gets can't "

225 
__extern_always_inline
 
__wur
 char *

226 
	$gets
 (char *
__str
)

228 if (
	`__bos
 (
__str
) != (
size_t
) -1)

229 return 
	`__gets_chk
 (
__str
, 
	`__bos
 (__str));

230 return 
	`__gets_warn
 (
__str
);

231 
	}
}

233 extern char *
	$__fgets_chk
 (char *
__restrict
 
__s
, 
size_t
 
__size
, int 
__n
,

234 
FILE
 *
__restrict
 
__stream
) 
__wur
;

235 extern char *
	`__REDIRECT
 (
__fgets_alias
,

236 (char *
__restrict
 
__s
, int 
__n
,

237 
FILE
 *
__restrict
 
__stream
), 
fgets
) 
__wur
;

238 extern char *
	`__REDIRECT
 (
__fgets_chk_warn
,

239 (char *
__restrict
 
__s
, 
size_t
 
__size
, int 
__n
,

240 
FILE
 *
__restrict
 
__stream
), 
__fgets_chk
)

241 
__wur
 
	`__warnattr
 ("fgets called with bigger size than length "

244 
__extern_always_inline
 
__wur
 char *

245 
	$fgets
 (char *
__restrict
 
__s
, int 
__n
, 
FILE
 *__restrict 
__stream
)

247 if (
	`__bos
 (
__s
) != (
size_t
) -1)

249 if (!
	`__builtin_constant_p
 (
__n
) || __n <= 0)

250 return 
	`__fgets_chk
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__stream
);

252 if ((
size_t
) 
__n
 > 
	`__bos
 (
__s
))

253 return 
	`__fgets_chk_warn
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__stream
);

255 return 
	`__fgets_alias
 (
__s
, 
__n
, 
__stream
);

256 
	}
}

258 extern 
size_t
 
	$__fread_chk
 (void *
__restrict
 
__ptr
, 
size_t
 
__ptrlen
,

259 
size_t
 
__size
, size_t 
__n
,

260 
FILE
 *
__restrict
 
__stream
) 
__wur
;

261 extern 
size_t
 
	`__REDIRECT
 (
__fread_alias
,

262 (void *
__restrict
 
__ptr
, 
size_t
 
__size
,

263 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
),

264 
fread
) 
__wur
;

265 extern 
size_t
 
	`__REDIRECT
 (
__fread_chk_warn
,

266 (void *
__restrict
 
__ptr
, 
size_t
 
__ptrlen
,

267 
size_t
 
__size
, size_t 
__n
,

268 
FILE
 *
__restrict
 
__stream
),

269 
__fread_chk
)

270 
__wur
 
	`__warnattr
 ("fread called with bigger size * nmemb than length "

273 
__extern_always_inline
 
__wur
 
size_t


274 
	$fread
 (void *
__restrict
 
__ptr
, 
size_t
 
__size
, size_t 
__n
,

275 
FILE
 *
__restrict
 
__stream
)

277 if (
	`__bos0
 (
__ptr
) != (
size_t
) -1)

279 if (!
	`__builtin_constant_p
 (
__size
)

280 || !
	`__builtin_constant_p
 (
__n
)

281 || (
__size
 | 
__n
) >= (((
size_t
) 1) << (8 * sizeof (size_t) / 2)))

282 return 
	`__fread_chk
 (
__ptr
, 
	`__bos0
 (__ptr), 
__size
, 
__n
, 
__stream
);

284 if (
__size
 * 
__n
 > 
	`__bos0
 (
__ptr
))

285 return 
	`__fread_chk_warn
 (
__ptr
, 
	`__bos0
 (__ptr), 
__size
, 
__n
, 
__stream
);

287 return 
	`__fread_alias
 (
__ptr
, 
__size
, 
__n
, 
__stream
);

288 
	}
}

290 #ifdef 
__USE_GNU


291 extern char *
	$__fgets_unlocked_chk
 (char *
__restrict
 
__s
, 
size_t
 
__size
,

292 int 
__n
, 
FILE
 *
__restrict
 
__stream
) 
__wur
;

293 extern char *
	`__REDIRECT
 (
__fgets_unlocked_alias
,

294 (char *
__restrict
 
__s
, int 
__n
,

295 
FILE
 *
__restrict
 
__stream
), 
fgets_unlocked
) 
__wur
;

296 extern char *
	`__REDIRECT
 (
__fgets_unlocked_chk_warn
,

297 (char *
__restrict
 
__s
, 
size_t
 
__size
, int 
__n
,

298 
FILE
 *
__restrict
 
__stream
), 
__fgets_unlocked_chk
)

299 
__wur
 
	`__warnattr
 ("fgets_unlocked called with bigger size than length "

302 
__extern_always_inline
 
__wur
 char *

303 
	$fgets_unlocked
 (char *
__restrict
 
__s
, int 
__n
, 
FILE
 *__restrict 
__stream
)

305 if (
	`__bos
 (
__s
) != (
size_t
) -1)

307 if (!
	`__builtin_constant_p
 (
__n
) || __n <= 0)

308 return 
	`__fgets_unlocked_chk
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__stream
);

310 if ((
size_t
) 
__n
 > 
	`__bos
 (
__s
))

311 return 
	`__fgets_unlocked_chk_warn
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__stream
);

313 return 
	`__fgets_unlocked_alias
 (
__s
, 
__n
, 
__stream
);

314 
	}
}

317 #ifdef 
__USE_MISC


318 #undef 
fread_unlocked


319 extern 
size_t
 
	$__fread_unlocked_chk
 (void *
__restrict
 
__ptr
, 
size_t
 
__ptrlen
,

320 
size_t
 
__size
, size_t 
__n
,

321 
FILE
 *
__restrict
 
__stream
) 
__wur
;

322 extern 
size_t
 
	`__REDIRECT
 (
__fread_unlocked_alias
,

323 (void *
__restrict
 
__ptr
, 
size_t
 
__size
,

324 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
),

325 
fread_unlocked
) 
__wur
;

326 extern 
size_t
 
	`__REDIRECT
 (
__fread_unlocked_chk_warn
,

327 (void *
__restrict
 
__ptr
, 
size_t
 
__ptrlen
,

328 
size_t
 
__size
, size_t 
__n
,

329 
FILE
 *
__restrict
 
__stream
),

330 
__fread_unlocked_chk
)

331 
__wur
 
	`__warnattr
 ("fread_unlocked called with bigger size * nmemb than "

334 
__extern_always_inline
 
__wur
 
size_t


335 
	$fread_unlocked
 (void *
__restrict
 
__ptr
, 
size_t
 
__size
, size_t 
__n
,

336 
FILE
 *
__restrict
 
__stream
)

338 if (
	`__bos0
 (
__ptr
) != (
size_t
) -1)

340 if (!
	`__builtin_constant_p
 (
__size
)

341 || !
	`__builtin_constant_p
 (
__n
)

342 || (
__size
 | 
__n
) >= (((
size_t
) 1) << (8 * sizeof (size_t) / 2)))

343 return 
	`__fread_unlocked_chk
 (
__ptr
, 
	`__bos0
 (__ptr), 
__size
, 
__n
,

344 
__stream
);

346 if (
__size
 * 
__n
 > 
	`__bos0
 (
__ptr
))

347 return 
	`__fread_unlocked_chk_warn
 (
__ptr
, 
	`__bos0
 (__ptr), 
__size
, 
__n
,

348 
__stream
);

351 #ifdef 
__USE_EXTERN_INLINES


352 if (
	`__builtin_constant_p
 (
__size
)

353 && 
	`__builtin_constant_p
 (
__n
)

354 && (
__size
 | 
__n
) < (((
size_t
) 1) << (8 * sizeof (size_t) / 2))

355 && 
__size
 * 
__n
 <= 8)

357 
size_t
 
__cnt
 = 
__size
 * 
__n
;

358 char *
__cptr
 = (char *) 
__ptr
;

359 if (
__cnt
 == 0)

362 for (; 
__cnt
 > 0; --__cnt)

364 int 
__c
 = 
	`_IO_getc_unlocked
 (
__stream
);

365 if (
__c
 == 
EOF
)

367 *
__cptr
++ = 
__c
;

369 return (
__cptr
 - (char *) 
__ptr
) / 
__size
;

372 return 
	`__fread_unlocked_alias
 (
__ptr
, 
__size
, 
__n
, 
__stream
);

373 
	}
}

	@/usr/include/bits/stdio_lim.h

19 #if !
defined
 
_STDIO_H
 && !defined 
__need_FOPEN_MAX
 && !defined 
__need_IOV_MAX


23 #ifdef 
_STDIO_H


24 #define 
	#L_tmpnam
 20

	)

25 #define 
	#TMP_MAX
 238328

	)

26 #define 
	#FILENAME_MAX
 4096

	)

28 #ifdef 
__USE_POSIX


29 #define 
	#L_ctermid
 9

	)

30 #if !
defined
 
__USE_XOPEN2K
 || defined 
__USE_GNU


31 #define 
	#L_cuserid
 9

	)

36 #if 
defined
 
__need_FOPEN_MAX
 || defined 
_STDIO_H


37 #undef 
FOPEN_MAX


38 #define 
	#FOPEN_MAX
 16

	)

41 #if 
defined
 
__need_IOV_MAX
 && !defined 
IOV_MAX


42 #define 
	#IOV_MAX
 1024

	)

	@/usr/include/bits/stdlib-ldbl.h

20 #ifndef 
_STDLIB_H


24 #ifdef 
__USE_ISOC99


25 
__BEGIN_NAMESPACE_C99


26 
	$__LDBL_REDIR1_DECL
 (
strtold
, 
strtod
)

27 
__END_NAMESPACE_C99


30 #ifdef 
__USE_GNU


31 
	$__LDBL_REDIR1_DECL
 (
strtold_l
, 
strtod_l
)

34 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN_EXTENDED


35 #ifdef 
__USE_MISC


36 
	$__LDBL_REDIR1_DECL
 (
qecvt
, 
ecvt
)

37 
	$__LDBL_REDIR1_DECL
 (
qfcvt
, 
fcvt
)

38 
	$__LDBL_REDIR1_DECL
 (
qgcvt
, 
gcvt
)

39 
	$__LDBL_REDIR1_DECL
 (
qecvt_r
, 
ecvt_r
)

40 
	$__LDBL_REDIR1_DECL
 (
qfcvt_r
, 
fcvt_r
)

	@/usr/include/bits/stdlib.h

20 #ifndef 
_STDLIB_H


24 extern char *
	$__realpath_chk
 (
__const
 char *
__restrict
 
__name
,

25 char *
__restrict
 
__resolved
,

26 
size_t
 
__resolvedlen
) 
__THROW
 
__wur
;

27 extern char *
	`__REDIRECT_NTH
 (
__realpath_alias
,

28 (
__const
 char *
__restrict
 
__name
,

29 char *
__restrict
 
__resolved
), 
realpath
) 
__wur
;

30 extern char *
	`__REDIRECT_NTH
 (
__realpath_chk_warn
,

31 (
__const
 char *
__restrict
 
__name
,

32 char *
__restrict
 
__resolved
,

33 
size_t
 
__resolvedlen
), 
__realpath_chk
) 
__wur


34 
	`__warnattr
 ("second argument of realpath must be either NULL or at "

37 
__extern_always_inline
 
__wur
 char *

38 
	`__NTH
 (
	$realpath
 (
__const
 char *
__restrict
 
__name
, char *__restrict 
__resolved
))

40 if (
	`__bos
 (
__resolved
) != (
size_t
) -1)

42 #if 
defined
 
_LIBC_LIMITS_H_
 && defined 
PATH_MAX


43 if (
	`__bos
 (
__resolved
) < 
PATH_MAX
)

44 return 
	`__realpath_chk_warn
 (
__name
, 
__resolved
, 
	`__bos
 (__resolved));

46 return 
	`__realpath_chk
 (
__name
, 
__resolved
, 
	`__bos
 (__resolved));

49 return 
	`__realpath_alias
 (
__name
, 
__resolved
);

50 
	}
}

53 extern int 
	$__ptsname_r_chk
 (int 
__fd
, char *
__buf
, 
size_t
 
__buflen
,

54 
size_t
 
__nreal
) 
__THROW
 
	`__nonnull
 ((2));

55 extern int 
	`__REDIRECT_NTH
 (
__ptsname_r_alias
, (int 
__fd
, char *
__buf
,

56 
size_t
 
__buflen
), 
ptsname_r
)

57 
	`__nonnull
 ((2));

58 extern int 
	`__REDIRECT_NTH
 (
__ptsname_r_chk_warn
,

59 (int 
__fd
, char *
__buf
, 
size_t
 
__buflen
,

60 
size_t
 
__nreal
), 
__ptsname_r_chk
)

61 
	`__nonnull
 ((2)) 
	`__warnattr
 ("ptsname_r called with buflen bigger than "

64 
__extern_always_inline
 int

65 
	`__NTH
 (
	$ptsname_r
 (int 
__fd
, char *
__buf
, 
size_t
 
__buflen
))

67 if (
	`__bos
 (
__buf
) != (
size_t
) -1)

69 if (!
	`__builtin_constant_p
 (
__buflen
))

70 return 
	`__ptsname_r_chk
 (
__fd
, 
__buf
, 
__buflen
, 
	`__bos
 (__buf));

71 if (
__buflen
 > 
	`__bos
 (
__buf
))

72 return 
	`__ptsname_r_chk_warn
 (
__fd
, 
__buf
, 
__buflen
, 
	`__bos
 (__buf));

74 return 
	`__ptsname_r_alias
 (
__fd
, 
__buf
, 
__buflen
);

75 
	}
}

78 extern int 
	$__wctomb_chk
 (char *
__s
, 
wchar_t
 
__wchar
, 
size_t
 
__buflen
)

79 
__THROW
 
__wur
;

80 extern int 
	`__REDIRECT_NTH
 (
__wctomb_alias
, (char *
__s
, 
wchar_t
 
__wchar
),

81 
wctomb
) 
__wur
;

83 
__extern_always_inline
 
__wur
 int

84 
	`__NTH
 (
	$wctomb
 (char *
__s
, 
wchar_t
 
__wchar
))

89 #define 
	#__STDLIB_MB_LEN_MAX
 16

	)

90 #if 
defined
 
MB_LEN_MAX
 && MB_LEN_MAX != 
__STDLIB_MB_LEN_MAX


93 if (
	`__bos
 (
__s
) != (
size_t
) -1 && 
__STDLIB_MB_LEN_MAX
 > __bos (__s))

94 return 
	`__wctomb_chk
 (
__s
, 
__wchar
, 
	`__bos
 (__s));

95 return 
	`__wctomb_alias
 (
__s
, 
__wchar
);

96 
	}
}

99 extern 
size_t
 
	$__mbstowcs_chk
 (
wchar_t
 *
__restrict
 
__dst
,

100 
__const
 char *
__restrict
 
__src
,

101 
size_t
 
__len
, size_t 
__dstlen
) 
__THROW
;

102 extern 
size_t
 
	`__REDIRECT_NTH
 (
__mbstowcs_alias
,

103 (
wchar_t
 *
__restrict
 
__dst
,

104 
__const
 char *
__restrict
 
__src
,

105 
size_t
 
__len
), 
mbstowcs
);

106 extern 
size_t
 
	`__REDIRECT_NTH
 (
__mbstowcs_chk_warn
,

107 (
wchar_t
 *
__restrict
 
__dst
,

108 
__const
 char *
__restrict
 
__src
,

109 
size_t
 
__len
, size_t 
__dstlen
), 
__mbstowcs_chk
)

110 
	`__warnattr
 ("mbstowcs called with dst buffer smaller than len "

113 
__extern_always_inline
 
size_t


114 
	`__NTH
 (
	$mbstowcs
 (
wchar_t
 *
__restrict
 
__dst
, 
__const
 char *__restrict 
__src
,

115 
size_t
 
__len
))

117 if (
	`__bos
 (
__dst
) != (
size_t
) -1)

119 if (!
	`__builtin_constant_p
 (
__len
))

120 return 
	`__mbstowcs_chk
 (
__dst
, 
__src
, 
__len
,

121 
	`__bos
 (
__dst
) / sizeof (
wchar_t
));

123 if (
__len
 > 
	`__bos
 (
__dst
) / sizeof (
wchar_t
))

124 return 
	`__mbstowcs_chk_warn
 (
__dst
, 
__src
, 
__len
,

125 
	`__bos
 (
__dst
) / sizeof (
wchar_t
));

127 return 
	`__mbstowcs_alias
 (
__dst
, 
__src
, 
__len
);

128 
	}
}

131 extern 
size_t
 
	$__wcstombs_chk
 (char *
__restrict
 
__dst
,

132 
__const
 
wchar_t
 *
__restrict
 
__src
,

133 
size_t
 
__len
, size_t 
__dstlen
) 
__THROW
;

134 extern 
size_t
 
	`__REDIRECT_NTH
 (
__wcstombs_alias
,

135 (char *
__restrict
 
__dst
,

136 
__const
 
wchar_t
 *
__restrict
 
__src
,

137 
size_t
 
__len
), 
wcstombs
);

138 extern 
size_t
 
	`__REDIRECT_NTH
 (
__wcstombs_chk_warn
,

139 (char *
__restrict
 
__dst
,

140 
__const
 
wchar_t
 *
__restrict
 
__src
,

141 
size_t
 
__len
, size_t 
__dstlen
), 
__wcstombs_chk
)

142 
	`__warnattr
 ("wcstombs called with dst buffer smaller than len");

144 
__extern_always_inline
 
size_t


145 
	`__NTH
 (
	$wcstombs
 (char *
__restrict
 
__dst
, 
__const
 
wchar_t
 *__restrict 
__src
,

146 
size_t
 
__len
))

148 if (
	`__bos
 (
__dst
) != (
size_t
) -1)

150 if (!
	`__builtin_constant_p
 (
__len
))

151 return 
	`__wcstombs_chk
 (
__dst
, 
__src
, 
__len
, 
	`__bos
 (__dst));

152 if (
__len
 > 
	`__bos
 (
__dst
))

153 return 
	`__wcstombs_chk_warn
 (
__dst
, 
__src
, 
__len
, 
	`__bos
 (__dst));

155 return 
	`__wcstombs_alias
 (
__dst
, 
__src
, 
__len
);

156 
	}
}

	@/usr/include/bits/string.h

20 #ifndef 
_STRING_H


26 #define 
	#_STRING_ARCH_unaligned
 1

	)

	@/usr/include/bits/string2.h

21 #ifndef 
_STRING_H


25 #if !
defined
 
__NO_STRING_INLINES
 && !defined 
__BOUNDED_POINTERS__


42 #ifndef 
__STRING_INLINE


43 #ifdef 
__cplusplus


44 #define 
	#__STRING_INLINE
 
inline


	)

46 #define 
	#__STRING_INLINE
 
__extern_inline


	)

50 #if 
_STRING_ARCH_unaligned


52 #include 
	~<endian.h
>

53 #include 
	~<bits/types.h
>

55 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


56 #define 
	#__STRING2_SMALL_GET16
(
src
, 
idx
) \

57 (((
__const
 unsigned char *) (__const char *) (
src
))[
idx
 + 1] << 8 \

58 | ((
__const
 unsigned char *) (__const char *) (
src
))[
idx
])

	)

59 #define 
	#__STRING2_SMALL_GET32
(
src
, 
idx
) \

60 (((((
__const
 unsigned char *) (__const char *) (
src
))[
idx
 + 3] << 8 \

61 | ((
__const
 unsigned char *) (__const char *) (
src
))[
idx
 + 2]) << 8 \

62 | ((
__const
 unsigned char *) (__const char *) (
src
))[
idx
 + 1]) << 8 \

63 | ((
__const
 unsigned char *) (__const char *) (
src
))[
idx
])

	)

65 #define 
	#__STRING2_SMALL_GET16
(
src
, 
idx
) \

66 (((
__const
 unsigned char *) (__const char *) (
src
))[
idx
] << 8 \

67 | ((
__const
 unsigned char *) (__const char *) (
src
))[
idx
 + 1])

	)

68 #define 
	#__STRING2_SMALL_GET32
(
src
, 
idx
) \

69 (((((
__const
 unsigned char *) (__const char *) (
src
))[
idx
] << 8 \

70 | ((
__const
 unsigned char *) (__const char *) (
src
))[
idx
 + 1]) << 8 \

71 | ((
__const
 unsigned char *) (__const char *) (
src
))[
idx
 + 2]) << 8 \

72 | ((
__const
 unsigned char *) (__const char *) (
src
))[
idx
 + 3])

	)

77 #define 
	#__STRING2_COPY_TYPE
(
N
) \

78 typedef struct { unsigned char 
__arr
[
N
]; } \

79 
	t__attribute__
 ((
	t__packed__
)) 
	t__STRING2_COPY_ARR
##
	tN


	)

80 
	t__STRING2_COPY_TYPE
 (2);

81 
__STRING2_COPY_TYPE
 (3);

82 
__STRING2_COPY_TYPE
 (4);

83 
__STRING2_COPY_TYPE
 (5);

84 
__STRING2_COPY_TYPE
 (6);

85 
__STRING2_COPY_TYPE
 (7);

86 
__STRING2_COPY_TYPE
 (8);

87 #undef 
__STRING2_COPY_TYPE


93 #define 
	#__string2_1bptr_p
(
__x
) \

94 ((
size_t
)(const void *)((
__x
) + 1) - (size_t)(const void *)(__x) == 1)

	)

97 #if !
defined
 
_HAVE_STRING_ARCH_memset


98 #if !
__GNUC_PREREQ
 (3, 0)

99 #if 
_STRING_ARCH_unaligned


100 #define 
	#memset
(
s
, 
c
, 
n
) \

101 (
	`__extension__
 (
	`__builtin_constant_p
 (
n
) && (n) <= 16 \

102 ? ((
n
) == 1 \

103 ? 
	`__memset_1
 (
s
, 
c
) \

104 : 
	`__memset_gc
 (
s
, 
c
, 
n
)) \

105 : (
	`__builtin_constant_p
 (
c
) && (c) == '\0' \

106 ? ({ void *
__s
 = (
s
); 
	`__bzero
 (__s, 
n
); __s; }) \

107 : 
	`memset
 (
s
, 
c
, 
n
))))

	)

109 #define 
	#__memset_1
(
s
, 
c
) ({ void *
__s
 = (s); \

110 *((
__uint8_t
 *) 
__s
) = (__uint8_t) 
c
; __s; })

	)

112 #define 
	#__memset_gc
(
s
, 
c
, 
n
) \

113 ({ void *
__s
 = (
s
); \

115 unsigned int 
__ui
; \

116 unsigned short int 
__usi
; \

117 unsigned char 
__uc
; \

118 } *
__u
 = 
__s
; \

119 
__uint8_t
 
__c
 = (__uint8_t) (
c
); \

122 switch ((unsigned int) (
n
)) \

125 
__u
->
__ui
 = 
__c
 * 0x01010101; \

126 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

128 
__u
->
__ui
 = 
__c
 * 0x01010101; \

129 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

131 
__u
->
__ui
 = 
__c
 * 0x01010101; \

132 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

134 
__u
->
__usi
 = (unsigned short int) 
__c
 * 0x0101; \

135 
__u
 = 
	`__extension__
 ((void *) __u + 2); \

136 
__u
->
__uc
 = (unsigned char) 
__c
; \

140 
__u
->
__ui
 = 
__c
 * 0x01010101; \

141 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

143 
__u
->
__ui
 = 
__c
 * 0x01010101; \

144 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

146 
__u
->
__ui
 = 
__c
 * 0x01010101; \

147 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

149 
__u
->
__usi
 = (unsigned short int) 
__c
 * 0x0101; \

153 
__u
->
__ui
 = 
__c
 * 0x01010101; \

154 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

156 
__u
->
__ui
 = 
__c
 * 0x01010101; \

157 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

159 
__u
->
__ui
 = 
__c
 * 0x01010101; \

160 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

162 
__u
->
__uc
 = (unsigned char) 
__c
; \

166 
__u
->
__ui
 = 
__c
 * 0x01010101; \

167 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

169 
__u
->
__ui
 = 
__c
 * 0x01010101; \

170 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

172 
__u
->
__ui
 = 
__c
 * 0x01010101; \

173 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

175 
__u
->
__ui
 = 
__c
 * 0x01010101; \

180 
__s
; })

	)

182 #define 
	#memset
(
s
, 
c
, 
n
) \

183 (
	`__extension__
 (
	`__builtin_constant_p
 (
c
) && (c) == '\0' \

184 ? ({ void *
__s
 = (
s
); 
	`__bzero
 (__s, 
n
); __s; }) \

185 : 
	`memset
 (
s
, 
c
, 
n
)))

	)

194 #if 
__GNUC_PREREQ
 (2, 91)

195 #define 
	#__bzero
(
s
, 
n
) 
	`__builtin_memset
 (s, '\0', n)

	)

203 #ifdef 
__USE_GNU


204 #if !
defined
 
_HAVE_STRING_ARCH_mempcpy
 || defined 
_FORCE_INLINES


205 #ifndef 
_HAVE_STRING_ARCH_mempcpy


206 #if 
__GNUC_PREREQ
 (3, 4)

207 #define 
	#__mempcpy
(
dest
, 
src
, 
n
) 
	`__builtin_mempcpy
 (dest, src, n)

	)

208 #elif 
__GNUC_PREREQ
 (3, 0)

209 #define 
	#__mempcpy
(
dest
, 
src
, 
n
) \

210 (
	`__extension__
 (
	`__builtin_constant_p
 (
src
) && __builtin_constant_p (
n
) \

211 && 
	`__string2_1bptr_p
 (
src
) && 
n
 <= 8 \

212 ? 
	`__builtin_memcpy
 (
dest
, 
src
, 
n
) + (n) \

213 : 
	`__mempcpy
 (
dest
, 
src
, 
n
)))

	)

215 #define 
	#__mempcpy
(
dest
, 
src
, 
n
) \

216 (
	`__extension__
 (
	`__builtin_constant_p
 (
src
) && __builtin_constant_p (
n
) \

217 && 
	`__string2_1bptr_p
 (
src
) && 
n
 <= 8 \

218 ? 
	`__mempcpy_small
 (
dest
, 
	`__mempcpy_args
 (
src
), 
n
) \

219 : 
	`__mempcpy
 (
dest
, 
src
, 
n
)))

	)

223 #define 
	#mempcpy
(
dest
, 
src
, 
n
) 
	`__mempcpy
 (dest, src, n)

	)

226 #if !
__GNUC_PREREQ
 (3, 0) || 
defined
 
_FORCE_INLINES


227 #if 
_STRING_ARCH_unaligned


228 #ifndef 
_FORCE_INLINES


229 #define 
	#__mempcpy_args
(
src
) \

230 ((
__const
 char *) (
src
))[0], ((__const char *) (src))[2], \

231 ((
__const
 char *) (
src
))[4], ((__const char *) (src))[6], \

232 
__extension__
 
	`__STRING2_SMALL_GET16
 (
src
, 0), \

233 
__extension__
 
	`__STRING2_SMALL_GET16
 (
src
, 4), \

234 
__extension__
 
	`__STRING2_SMALL_GET32
 (
src
, 0), \

235 
__extension__
 
	`__STRING2_SMALL_GET32
 (
src
, 4)

	)

237 
__STRING_INLINE
 void *
__mempcpy_small
 (void *, char, char, char, char,

238 
__uint16_t
, __uint16_t, 
__uint32_t
,

239 
__uint32_t
, 
size_t
);

240 
__STRING_INLINE
 void *

241 
	$__mempcpy_small
 (void *
__dest1
,

242 char 
__src0_1
, char 
__src2_1
, char 
__src4_1
, char 
__src6_1
,

243 
__uint16_t
 
__src0_2
, __uint16_t 
__src4_2
,

244 
__uint32_t
 
__src0_4
, __uint32_t 
__src4_4
,

245 
size_t
 
__srclen
)

248 
__uint32_t
 
__ui
;

249 
__uint16_t
 
__usi
;

250 unsigned char 
__uc
;

251 unsigned char 
__c
;

252 } *
__u
 = 
__dest1
;

253 switch ((unsigned int) 
__srclen
)

256 
__u
->
__c
 = 
__src0_1
;

257 
__u
 = 
	`__extension__
 ((void *) __u + 1);

260 
__u
->
__usi
 = 
__src0_2
;

261 
__u
 = 
	`__extension__
 ((void *) __u + 2);

264 
__u
->
__usi
 = 
__src0_2
;

265 
__u
 = 
	`__extension__
 ((void *) __u + 2);

266 
__u
->
__c
 = 
__src2_1
;

267 
__u
 = 
	`__extension__
 ((void *) __u + 1);

270 
__u
->
__ui
 = 
__src0_4
;

271 
__u
 = 
	`__extension__
 ((void *) __u + 4);

274 
__u
->
__ui
 = 
__src0_4
;

275 
__u
 = 
	`__extension__
 ((void *) __u + 4);

276 
__u
->
__c
 = 
__src4_1
;

277 
__u
 = 
	`__extension__
 ((void *) __u + 1);

280 
__u
->
__ui
 = 
__src0_4
;

281 
__u
 = 
	`__extension__
 ((void *) __u + 4);

282 
__u
->
__usi
 = 
__src4_2
;

283 
__u
 = 
	`__extension__
 ((void *) __u + 2);

286 
__u
->
__ui
 = 
__src0_4
;

287 
__u
 = 
	`__extension__
 ((void *) __u + 4);

288 
__u
->
__usi
 = 
__src4_2
;

289 
__u
 = 
	`__extension__
 ((void *) __u + 2);

290 
__u
->
__c
 = 
__src6_1
;

291 
__u
 = 
	`__extension__
 ((void *) __u + 1);

294 
__u
->
__ui
 = 
__src0_4
;

295 
__u
 = 
	`__extension__
 ((void *) __u + 4);

296 
__u
->
__ui
 = 
__src4_4
;

297 
__u
 = 
	`__extension__
 ((void *) __u + 4);

300 return (void *) 
__u
;

301 
	}
}

303 #ifndef 
_FORCE_INLINES


304 #define 
	#__mempcpy_args
(
src
) \

305 ((
__const
 char *) (
src
))[0], \

306 
	`__extension__
 ((
__STRING2_COPY_ARR2
) \

307 { { ((
__const
 char *) (
src
))[0], ((__const char *) (src))[1] } }), \

308 
	`__extension__
 ((
__STRING2_COPY_ARR3
) \

309 { { ((
__const
 char *) (
src
))[0], ((__const char *) (src))[1], \

310 ((
__const
 char *) (
src
))[2] } }), \

311 
	`__extension__
 ((
__STRING2_COPY_ARR4
) \

312 { { ((
__const
 char *) (
src
))[0], ((__const char *) (src))[1], \

313 ((
__const
 char *) (
src
))[2], ((__const char *) (src))[3] } }), \

314 
	`__extension__
 ((
__STRING2_COPY_ARR5
) \

315 { { ((
__const
 char *) (
src
))[0], ((__const char *) (src))[1], \

316 ((
__const
 char *) (
src
))[2], ((__const char *) (src))[3], \

317 ((
__const
 char *) (
src
))[4] } }), \

318 
	`__extension__
 ((
__STRING2_COPY_ARR6
) \

319 { { ((
__const
 char *) (
src
))[0], ((__const char *) (src))[1], \

320 ((
__const
 char *) (
src
))[2], ((__const char *) (src))[3], \

321 ((
__const
 char *) (
src
))[4], ((__const char *) (src))[5] } }), \

322 
	`__extension__
 ((
__STRING2_COPY_ARR7
) \

323 { { ((
__const
 char *) (
src
))[0], ((__const char *) (src))[1], \

324 ((
__const
 char *) (
src
))[2], ((__const char *) (src))[3], \

325 ((
__const
 char *) (
src
))[4], ((__const char *) (src))[5], \

326 ((
__const
 char *) (
src
))[6] } }), \

327 
	`__extension__
 ((
__STRING2_COPY_ARR8
) \

328 { { ((
__const
 char *) (
src
))[0], ((__const char *) (src))[1], \

329 ((
__const
 char *) (
src
))[2], ((__const char *) (src))[3], \

330 ((
__const
 char *) (
src
))[4], ((__const char *) (src))[5], \

331 ((
__const
 char *) (
src
))[6], ((__const char *) (src))[7] } })

	)

333 
__STRING_INLINE
 void *
__mempcpy_small
 (void *, char, 
__STRING2_COPY_ARR2
,

334 
__STRING2_COPY_ARR3
,

335 
__STRING2_COPY_ARR4
,

336 
__STRING2_COPY_ARR5
,

337 
__STRING2_COPY_ARR6
,

338 
__STRING2_COPY_ARR7
,

339 
__STRING2_COPY_ARR8
, 
size_t
);

340 
__STRING_INLINE
 void *

341 
	$__mempcpy_small
 (void *
__dest
, char 
__src1
,

342 
__STRING2_COPY_ARR2
 
__src2
, 
__STRING2_COPY_ARR3
 
__src3
,

343 
__STRING2_COPY_ARR4
 
__src4
, 
__STRING2_COPY_ARR5
 
__src5
,

344 
__STRING2_COPY_ARR6
 
__src6
, 
__STRING2_COPY_ARR7
 
__src7
,

345 
__STRING2_COPY_ARR8
 
__src8
, 
size_t
 
__srclen
)

348 char 
__c
;

349 
__STRING2_COPY_ARR2
 
__sca2
;

350 
__STRING2_COPY_ARR3
 
__sca3
;

351 
__STRING2_COPY_ARR4
 
__sca4
;

352 
__STRING2_COPY_ARR5
 
__sca5
;

353 
__STRING2_COPY_ARR6
 
__sca6
;

354 
__STRING2_COPY_ARR7
 
__sca7
;

355 
__STRING2_COPY_ARR8
 
__sca8
;

356 } *
__u
 = 
__dest
;

357 switch ((unsigned int) 
__srclen
)

360 
__u
->
__c
 = 
__src1
;

363 
__extension__
 
__u
->
__sca2
 = 
__src2
;

366 
__extension__
 
__u
->
__sca3
 = 
__src3
;

369 
__extension__
 
__u
->
__sca4
 = 
__src4
;

372 
__extension__
 
__u
->
__sca5
 = 
__src5
;

375 
__extension__
 
__u
->
__sca6
 = 
__src6
;

378 
__extension__
 
__u
->
__sca7
 = 
__src7
;

381 
__extension__
 
__u
->
__sca8
 = 
__src8
;

384 return 
	`__extension__
 ((void *) 
__u
 + 
__srclen
);

385 
	}
}

393 #ifndef 
_HAVE_STRING_ARCH_strchr


394 extern void *
__rawmemchr
 (const void *
__s
, int 
__c
);

395 #if 
__GNUC_PREREQ
 (3, 2)

396 #define 
	#strchr
(
s
, 
c
) \

397 (
	`__extension__
 (
	`__builtin_constant_p
 (
c
) && !__builtin_constant_p (
s
) \

398 && (
c
) == '\0' \

399 ? (char *) 
	`__rawmemchr
 (
s
, 
c
) \

400 : 
	`__builtin_strchr
 (
s
, 
c
)))

	)

402 #define 
	#strchr
(
s
, 
c
) \

403 (
	`__extension__
 (
	`__builtin_constant_p
 (
c
) && (c) == '\0' \

404 ? (char *) 
	`__rawmemchr
 (
s
, 
c
) \

405 : 
	`strchr
 (
s
, 
c
)))

	)

411 #if (!
defined
 
_HAVE_STRING_ARCH_strcpy
 && !
__GNUC_PREREQ
 (3, 0)) \

412 || 
defined
 
	g_FORCE_INLINES


413 #if !
defined
 
_HAVE_STRING_ARCH_strcpy
 && !
__GNUC_PREREQ
 (3, 0)

414 #define 
	#strcpy
(
dest
, 
src
) \

415 (
	`__extension__
 (
	`__builtin_constant_p
 (
src
) \

416 ? (
	`__string2_1bptr_p
 (
src
) && 
	`strlen
 (src) + 1 <= 8 \

417 ? 
	`__strcpy_small
 (
dest
, 
	`__strcpy_args
 (
src
), \

418 
	`strlen
 (
src
) + 1) \

419 : (char *) 
	`memcpy
 (
dest
, 
src
, 
	`strlen
 (src) + 1)) \

420 : 
	`strcpy
 (
dest
, 
src
)))

	)

423 #if 
_STRING_ARCH_unaligned


424 #ifndef 
_FORCE_INLINES


425 #define 
	#__strcpy_args
(
src
) \

426 
__extension__
 
	`__STRING2_SMALL_GET16
 (
src
, 0), \

427 
__extension__
 
	`__STRING2_SMALL_GET16
 (
src
, 4), \

428 
__extension__
 
	`__STRING2_SMALL_GET32
 (
src
, 0), \

429 
__extension__
 
	`__STRING2_SMALL_GET32
 (
src
, 4)

	)

431 
__STRING_INLINE
 char *
__strcpy_small
 (char *, 
__uint16_t
, __uint16_t,

432 
__uint32_t
, __uint32_t, 
size_t
);

433 
__STRING_INLINE
 char *

434 
	$__strcpy_small
 (char *
__dest
,

435 
__uint16_t
 
__src0_2
, __uint16_t 
__src4_2
,

436 
__uint32_t
 
__src0_4
, __uint32_t 
__src4_4
,

437 
size_t
 
__srclen
)

440 
__uint32_t
 
__ui
;

441 
__uint16_t
 
__usi
;

442 unsigned char 
__uc
;

443 } *
__u
 = (void *) 
__dest
;

444 switch ((unsigned int) 
__srclen
)

447 
__u
->
__uc
 = '\0';

450 
__u
->
__usi
 = 
__src0_2
;

453 
__u
->
__usi
 = 
__src0_2
;

454 
__u
 = 
	`__extension__
 ((void *) __u + 2);

455 
__u
->
__uc
 = '\0';

458 
__u
->
__ui
 = 
__src0_4
;

461 
__u
->
__ui
 = 
__src0_4
;

462 
__u
 = 
	`__extension__
 ((void *) __u + 4);

463 
__u
->
__uc
 = '\0';

466 
__u
->
__ui
 = 
__src0_4
;

467 
__u
 = 
	`__extension__
 ((void *) __u + 4);

468 
__u
->
__usi
 = 
__src4_2
;

471 
__u
->
__ui
 = 
__src0_4
;

472 
__u
 = 
	`__extension__
 ((void *) __u + 4);

473 
__u
->
__usi
 = 
__src4_2
;

474 
__u
 = 
	`__extension__
 ((void *) __u + 2);

475 
__u
->
__uc
 = '\0';

478 
__u
->
__ui
 = 
__src0_4
;

479 
__u
 = 
	`__extension__
 ((void *) __u + 4);

480 
__u
->
__ui
 = 
__src4_4
;

483 return 
__dest
;

484 
	}
}

486 #ifndef 
_FORCE_INLINES


487 #define 
	#__strcpy_args
(
src
) \

488 
	`__extension__
 ((
__STRING2_COPY_ARR2
) \

489 { { ((
__const
 char *) (
src
))[0], '\0' } }), \

490 
	`__extension__
 ((
__STRING2_COPY_ARR3
) \

491 { { ((
__const
 char *) (
src
))[0], ((__const char *) (src))[1], \

493 
	`__extension__
 ((
__STRING2_COPY_ARR4
) \

494 { { ((
__const
 char *) (
src
))[0], ((__const char *) (src))[1], \

495 ((
__const
 char *) (
src
))[2], '\0' } }), \

496 
	`__extension__
 ((
__STRING2_COPY_ARR5
) \

497 { { ((
__const
 char *) (
src
))[0], ((__const char *) (src))[1], \

498 ((
__const
 char *) (
src
))[2], ((__const char *) (src))[3], \

500 
	`__extension__
 ((
__STRING2_COPY_ARR6
) \

501 { { ((
__const
 char *) (
src
))[0], ((__const char *) (src))[1], \

502 ((
__const
 char *) (
src
))[2], ((__const char *) (src))[3], \

503 ((
__const
 char *) (
src
))[4], '\0' } }), \

504 
	`__extension__
 ((
__STRING2_COPY_ARR7
) \

505 { { ((
__const
 char *) (
src
))[0], ((__const char *) (src))[1], \

506 ((
__const
 char *) (
src
))[2], ((__const char *) (src))[3], \

507 ((
__const
 char *) (
src
))[4], ((__const char *) (src))[5], \

509 
	`__extension__
 ((
__STRING2_COPY_ARR8
) \

510 { { ((
__const
 char *) (
src
))[0], ((__const char *) (src))[1], \

511 ((
__const
 char *) (
src
))[2], ((__const char *) (src))[3], \

512 ((
__const
 char *) (
src
))[4], ((__const char *) (src))[5], \

513 ((
__const
 char *) (
src
))[6], '\0' } })

	)

515 
__STRING_INLINE
 char *
__strcpy_small
 (char *, 
__STRING2_COPY_ARR2
,

516 
__STRING2_COPY_ARR3
,

517 
__STRING2_COPY_ARR4
,

518 
__STRING2_COPY_ARR5
,

519 
__STRING2_COPY_ARR6
,

520 
__STRING2_COPY_ARR7
,

521 
__STRING2_COPY_ARR8
, 
size_t
);

522 
__STRING_INLINE
 char *

523 
	$__strcpy_small
 (char *
__dest
,

524 
__STRING2_COPY_ARR2
 
__src2
, 
__STRING2_COPY_ARR3
 
__src3
,

525 
__STRING2_COPY_ARR4
 
__src4
, 
__STRING2_COPY_ARR5
 
__src5
,

526 
__STRING2_COPY_ARR6
 
__src6
, 
__STRING2_COPY_ARR7
 
__src7
,

527 
__STRING2_COPY_ARR8
 
__src8
, 
size_t
 
__srclen
)

530 char 
__c
;

531 
__STRING2_COPY_ARR2
 
__sca2
;

532 
__STRING2_COPY_ARR3
 
__sca3
;

533 
__STRING2_COPY_ARR4
 
__sca4
;

534 
__STRING2_COPY_ARR5
 
__sca5
;

535 
__STRING2_COPY_ARR6
 
__sca6
;

536 
__STRING2_COPY_ARR7
 
__sca7
;

537 
__STRING2_COPY_ARR8
 
__sca8
;

538 } *
__u
 = (void *) 
__dest
;

539 switch ((unsigned int) 
__srclen
)

542 
__u
->
__c
 = '\0';

545 
__extension__
 
__u
->
__sca2
 = 
__src2
;

548 
__extension__
 
__u
->
__sca3
 = 
__src3
;

551 
__extension__
 
__u
->
__sca4
 = 
__src4
;

554 
__extension__
 
__u
->
__sca5
 = 
__src5
;

557 
__extension__
 
__u
->
__sca6
 = 
__src6
;

560 
__extension__
 
__u
->
__sca7
 = 
__src7
;

563 
__extension__
 
__u
->
__sca8
 = 
__src8
;

566 return 
__dest
;

567 
	}
}

573 #ifdef 
__USE_GNU


574 #if !
defined
 
_HAVE_STRING_ARCH_stpcpy
 || defined 
_FORCE_INLINES


575 #ifndef 
_HAVE_STRING_ARCH_stpcpy


576 #if 
__GNUC_PREREQ
 (3, 4)

577 #define 
	#__stpcpy
(
dest
, 
src
) 
	`__builtin_stpcpy
 (dest, src)

	)

578 #elif 
__GNUC_PREREQ
 (3, 0)

579 #define 
	#__stpcpy
(
dest
, 
src
) \

580 (
	`__extension__
 (
	`__builtin_constant_p
 (
src
) \

581 ? (
	`__string2_1bptr_p
 (
src
) && 
	`strlen
 (src) + 1 <= 8 \

582 ? 
	`__builtin_strcpy
 (
dest
, 
src
) + 
	`strlen
 (src) \

583 : ((char *) (
__mempcpy
) (
dest
, 
src
, 
	`strlen
 (src) + 1) \

585 : 
	`__stpcpy
 (
dest
, 
src
)))

	)

587 #define 
	#__stpcpy
(
dest
, 
src
) \

588 (
	`__extension__
 (
	`__builtin_constant_p
 (
src
) \

589 ? (
	`__string2_1bptr_p
 (
src
) && 
	`strlen
 (src) + 1 <= 8 \

590 ? 
	`__stpcpy_small
 (
dest
, 
	`__stpcpy_args
 (
src
), \

591 
	`strlen
 (
src
) + 1) \

592 : ((char *) (
__mempcpy
) (
dest
, 
src
, 
	`strlen
 (src) + 1) \

594 : 
	`__stpcpy
 (
dest
, 
src
)))

	)

598 #define 
	#stpcpy
(
dest
, 
src
) 
	`__stpcpy
 (dest, src)

	)

601 #if !
__GNUC_PREREQ
 (3, 0) || 
defined
 
_FORCE_INLINES


602 #if 
_STRING_ARCH_unaligned


603 #ifndef 
_FORCE_INLINES


604 #define 
	#__stpcpy_args
(
src
) \

605 
__extension__
 
	`__STRING2_SMALL_GET16
 (
src
, 0), \

606 
__extension__
 
	`__STRING2_SMALL_GET16
 (
src
, 4), \

607 
__extension__
 
	`__STRING2_SMALL_GET32
 (
src
, 0), \

608 
__extension__
 
	`__STRING2_SMALL_GET32
 (
src
, 4)

	)

610 
__STRING_INLINE
 char *
__stpcpy_small
 (char *, 
__uint16_t
, __uint16_t,

611 
__uint32_t
, __uint32_t, 
size_t
);

612 
__STRING_INLINE
 char *

613 
	$__stpcpy_small
 (char *
__dest
,

614 
__uint16_t
 
__src0_2
, __uint16_t 
__src4_2
,

615 
__uint32_t
 
__src0_4
, __uint32_t 
__src4_4
,

616 
size_t
 
__srclen
)

619 unsigned int 
__ui
;

620 unsigned short int 
__usi
;

621 unsigned char 
__uc
;

622 char 
__c
;

623 } *
__u
 = (void *) 
__dest
;

624 switch ((unsigned int) 
__srclen
)

627 
__u
->
__uc
 = '\0';

630 
__u
->
__usi
 = 
__src0_2
;

631 
__u
 = 
	`__extension__
 ((void *) __u + 1);

634 
__u
->
__usi
 = 
__src0_2
;

635 
__u
 = 
	`__extension__
 ((void *) __u + 2);

636 
__u
->
__uc
 = '\0';

639 
__u
->
__ui
 = 
__src0_4
;

640 
__u
 = 
	`__extension__
 ((void *) __u + 3);

643 
__u
->
__ui
 = 
__src0_4
;

644 
__u
 = 
	`__extension__
 ((void *) __u + 4);

645 
__u
->
__uc
 = '\0';

648 
__u
->
__ui
 = 
__src0_4
;

649 
__u
 = 
	`__extension__
 ((void *) __u + 4);

650 
__u
->
__usi
 = 
__src4_2
;

651 
__u
 = 
	`__extension__
 ((void *) __u + 1);

654 
__u
->
__ui
 = 
__src0_4
;

655 
__u
 = 
	`__extension__
 ((void *) __u + 4);

656 
__u
->
__usi
 = 
__src4_2
;

657 
__u
 = 
	`__extension__
 ((void *) __u + 2);

658 
__u
->
__uc
 = '\0';

661 
__u
->
__ui
 = 
__src0_4
;

662 
__u
 = 
	`__extension__
 ((void *) __u + 4);

663 
__u
->
__ui
 = 
__src4_4
;

664 
__u
 = 
	`__extension__
 ((void *) __u + 3);

667 return &
__u
->
__c
;

668 
	}
}

670 #ifndef 
_FORCE_INLINES


671 #define 
	#__stpcpy_args
(
src
) \

672 
	`__extension__
 ((
__STRING2_COPY_ARR2
) \

673 { { ((
__const
 char *) (
src
))[0], '\0' } }), \

674 
	`__extension__
 ((
__STRING2_COPY_ARR3
) \

675 { { ((
__const
 char *) (
src
))[0], ((__const char *) (src))[1], \

677 
	`__extension__
 ((
__STRING2_COPY_ARR4
) \

678 { { ((
__const
 char *) (
src
))[0], ((__const char *) (src))[1], \

679 ((
__const
 char *) (
src
))[2], '\0' } }), \

680 
	`__extension__
 ((
__STRING2_COPY_ARR5
) \

681 { { ((
__const
 char *) (
src
))[0], ((__const char *) (src))[1], \

682 ((
__const
 char *) (
src
))[2], ((__const char *) (src))[3], \

684 
	`__extension__
 ((
__STRING2_COPY_ARR6
) \

685 { { ((
__const
 char *) (
src
))[0], ((__const char *) (src))[1], \

686 ((
__const
 char *) (
src
))[2], ((__const char *) (src))[3], \

687 ((
__const
 char *) (
src
))[4], '\0' } }), \

688 
	`__extension__
 ((
__STRING2_COPY_ARR7
) \

689 { { ((
__const
 char *) (
src
))[0], ((__const char *) (src))[1], \

690 ((
__const
 char *) (
src
))[2], ((__const char *) (src))[3], \

691 ((
__const
 char *) (
src
))[4], ((__const char *) (src))[5], \

693 
	`__extension__
 ((
__STRING2_COPY_ARR8
) \

694 { { ((
__const
 char *) (
src
))[0], ((__const char *) (src))[1], \

695 ((
__const
 char *) (
src
))[2], ((__const char *) (src))[3], \

696 ((
__const
 char *) (
src
))[4], ((__const char *) (src))[5], \

697 ((
__const
 char *) (
src
))[6], '\0' } })

	)

699 
__STRING_INLINE
 char *
__stpcpy_small
 (char *, 
__STRING2_COPY_ARR2
,

700 
__STRING2_COPY_ARR3
,

701 
__STRING2_COPY_ARR4
,

702 
__STRING2_COPY_ARR5
,

703 
__STRING2_COPY_ARR6
,

704 
__STRING2_COPY_ARR7
,

705 
__STRING2_COPY_ARR8
, 
size_t
);

706 
__STRING_INLINE
 char *

707 
	$__stpcpy_small
 (char *
__dest
,

708 
__STRING2_COPY_ARR2
 
__src2
, 
__STRING2_COPY_ARR3
 
__src3
,

709 
__STRING2_COPY_ARR4
 
__src4
, 
__STRING2_COPY_ARR5
 
__src5
,

710 
__STRING2_COPY_ARR6
 
__src6
, 
__STRING2_COPY_ARR7
 
__src7
,

711 
__STRING2_COPY_ARR8
 
__src8
, 
size_t
 
__srclen
)

714 char 
__c
;

715 
__STRING2_COPY_ARR2
 
__sca2
;

716 
__STRING2_COPY_ARR3
 
__sca3
;

717 
__STRING2_COPY_ARR4
 
__sca4
;

718 
__STRING2_COPY_ARR5
 
__sca5
;

719 
__STRING2_COPY_ARR6
 
__sca6
;

720 
__STRING2_COPY_ARR7
 
__sca7
;

721 
__STRING2_COPY_ARR8
 
__sca8
;

722 } *
__u
 = (void *) 
__dest
;

723 switch ((unsigned int) 
__srclen
)

726 
__u
->
__c
 = '\0';

729 
__extension__
 
__u
->
__sca2
 = 
__src2
;

732 
__extension__
 
__u
->
__sca3
 = 
__src3
;

735 
__extension__
 
__u
->
__sca4
 = 
__src4
;

738 
__extension__
 
__u
->
__sca5
 = 
__src5
;

741 
__extension__
 
__u
->
__sca6
 = 
__src6
;

744 
__extension__
 
__u
->
__sca7
 = 
__src7
;

747 
__extension__
 
__u
->
__sca8
 = 
__src8
;

750 return 
__dest
 + 
__srclen
 - 1;

751 
	}
}

759 #ifndef 
_HAVE_STRING_ARCH_strncpy


760 #if 
__GNUC_PREREQ
 (3, 2)

761 #define 
	#strncpy
(
dest
, 
src
, 
n
) 
	`__builtin_strncpy
 (dest, src, n)

	)

763 #define 
	#strncpy
(
dest
, 
src
, 
n
) \

764 (
	`__extension__
 (
	`__builtin_constant_p
 (
src
) && __builtin_constant_p (
n
) \

765 ? (
	`strlen
 (
src
) + 1 >= ((
size_t
) (
n
)) \

766 ? (char *) 
	`memcpy
 (
dest
, 
src
, 
n
) \

767 : 
	`strncpy
 (
dest
, 
src
, 
n
)) \

768 : 
	`strncpy
 (
dest
, 
src
, 
n
)))

	)

774 #ifndef 
_HAVE_STRING_ARCH_strncat


775 #ifdef 
_USE_STRING_ARCH_strchr


776 #define 
	#strncat
(
dest
, 
src
, 
n
) \

777 (
	`__extension__
 ({ char *
__dest
 = (
dest
); \

778 
	`__builtin_constant_p
 (
src
) && __builtin_constant_p (
n
) \

779 ? (
	`strlen
 (
src
) < ((
size_t
) (
n
)) \

780 ? 
	`strcat
 (
__dest
, 
src
) \

781 : (*((char *) 
	`__mempcpy
 (
	`strchr
 (
__dest
, '\0'), \

782 
src
, 
n
)) = '\0', 
__dest
)) \

783 : 
	`strncat
 (
dest
, 
src
, 
n
); }))

	)

784 #elif 
__GNUC_PREREQ
 (3, 2)

785 #define 
	#strncat
(
dest
, 
src
, 
n
) 
	`__builtin_strncat
 (dest, src, n)

	)

787 #define 
	#strncat
(
dest
, 
src
, 
n
) \

788 (
	`__extension__
 (
	`__builtin_constant_p
 (
src
) && __builtin_constant_p (
n
) \

789 ? (
	`strlen
 (
src
) < ((
size_t
) (
n
)) \

790 ? 
	`strcat
 (
dest
, 
src
) \

791 : 
	`strncat
 (
dest
, 
src
, 
n
)) \

792 : 
	`strncat
 (
dest
, 
src
, 
n
)))

	)

798 #ifndef 
_HAVE_STRING_ARCH_strcmp


799 #if 
__GNUC_PREREQ
 (3, 2)

800 #define 
	#strcmp
(
s1
, 
s2
) \

801 
__extension__
 \

802 ({ 
size_t
 
__s1_len
, 
__s2_len
; \

803 (
	`__builtin_constant_p
 (
s1
) && __builtin_constant_p (
s2
) \

804 && (
__s1_len
 = 
	`strlen
 (
s1
), 
__s2_len
 = strlen (
s2
), \

805 (!
	`__string2_1bptr_p
 (
s1
) || 
__s1_len
 >= 4) \

806 && (!
	`__string2_1bptr_p
 (
s2
) || 
__s2_len
 >= 4)) \

807 ? 
	`__builtin_strcmp
 (
s1
, 
s2
) \

808 : (
	`__builtin_constant_p
 (
s1
) && 
	`__string2_1bptr_p
 (s1) \

809 && (
__s1_len
 = 
	`strlen
 (
s1
), __s1_len < 4) \

810 ? (
	`__builtin_constant_p
 (
s2
) && 
	`__string2_1bptr_p
 (s2) \

811 ? 
	`__builtin_strcmp
 (
s1
, 
s2
) \

812 : 
	`__strcmp_cg
 (
s1
, 
s2
, 
__s1_len
)) \

813 : (
	`__builtin_constant_p
 (
s2
) && 
	`__string2_1bptr_p
 (s2) \

814 && (
__s2_len
 = 
	`strlen
 (
s2
), __s2_len < 4) \

815 ? (
	`__builtin_constant_p
 (
s1
) && 
	`__string2_1bptr_p
 (s1) \

816 ? 
	`__builtin_strcmp
 (
s1
, 
s2
) \

817 : 
	`__strcmp_gc
 (
s1
, 
s2
, 
__s2_len
)) \

818 : 
	`__builtin_strcmp
 (
s1
, 
s2
)))); })

	)

820 #define 
	#strcmp
(
s1
, 
s2
) \

821 
__extension__
 \

822 ({ 
size_t
 
__s1_len
, 
__s2_len
; \

823 (
	`__builtin_constant_p
 (
s1
) && __builtin_constant_p (
s2
) \

824 && (
__s1_len
 = 
	`strlen
 (
s1
), 
__s2_len
 = strlen (
s2
), \

825 (!
	`__string2_1bptr_p
 (
s1
) || 
__s1_len
 >= 4) \

826 && (!
	`__string2_1bptr_p
 (
s2
) || 
__s2_len
 >= 4)) \

827 ? 
	`memcmp
 ((
__const
 char *) (
s1
), (__const char *) (
s2
), \

828 (
__s1_len
 < 
__s2_len
 ? __s1_len : __s2_len) + 1) \

829 : (
	`__builtin_constant_p
 (
s1
) && 
	`__string2_1bptr_p
 (s1) \

830 && (
__s1_len
 = 
	`strlen
 (
s1
), __s1_len < 4) \

831 ? (
	`__builtin_constant_p
 (
s2
) && 
	`__string2_1bptr_p
 (s2) \

832 ? 
	`__strcmp_cc
 (
s1
, 
s2
, 
__s1_len
) \

833 : 
	`__strcmp_cg
 (
s1
, 
s2
, 
__s1_len
)) \

834 : (
	`__builtin_constant_p
 (
s2
) && 
	`__string2_1bptr_p
 (s2) \

835 && (
__s2_len
 = 
	`strlen
 (
s2
), __s2_len < 4) \

836 ? (
	`__builtin_constant_p
 (
s1
) && 
	`__string2_1bptr_p
 (s1) \

837 ? 
	`__strcmp_cc
 (
s1
, 
s2
, 
__s2_len
) \

838 : 
	`__strcmp_gc
 (
s1
, 
s2
, 
__s2_len
)) \

839 : 
	`strcmp
 (
s1
, 
s2
)))); })

	)

842 #define 
	#__strcmp_cc
(
s1
, 
s2
, 
l
) \

843 (
	`__extension__
 ({ register int 
__result
 = \

844 (((
__const
 unsigned char *) (__const char *) (
s1
))[0] \

845 - ((
__const
 unsigned char *) (__const char *)(
s2
))[0]);\

846 if (
l
 > 0 && 
__result
 == 0) \

848 
__result
 = (((
__const
 unsigned char *) \

849 (
__const
 char *) (
s1
))[1] \

850 - ((
__const
 unsigned char *) \

851 (
__const
 char *) (
s2
))[1]); \

852 if (
l
 > 1 && 
__result
 == 0) \

854 
__result
 = \

855 (((
__const
 unsigned char *) \

856 (
__const
 char *) (
s1
))[2] \

857 - ((
__const
 unsigned char *) \

858 (
__const
 char *) (
s2
))[2]); \

859 if (
l
 > 2 && 
__result
 == 0) \

860 
__result
 = \

861 (((
__const
 unsigned char *) \

862 (
__const
 char *) (
s1
))[3] \

863 - ((
__const
 unsigned char *) \

864 (
__const
 char *) (
s2
))[3]); \

867 
__result
; }))

	)

869 #define 
	#__strcmp_cg
(
s1
, 
s2
, 
l1
) \

870 (
	`__extension__
 ({ 
__const
 unsigned char *
__s2
 = \

871 (
__const
 unsigned char *) (__const char *) (
s2
); \

872 register int 
__result
 = \

873 (((
__const
 unsigned char *) (__const char *) (
s1
))[0] \

874 - 
__s2
[0]); \

875 if (
l1
 > 0 && 
__result
 == 0) \

877 
__result
 = (((
__const
 unsigned char *) \

878 (
__const
 char *) (
s1
))[1] - 
__s2
[1]); \

879 if (
l1
 > 1 && 
__result
 == 0) \

881 
__result
 = (((
__const
 unsigned char *) \

882 (
__const
 char *) (
s1
))[2] - 
__s2
[2]);\

883 if (
l1
 > 2 && 
__result
 == 0) \

884 
__result
 = (((
__const
 unsigned char *) \

885 (
__const
 char *) (
s1
))[3] \

886 - 
__s2
[3]); \

889 
__result
; }))

	)

891 #define 
	#__strcmp_gc
(
s1
, 
s2
, 
l2
) \

892 (
	`__extension__
 ({ 
__const
 unsigned char *
__s1
 = \

893 (
__const
 unsigned char *) (__const char *) (
s1
); \

894 register int 
__result
 = \

895 
__s1
[0] - ((
__const
 unsigned char *) \

896 (
__const
 char *) (
s2
))[0]; \

897 if (
l2
 > 0 && 
__result
 == 0) \

899 
__result
 = (
__s1
[1] \

900 - ((
__const
 unsigned char *) \

901 (
__const
 char *) (
s2
))[1]); \

902 if (
l2
 > 1 && 
__result
 == 0) \

904 
__result
 = \

905 (
__s1
[2] - ((
__const
 unsigned char *) \

906 (
__const
 char *) (
s2
))[2]); \

907 if (
l2
 > 2 && 
__result
 == 0) \

908 
__result
 = \

909 (
__s1
[3] \

910 - ((
__const
 unsigned char *) \

911 (
__const
 char *) (
s2
))[3]); \

914 
__result
; }))

	)

919 #ifndef 
_HAVE_STRING_ARCH_strncmp


920 #define 
	#strncmp
(
s1
, 
s2
, 
n
) \

921 (
	`__extension__
 (
	`__builtin_constant_p
 (
n
) \

922 && ((
	`__builtin_constant_p
 (
s1
) \

923 && 
	`strlen
 (
s1
) < ((
size_t
) (
n
))) \

924 || (
	`__builtin_constant_p
 (
s2
) \

925 && 
	`strlen
 (
s2
) < ((
size_t
) (
n
)))) \

926 ? 
	`strcmp
 (
s1
, 
s2
) : 
	`strncmp
 (s1, s2, 
n
)))

	)

932 #if !
defined
 
_HAVE_STRING_ARCH_strcspn
 || defined 
_FORCE_INLINES


933 #ifndef 
_HAVE_STRING_ARCH_strcspn


934 #if 
__GNUC_PREREQ
 (3, 2)

935 #define 
	#strcspn
(
s
, 
reject
) \

936 
__extension__
 \

937 ({ char 
__r0
, 
__r1
, 
__r2
; \

938 (
	`__builtin_constant_p
 (
reject
) && 
	`__string2_1bptr_p
 (reject) \

939 ? ((
	`__builtin_constant_p
 (
s
) && 
	`__string2_1bptr_p
 (s)) \

940 ? 
	`__builtin_strcspn
 (
s
, 
reject
) \

941 : ((
__r0
 = ((
__const
 char *) (
reject
))[0], __r0 == '\0') \

942 ? 
	`strlen
 (
s
) \

943 : ((
__r1
 = ((
__const
 char *) (
reject
))[1], __r1 == '\0') \

944 ? 
	`__strcspn_c1
 (
s
, 
__r0
) \

945 : ((
__r2
 = ((
__const
 char *) (
reject
))[2], __r2 == '\0') \

946 ? 
	`__strcspn_c2
 (
s
, 
__r0
, 
__r1
) \

947 : (((
__const
 char *) (
reject
))[3] == '\0' \

948 ? 
	`__strcspn_c3
 (
s
, 
__r0
, 
__r1
, 
__r2
) \

949 : 
	`__builtin_strcspn
 (
s
, 
reject
)))))) \

950 : 
	`__builtin_strcspn
 (
s
, 
reject
)); })

	)

952 #define 
	#strcspn
(
s
, 
reject
) \

953 
__extension__
 \

954 ({ char 
__r0
, 
__r1
, 
__r2
; \

955 (
	`__builtin_constant_p
 (
reject
) && 
	`__string2_1bptr_p
 (reject) \

956 ? ((
__r0
 = ((
__const
 char *) (
reject
))[0], __r0 == '\0') \

957 ? 
	`strlen
 (
s
) \

958 : ((
__r1
 = ((
__const
 char *) (
reject
))[1], __r1 == '\0') \

959 ? 
	`__strcspn_c1
 (
s
, 
__r0
) \

960 : ((
__r2
 = ((
__const
 char *) (
reject
))[2], __r2 == '\0') \

961 ? 
	`__strcspn_c2
 (
s
, 
__r0
, 
__r1
) \

962 : (((
__const
 char *) (
reject
))[3] == '\0' \

963 ? 
	`__strcspn_c3
 (
s
, 
__r0
, 
__r1
, 
__r2
) \

964 : 
	`strcspn
 (
s
, 
reject
))))) \

965 : 
	`strcspn
 (
s
, 
reject
)); })

	)

969 
__STRING_INLINE
 
size_t
 
__strcspn_c1
 (
__const
 char *
__s
, int 
__reject
);

970 
__STRING_INLINE
 
size_t


971 
	$__strcspn_c1
 (
__const
 char *
__s
, int 
__reject
)

973 register 
size_t
 
__result
 = 0;

974 while (
__s
[
__result
] != '\0' && __s[__result] != 
__reject
)

975 ++
__result
;

976 return 
__result
;

977 
	}
}

979 
__STRING_INLINE
 
size_t
 
__strcspn_c2
 (
__const
 char *
__s
, int 
__reject1
,

980 int 
__reject2
);

981 
__STRING_INLINE
 
size_t


982 
	$__strcspn_c2
 (
__const
 char *
__s
, int 
__reject1
, int 
__reject2
)

984 register 
size_t
 
__result
 = 0;

985 while (
__s
[
__result
] != '\0' && __s[__result] != 
__reject1


986 && 
__s
[
__result
] != 
__reject2
)

987 ++
__result
;

988 return 
__result
;

989 
	}
}

991 
__STRING_INLINE
 
size_t
 
__strcspn_c3
 (
__const
 char *
__s
, int 
__reject1
,

992 int 
__reject2
, int 
__reject3
);

993 
__STRING_INLINE
 
size_t


994 
	$__strcspn_c3
 (
__const
 char *
__s
, int 
__reject1
, int 
__reject2
,

995 int 
__reject3
)

997 register 
size_t
 
__result
 = 0;

998 while (
__s
[
__result
] != '\0' && __s[__result] != 
__reject1


999 && 
__s
[
__result
] != 
__reject2
 && __s[__result] != 
__reject3
)

1000 ++
__result
;

1001 return 
__result
;

1002 
	}
}

1008 #if !
defined
 
_HAVE_STRING_ARCH_strspn
 || defined 
_FORCE_INLINES


1009 #ifndef 
_HAVE_STRING_ARCH_strspn


1010 #if 
__GNUC_PREREQ
 (3, 2)

1011 #define 
	#strspn
(
s
, 
accept
) \

1012 
__extension__
 \

1013 ({ char 
__a0
, 
__a1
, 
__a2
; \

1014 (
	`__builtin_constant_p
 (
accept
) && 
	`__string2_1bptr_p
 (accept) \

1015 ? ((
	`__builtin_constant_p
 (
s
) && 
	`__string2_1bptr_p
 (s)) \

1016 ? 
	`__builtin_strspn
 (
s
, 
accept
) \

1017 : ((
__a0
 = ((
__const
 char *) (
accept
))[0], __a0 == '\0') \

1018 ? ((void) (
s
), 0) \

1019 : ((
__a1
 = ((
__const
 char *) (
accept
))[1], __a1 == '\0') \

1020 ? 
	`__strspn_c1
 (
s
, 
__a0
) \

1021 : ((
__a2
 = ((
__const
 char *) (
accept
))[2], __a2 == '\0') \

1022 ? 
	`__strspn_c2
 (
s
, 
__a0
, 
__a1
) \

1023 : (((
__const
 char *) (
accept
))[3] == '\0' \

1024 ? 
	`__strspn_c3
 (
s
, 
__a0
, 
__a1
, 
__a2
) \

1025 : 
	`__builtin_strspn
 (
s
, 
accept
)))))) \

1026 : 
	`__builtin_strspn
 (
s
, 
accept
)); })

	)

1028 #define 
	#strspn
(
s
, 
accept
) \

1029 
__extension__
 \

1030 ({ char 
__a0
, 
__a1
, 
__a2
; \

1031 (
	`__builtin_constant_p
 (
accept
) && 
	`__string2_1bptr_p
 (accept) \

1032 ? ((
__a0
 = ((
__const
 char *) (
accept
))[0], __a0 == '\0') \

1033 ? ((void) (
s
), 0) \

1034 : ((
__a1
 = ((
__const
 char *) (
accept
))[1], __a1 == '\0') \

1035 ? 
	`__strspn_c1
 (
s
, 
__a0
) \

1036 : ((
__a2
 = ((
__const
 char *) (
accept
))[2], __a2 == '\0') \

1037 ? 
	`__strspn_c2
 (
s
, 
__a0
, 
__a1
) \

1038 : (((
__const
 char *) (
accept
))[3] == '\0' \

1039 ? 
	`__strspn_c3
 (
s
, 
__a0
, 
__a1
, 
__a2
) \

1040 : 
	`strspn
 (
s
, 
accept
))))) \

1041 : 
	`strspn
 (
s
, 
accept
)); })

	)

1045 
__STRING_INLINE
 
size_t
 
__strspn_c1
 (
__const
 char *
__s
, int 
__accept
);

1046 
__STRING_INLINE
 
size_t


1047 
	$__strspn_c1
 (
__const
 char *
__s
, int 
__accept
)

1049 register 
size_t
 
__result
 = 0;

1051 while (
__s
[
__result
] == 
__accept
)

1052 ++
__result
;

1053 return 
__result
;

1054 
	}
}

1056 
__STRING_INLINE
 
size_t
 
__strspn_c2
 (
__const
 char *
__s
, int 
__accept1
,

1057 int 
__accept2
);

1058 
__STRING_INLINE
 
size_t


1059 
	$__strspn_c2
 (
__const
 char *
__s
, int 
__accept1
, int 
__accept2
)

1061 register 
size_t
 
__result
 = 0;

1063 while (
__s
[
__result
] == 
__accept1
 || __s[__result] == 
__accept2
)

1064 ++
__result
;

1065 return 
__result
;

1066 
	}
}

1068 
__STRING_INLINE
 
size_t
 
__strspn_c3
 (
__const
 char *
__s
, int 
__accept1
,

1069 int 
__accept2
, int 
__accept3
);

1070 
__STRING_INLINE
 
size_t


1071 
	$__strspn_c3
 (
__const
 char *
__s
, int 
__accept1
, int 
__accept2
, int 
__accept3
)

1073 register 
size_t
 
__result
 = 0;

1075 while (
__s
[
__result
] == 
__accept1
 || __s[__result] == 
__accept2


1076 || 
__s
[
__result
] == 
__accept3
)

1077 ++
__result
;

1078 return 
__result
;

1079 
	}
}

1084 #if !
defined
 
_HAVE_STRING_ARCH_strpbrk
 || defined 
_FORCE_INLINES


1085 #ifndef 
_HAVE_STRING_ARCH_strpbrk


1086 #if 
__GNUC_PREREQ
 (3, 2)

1087 #define 
	#strpbrk
(
s
, 
accept
) \

1088 
__extension__
 \

1089 ({ char 
__a0
, 
__a1
, 
__a2
; \

1090 (
	`__builtin_constant_p
 (
accept
) && 
	`__string2_1bptr_p
 (accept) \

1091 ? ((
	`__builtin_constant_p
 (
s
) && 
	`__string2_1bptr_p
 (s)) \

1092 ? 
	`__builtin_strpbrk
 (
s
, 
accept
) \

1093 : ((
__a0
 = ((
__const
 char *) (
accept
))[0], __a0 == '\0') \

1094 ? ((void) (
s
), (char *) 
NULL
) \

1095 : ((
__a1
 = ((
__const
 char *) (
accept
))[1], __a1 == '\0') \

1096 ? 
	`__builtin_strchr
 (
s
, 
__a0
) \

1097 : ((
__a2
 = ((
__const
 char *) (
accept
))[2], __a2 == '\0') \

1098 ? 
	`__strpbrk_c2
 (
s
, 
__a0
, 
__a1
) \

1099 : (((
__const
 char *) (
accept
))[3] == '\0' \

1100 ? 
	`__strpbrk_c3
 (
s
, 
__a0
, 
__a1
, 
__a2
) \

1101 : 
	`__builtin_strpbrk
 (
s
, 
accept
)))))) \

1102 : 
	`__builtin_strpbrk
 (
s
, 
accept
)); })

	)

1104 #define 
	#strpbrk
(
s
, 
accept
) \

1105 
__extension__
 \

1106 ({ char 
__a0
, 
__a1
, 
__a2
; \

1107 (
	`__builtin_constant_p
 (
accept
) && 
	`__string2_1bptr_p
 (accept) \

1108 ? ((
__a0
 = ((
__const
 char *) (
accept
))[0], __a0 == '\0') \

1109 ? ((void) (
s
), (char *) 
NULL
) \

1110 : ((
__a1
 = ((
__const
 char *) (
accept
))[1], __a1 == '\0') \

1111 ? 
	`strchr
 (
s
, 
__a0
) \

1112 : ((
__a2
 = ((
__const
 char *) (
accept
))[2], __a2 == '\0') \

1113 ? 
	`__strpbrk_c2
 (
s
, 
__a0
, 
__a1
) \

1114 : (((
__const
 char *) (
accept
))[3] == '\0' \

1115 ? 
	`__strpbrk_c3
 (
s
, 
__a0
, 
__a1
, 
__a2
) \

1116 : 
	`strpbrk
 (
s
, 
accept
))))) \

1117 : 
	`strpbrk
 (
s
, 
accept
)); })

	)

1121 
__STRING_INLINE
 char *
__strpbrk_c2
 (
__const
 char *
__s
, int 
__accept1
,

1122 int 
__accept2
);

1123 
__STRING_INLINE
 char *

1124 
	$__strpbrk_c2
 (
__const
 char *
__s
, int 
__accept1
, int 
__accept2
)

1127 while (*
__s
 != '\0' && *__s != 
__accept1
 && *__s != 
__accept2
)

1128 ++
__s
;

1129 return *
__s
 == '\0' ? 
NULL
 : (char *) (
size_t
) __s;

1130 
	}
}

1132 
__STRING_INLINE
 char *
__strpbrk_c3
 (
__const
 char *
__s
, int 
__accept1
,

1133 int 
__accept2
, int 
__accept3
);

1134 
__STRING_INLINE
 char *

1135 
	$__strpbrk_c3
 (
__const
 char *
__s
, int 
__accept1
, int 
__accept2
,

1136 int 
__accept3
)

1139 while (*
__s
 != '\0' && *__s != 
__accept1
 && *__s != 
__accept2


1140 && *
__s
 != 
__accept3
)

1141 ++
__s
;

1142 return *
__s
 == '\0' ? 
NULL
 : (char *) (
size_t
) __s;

1143 
	}
}

1149 #if !
defined
 
_HAVE_STRING_ARCH_strstr
 && !
__GNUC_PREREQ
 (2, 97)

1150 #define 
	#strstr
(
haystack
, 
needle
) \

1151 (
	`__extension__
 (
	`__builtin_constant_p
 (
needle
) && 
	`__string2_1bptr_p
 (needle) \

1152 ? (((
__const
 char *) (
needle
))[0] == '\0' \

1153 ? (char *) (
size_t
) (
haystack
) \

1154 : (((
__const
 char *) (
needle
))[1] == '\0' \

1155 ? 
	`strchr
 (
haystack
, \

1156 ((
__const
 char *) (
needle
))[0]) \

1157 : 
	`strstr
 (
haystack
, 
needle
))) \

1158 : 
	`strstr
 (
haystack
, 
needle
)))

	)

1162 #if !
defined
 
_HAVE_STRING_ARCH_strtok_r
 || defined 
_FORCE_INLINES


1163 #ifndef 
_HAVE_STRING_ARCH_strtok_r


1164 #define 
	#__strtok_r
(
s
, 
sep
, 
nextp
) \

1165 (
	`__extension__
 (
	`__builtin_constant_p
 (
sep
) && 
	`__string2_1bptr_p
 (sep) \

1166 && ((
__const
 char *) (
sep
))[0] != '\0' \

1167 && ((
__const
 char *) (
sep
))[1] == '\0' \

1168 ? 
	`__strtok_r_1c
 (
s
, ((
__const
 char *) (
sep
))[0], 
nextp
) \

1169 : 
	`__strtok_r
 (
s
, 
sep
, 
nextp
)))

	)

1172 
__STRING_INLINE
 char *
__strtok_r_1c
 (char *
__s
, char 
__sep
, char **
__nextp
);

1173 
__STRING_INLINE
 char *

1174 
	$__strtok_r_1c
 (char *
__s
, char 
__sep
, char **
__nextp
)

1176 char *
__result
;

1177 if (
__s
 == 
NULL
)

1178 
__s
 = *
__nextp
;

1179 while (*
__s
 == 
__sep
)

1180 ++
__s
;

1181 
__result
 = 
NULL
;

1182 if (*
__s
 != '\0')

1184 
__result
 = 
__s
++;

1185 while (*
__s
 != '\0')

1186 if (*
__s
++ == 
__sep
)

1188 
__s
[-1] = '\0';

1192 *
__nextp
 = 
__s
;

1193 return 
__result
;

1194 
	}
}

1195 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


1196 #define 
	#strtok_r
(
s
, 
sep
, 
nextp
) 
	`__strtok_r
 (s, sep, nextp)

	)

1201 #if !
defined
 
_HAVE_STRING_ARCH_strsep
 || defined 
_FORCE_INLINES


1202 #ifndef 
_HAVE_STRING_ARCH_strsep


1204 extern char *
__strsep_g
 (char **
__stringp
, 
__const
 char *
__delim
);

1205 #define 
	#__strsep
(
s
, 
reject
) \

1206 
__extension__
 \

1207 ({ char 
__r0
, 
__r1
, 
__r2
; \

1208 (
	`__builtin_constant_p
 (
reject
) && 
	`__string2_1bptr_p
 (reject) \

1209 && (
__r0
 = ((
__const
 char *) (
reject
))[0], \

1210 ((
__const
 char *) (
reject
))[0] != '\0') \

1211 ? ((
__r1
 = ((
__const
 char *) (
reject
))[1], \

1212 ((
__const
 char *) (
reject
))[1] == '\0') \

1213 ? 
	`__strsep_1c
 (
s
, 
__r0
) \

1214 : ((
__r2
 = ((
__const
 char *) (
reject
))[2], __r2 == '\0') \

1215 ? 
	`__strsep_2c
 (
s
, 
__r0
, 
__r1
) \

1216 : (((
__const
 char *) (
reject
))[3] == '\0' \

1217 ? 
	`__strsep_3c
 (
s
, 
__r0
, 
__r1
, 
__r2
) \

1218 : 
	`__strsep_g
 (
s
, 
reject
)))) \

1219 : 
	`__strsep_g
 (
s
, 
reject
)); })

	)

1222 
__STRING_INLINE
 char *
__strsep_1c
 (char **
__s
, char 
__reject
);

1223 
__STRING_INLINE
 char *

1224 
	$__strsep_1c
 (char **
__s
, char 
__reject
)

1226 register char *
__retval
 = *
__s
;

1227 if (
__retval
 != 
NULL
 && (*
__s
 = 
	`strchr
 (__retval, 
__reject
)) != NULL)

1228 *(*
__s
)++ = '\0';

1229 return 
__retval
;

1230 
	}
}

1232 
__STRING_INLINE
 char *
__strsep_2c
 (char **
__s
, char 
__reject1
, char 
__reject2
);

1233 
__STRING_INLINE
 char *

1234 
	$__strsep_2c
 (char **
__s
, char 
__reject1
, char 
__reject2
)

1236 register char *
__retval
 = *
__s
;

1237 if (
__retval
 != 
NULL
)

1239 register char *
__cp
 = 
__retval
;

1242 if (*
__cp
 == '\0')

1244 
__cp
 = 
NULL
;

1247 if (*
__cp
 == 
__reject1
 || *__cp == 
__reject2
)

1249 *
__cp
++ = '\0';

1252 ++
__cp
;

1254 *
__s
 = 
__cp
;

1256 return 
__retval
;

1257 
	}
}

1259 
__STRING_INLINE
 char *
__strsep_3c
 (char **
__s
, char 
__reject1
, char 
__reject2
,

1260 char 
__reject3
);

1261 
__STRING_INLINE
 char *

1262 
	$__strsep_3c
 (char **
__s
, char 
__reject1
, char 
__reject2
, char 
__reject3
)

1264 register char *
__retval
 = *
__s
;

1265 if (
__retval
 != 
NULL
)

1267 register char *
__cp
 = 
__retval
;

1270 if (*
__cp
 == '\0')

1272 
__cp
 = 
NULL
;

1275 if (*
__cp
 == 
__reject1
 || *__cp == 
__reject2
 || *__cp == 
__reject3
)

1277 *
__cp
++ = '\0';

1280 ++
__cp
;

1282 *
__s
 = 
__cp
;

1284 return 
__retval
;

1285 
	}
}

1286 #ifdef 
__USE_BSD


1287 #define 
	#strsep
(
s
, 
reject
) 
	`__strsep
 (s, reject)

	)

1294 #ifdef 
__USE_MISC


1296 #if !
defined
 
_HAVE_STRING_ARCH_strdup
 || !defined 
_HAVE_STRING_ARCH_strndup


1297 #define 
	#__need_malloc_and_calloc


	)

1298 #include 
	~<stdlib.h
>

1301 #ifndef 
_HAVE_STRING_ARCH_strdup


1303 extern char *
	$__strdup
 (
__const
 char *
__string
) 
__THROW
 
__attribute_malloc__
;

1304 #define 
	#__strdup
(
s
) \

1305 (
	`__extension__
 (
	`__builtin_constant_p
 (
s
) && 
	`__string2_1bptr_p
 (s) \

1306 ? (((
__const
 char *) (
s
))[0] == '\0' \

1307 ? (char *) 
	`calloc
 ((
size_t
) 1, (size_t) 1) \

1308 : ({ 
size_t
 
__len
 = 
	`strlen
 (
s
) + 1; \

1309 char *
__retval
 = (char *) 
	`malloc
 (
__len
); \

1310 if (
__retval
 != 
NULL
) \

1311 
__retval
 = (char *) 
	`memcpy
 (__retval, 
s
, 
__len
); \

1312 
__retval
; 
	}
})) \

1313 : 
	`__strdup
 (
s
)))

	)

1315 #if 
defined
 
__USE_SVID
 || defined 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED


1316 #define 
	#strdup
(
s
) 
	`__strdup
 (s)

	)

1320 #ifndef 
_HAVE_STRING_ARCH_strndup


1322 extern char *
	$__strndup
 (
__const
 char *
__string
, 
size_t
 
__n
)

1323 
__THROW
 
__attribute_malloc__
;

1324 #define 
	#__strndup
(
s
, 
n
) \

1325 (
	`__extension__
 (
	`__builtin_constant_p
 (
s
) && 
	`__string2_1bptr_p
 (s) \

1326 ? (((
__const
 char *) (
s
))[0] == '\0' \

1327 ? (char *) 
	`calloc
 ((
size_t
) 1, (size_t) 1) \

1328 : ({ 
size_t
 
__len
 = 
	`strlen
 (
s
) + 1; \

1329 
size_t
 
__n
 = (
n
); \

1330 char *
__retval
; \

1331 if (
__n
 < 
__len
) \

1332 
__len
 = 
__n
 + 1; \

1333 
__retval
 = (char *) 
	`malloc
 (
__len
); \

1334 if (
__retval
 != 
NULL
) \

1336 
__retval
[
__len
 - 1] = '\0'; \

1337 
__retval
 = (char *) 
	`memcpy
 (__retval, 
s
, \

1338 
__len
 - 1); \

1340 
__retval
; 
	}
})) \

1341 : 
	`__strndup
 (
s
, 
n
)))

	)

1343 #ifdef 
__USE_GNU


1344 #define 
	#strndup
(
s
, 
n
) 
	`__strndup
 (s, n)

	)

1350 #ifndef 
_FORCE_INLINES


1351 #undef 
__STRING_INLINE


	@/usr/include/bits/string3.h

19 #ifndef 
_STRING_H


23 
__warndecl
 (
__warn_memset_zero_len
,

26 #ifndef 
__cplusplus


30 #undef 
memcpy


31 #undef 
memmove


32 #undef 
memset


33 #undef 
strcat


34 #undef 
strcpy


35 #undef 
strncat


36 #undef 
strncpy


37 #ifdef 
__USE_GNU


38 #undef 
mempcpy


39 #undef 
stpcpy


41 #ifdef 
__USE_BSD


42 #undef 
bcopy


43 #undef 
bzero


48 
__extern_always_inline
 void *

49 
__NTH
 (
	$memcpy
 (void *
__restrict
 
__dest
, 
__const
 void *__restrict 
__src
,

50 
size_t
 
__len
))

52 return 
	`__builtin___memcpy_chk
 (
__dest
, 
__src
, 
__len
, 
	`__bos0
 (__dest));

53 
	}
}

55 
__extern_always_inline
 void *

56 
__NTH
 (
	$memmove
 (void *
__dest
, 
__const
 void *
__src
, 
size_t
 
__len
))

58 return 
	`__builtin___memmove_chk
 (
__dest
, 
__src
, 
__len
, 
	`__bos0
 (__dest));

59 
	}
}

61 #ifdef 
__USE_GNU


62 
__extern_always_inline
 void *

63 
__NTH
 (
	$mempcpy
 (void *
__restrict
 
__dest
, 
__const
 void *__restrict 
__src
,

64 
size_t
 
__len
))

66 return 
	`__builtin___mempcpy_chk
 (
__dest
, 
__src
, 
__len
, 
	`__bos0
 (__dest));

67 
	}
}

76 
__extern_always_inline
 void *

77 
__NTH
 (
	$memset
 (void *
__dest
, int 
__ch
, 
size_t
 
__len
))

79 if (
	`__builtin_constant_p
 (
__len
) && __len == 0

80 && (!
	`__builtin_constant_p
 (
__ch
) || __ch != 0))

82 
	`__warn_memset_zero_len
 ();

83 return 
__dest
;

85 return 
	`__builtin___memset_chk
 (
__dest
, 
__ch
, 
__len
, 
	`__bos0
 (__dest));

86 
	}
}

88 #ifdef 
__USE_BSD


89 
__extern_always_inline
 void

90 
__NTH
 (
	$bcopy
 (
__const
 void *
__src
, void *
__dest
, 
size_t
 
__len
))

92 (void) 
	`__builtin___memmove_chk
 (
__dest
, 
__src
, 
__len
, 
	`__bos0
 (__dest));

93 
	}
}

95 
__extern_always_inline
 void

96 
__NTH
 (
	$bzero
 (void *
__dest
, 
size_t
 
__len
))

98 (void) 
	`__builtin___memset_chk
 (
__dest
, '\0', 
__len
, 
	`__bos0
 (__dest));

99 
	}
}

102 
__extern_always_inline
 char *

103 
__NTH
 (
	$strcpy
 (char *
__restrict
 
__dest
, 
__const
 char *__restrict 
__src
))

105 return 
	`__builtin___strcpy_chk
 (
__dest
, 
__src
, 
	`__bos
 (__dest));

106 
	}
}

108 #ifdef 
__USE_GNU


109 
__extern_always_inline
 char *

110 
__NTH
 (
	$stpcpy
 (char *
__restrict
 
__dest
, 
__const
 char *__restrict 
__src
))

112 return 
	`__builtin___stpcpy_chk
 (
__dest
, 
__src
, 
	`__bos
 (__dest));

113 
	}
}

117 
__extern_always_inline
 char *

118 
__NTH
 (
	$strncpy
 (char *
__restrict
 
__dest
, 
__const
 char *__restrict 
__src
,

119 
size_t
 
__len
))

121 return 
	`__builtin___strncpy_chk
 (
__dest
, 
__src
, 
__len
, 
	`__bos
 (__dest));

122 
	}
}

125 extern char *
	$__stpncpy_chk
 (char *
__dest
, 
__const
 char *
__src
, 
size_t
 
__n
,

126 
size_t
 
__destlen
) 
__THROW
;

127 extern char *
	`__REDIRECT_NTH
 (
__stpncpy_alias
, (char *
__dest
,

128 
__const
 char *
__src
,

129 
size_t
 
__n
), 
stpncpy
);

131 
__extern_always_inline
 char *

132 
	`__NTH
 (
	$stpncpy
 (char *
__dest
, 
__const
 char *
__src
, 
size_t
 
__n
))

134 if (
	`__bos
 (
__dest
) != (
size_t
) -1

135 && (!
	`__builtin_constant_p
 (
__n
) || __n <= 
	`__bos
 (
__dest
)))

136 return 
	`__stpncpy_chk
 (
__dest
, 
__src
, 
__n
, 
	`__bos
 (__dest));

137 return 
	`__stpncpy_alias
 (
__dest
, 
__src
, 
__n
);

138 
	}
}

141 
__extern_always_inline
 char *

142 
__NTH
 (
	$strcat
 (char *
__restrict
 
__dest
, 
__const
 char *__restrict 
__src
))

144 return 
	`__builtin___strcat_chk
 (
__dest
, 
__src
, 
	`__bos
 (__dest));

145 
	}
}

148 
__extern_always_inline
 char *

149 
__NTH
 (
	$strncat
 (char *
__restrict
 
__dest
, 
__const
 char *__restrict 
__src
,

150 
size_t
 
__len
))

152 return 
	`__builtin___strncat_chk
 (
__dest
, 
__src
, 
__len
, 
	`__bos
 (__dest));

153 
	}
}

	@/usr/include/bits/sys_errlist.h

20 #ifndef 
_STDIO_H


26 #ifdef 
__USE_BSD


27 extern int 
sys_nerr
;

28 extern 
__const
 char *__const 
sys_errlist
[];

30 #ifdef 
__USE_GNU


31 extern int 
_sys_nerr
;

32 extern 
__const
 char *__const 
_sys_errlist
[];

	@/usr/include/bits/types.h

24 #ifndef 
_BITS_TYPES_H


25 #define 
	#_BITS_TYPES_H
 1

	)

27 #include 
	~<features.h
>

28 #include 
	~<bits/wordsize.h
>

31 typedef unsigned char 
	t__u_char
;

32 typedef unsigned short int 
	t__u_short
;

33 typedef unsigned int 
	t__u_int
;

34 typedef unsigned long int 
	t__u_long
;

37 typedef signed char 
	t__int8_t
;

38 typedef unsigned char 
	t__uint8_t
;

39 typedef signed short int 
	t__int16_t
;

40 typedef unsigned short int 
	t__uint16_t
;

41 typedef signed int 
	t__int32_t
;

42 typedef unsigned int 
	t__uint32_t
;

43 #if 
__WORDSIZE
 == 64

44 typedef signed long int 
	t__int64_t
;

45 typedef unsigned long int 
	t__uint64_t
;

46 #elif 
defined
 
__GLIBC_HAVE_LONG_LONG


47 
__extension__
 typedef signed long long int 
	t__int64_t
;

48 
__extension__
 typedef unsigned long long int 
	t__uint64_t
;

52 #if 
__WORDSIZE
 == 64

53 typedef long int 
	t__quad_t
;

54 typedef unsigned long int 
	t__u_quad_t
;

55 #elif 
defined
 
__GLIBC_HAVE_LONG_LONG


56 
__extension__
 typedef long long int 
	t__quad_t
;

57 
__extension__
 typedef unsigned long long int 
	t__u_quad_t
;

61 long 
	m__val
[2];

62 } 
	t__quad_t
;

65 
__u_long
 
	m__val
[2];

66 } 
	t__u_quad_t
;

99 #define 
	#__S16_TYPE
 short int

	)

100 #define 
	#__U16_TYPE
 unsigned short int

	)

101 #define 
	#__S32_TYPE
 int

	)

102 #define 
	#__U32_TYPE
 unsigned int

	)

103 #define 
	#__SLONGWORD_TYPE
 long int

	)

104 #define 
	#__ULONGWORD_TYPE
 unsigned long int

	)

105 #if 
__WORDSIZE
 == 32

106 #define 
	#__SQUAD_TYPE
 
__quad_t


	)

107 #define 
	#__UQUAD_TYPE
 
__u_quad_t


	)

108 #define 
	#__SWORD_TYPE
 int

	)

109 #define 
	#__UWORD_TYPE
 unsigned int

	)

110 #define 
	#__SLONG32_TYPE
 long int

	)

111 #define 
	#__ULONG32_TYPE
 unsigned long int

	)

112 #define 
	#__S64_TYPE
 
__quad_t


	)

113 #define 
	#__U64_TYPE
 
__u_quad_t


	)

116 #define 
	#__STD_TYPE
 
__extension__
 typedef

	)

117 #elif 
__WORDSIZE
 == 64

118 #define 
	t__SQUAD_TYPE
 long int

	)

119 #define 
	t__UQUAD_TYPE
 unsigned long int

	)

120 #define 
	t__SWORD_TYPE
 long int

	)

121 #define 
	t__UWORD_TYPE
 unsigned long int

	)

122 #define 
	t__SLONG32_TYPE
 int

	)

123 #define 
	t__ULONG32_TYPE
 unsigned int

	)

124 #define 
	t__S64_TYPE
 long int

	)

125 #define 
	t__U64_TYPE
 unsigned long int

	)

127 #define 
	t__STD_TYPE
 typedef

	)

131 #include 
	~<bits/typesizes.h
>

134 
__STD_TYPE
 
	t__DEV_T_TYPE
 
	t__dev_t
;

135 
__STD_TYPE
 
__UID_T_TYPE
 
	g__uid_t
;

136 
__STD_TYPE
 
__GID_T_TYPE
 
	g__gid_t
;

137 
__STD_TYPE
 
__INO_T_TYPE
 
	g__ino_t
;

138 
__STD_TYPE
 
__INO64_T_TYPE
 
	g__ino64_t
;

139 
__STD_TYPE
 
__MODE_T_TYPE
 
	g__mode_t
;

140 
__STD_TYPE
 
__NLINK_T_TYPE
 
	g__nlink_t
;

141 
__STD_TYPE
 
__OFF_T_TYPE
 
	g__off_t
;

142 
__STD_TYPE
 
__OFF64_T_TYPE
 
	g__off64_t
;

143 
__STD_TYPE
 
__PID_T_TYPE
 
	g__pid_t
;

144 
__STD_TYPE
 
__FSID_T_TYPE
 
	g__fsid_t
;

145 
__STD_TYPE
 
__CLOCK_T_TYPE
 
	g__clock_t
;

146 
__STD_TYPE
 
__RLIM_T_TYPE
 
	g__rlim_t
;

147 
__STD_TYPE
 
__RLIM64_T_TYPE
 
	g__rlim64_t
;

148 
__STD_TYPE
 
__ID_T_TYPE
 
	g__id_t
;

149 
__STD_TYPE
 
__TIME_T_TYPE
 
	g__time_t
;

150 
__STD_TYPE
 
__USECONDS_T_TYPE
 
	g__useconds_t
;

151 
__STD_TYPE
 
__SUSECONDS_T_TYPE
 
	g__suseconds_t
;

153 
__STD_TYPE
 
__DADDR_T_TYPE
 
	g__daddr_t
;

154 
__STD_TYPE
 
__SWBLK_T_TYPE
 
	g__swblk_t
;

155 
__STD_TYPE
 
__KEY_T_TYPE
 
	g__key_t
;

158 
__STD_TYPE
 
__CLOCKID_T_TYPE
 
	g__clockid_t
;

161 
__STD_TYPE
 
__TIMER_T_TYPE
 
	g__timer_t
;

164 
__STD_TYPE
 
__BLKSIZE_T_TYPE
 
	g__blksize_t
;

169 
__STD_TYPE
 
__BLKCNT_T_TYPE
 
	g__blkcnt_t
;

170 
__STD_TYPE
 
__BLKCNT64_T_TYPE
 
	g__blkcnt64_t
;

173 
__STD_TYPE
 
__FSBLKCNT_T_TYPE
 
	g__fsblkcnt_t
;

174 
__STD_TYPE
 
__FSBLKCNT64_T_TYPE
 
	g__fsblkcnt64_t
;

177 
__STD_TYPE
 
__FSFILCNT_T_TYPE
 
	g__fsfilcnt_t
;

178 
__STD_TYPE
 
__FSFILCNT64_T_TYPE
 
	g__fsfilcnt64_t
;

180 
__STD_TYPE
 
__SSIZE_T_TYPE
 
	g__ssize_t
;

184 typedef 
__off64_t
 
	t__loff_t
;

185 typedef 
__quad_t
 *
	t__qaddr_t
;

186 typedef char *
	t__caddr_t
;

189 
__STD_TYPE
 
__SWORD_TYPE
 
	g__intptr_t
;

192 
__STD_TYPE
 
__U32_TYPE
 
	g__socklen_t
;

195 #undef 
__STD_TYPE


	@/usr/include/bits/waitflags.h

20 #if !
defined
 
_SYS_WAIT_H
 && !defined 
_STDLIB_H


26 #define 
	#WNOHANG
 1

	)

27 #define 
	#WUNTRACED
 2

	)

30 #define 
	#WSTOPPED
 2

	)

31 #define 
	#WEXITED
 4

	)

32 #define 
	#WCONTINUED
 8

	)

33 #define 
	#WNOWAIT
 0x01000000

	)

35 #define 
	#__WNOTHREAD
 0x20000000

	)

37 #define 
	#__WALL
 0x40000000

	)

38 #define 
	#__WCLONE
 0x80000000

	)

	@/usr/include/bits/waitstatus.h

20 #if !
defined
 
_SYS_WAIT_H
 && !defined 
_STDLIB_H


29 #define 
	#__WEXITSTATUS
(
status
) (((status) & 0xff00) >> 8)

	)

32 #define 
	#__WTERMSIG
(
status
) ((status) & 0x7f)

	)

35 #define 
	#__WSTOPSIG
(
status
) 
	`__WEXITSTATUS
(status)

	)

38 #define 
	#__WIFEXITED
(
status
) (
	`__WTERMSIG
(status) == 0)

	)

41 #define 
	#__WIFSIGNALED
(
status
) \

42 (((signed char) (((
status
) & 0x7f) + 1) >> 1) > 0)

	)

45 #define 
	#__WIFSTOPPED
(
status
) (((status) & 0xff) == 0x7f)

	)

49 #ifdef 
WCONTINUED


50 #define 
	#__WIFCONTINUED
(
status
) ((status) == 
__W_CONTINUED
)

	)

54 #define 
	#__WCOREDUMP
(
status
) ((status) & 
__WCOREFLAG
)

	)

57 #define 
	#__W_EXITCODE
(
ret
, 
sig
) ((ret) << 8 | (sig))

	)

58 #define 
	#__W_STOPCODE
(
sig
) ((sig) << 8 | 0x7f)

	)

59 #define 
	#__W_CONTINUED
 0xffff

	)

60 #define 
	#__WCOREFLAG
 0x80

	)

63 #ifdef 
__USE_BSD


65 #include 
	~<endian.h
>

67 union 
	uwait


69 int 
	mw_status
;

72 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


73 unsigned int 
	m__w_termsig
:7;

74 unsigned int 
	m__w_coredump
:1;

75 unsigned int 
	m__w_retcode
:8;

78 #if 
__BYTE_ORDER
 == 
__BIG_ENDIAN


80 unsigned int 
	m__w_retcode
:8;

81 unsigned int 
	m__w_coredump
:1;

82 unsigned int 
	m__w_termsig
:7;

84 } 
	m__wait_terminated
;

87 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


88 unsigned int 
	m__w_stopval
:8;

89 unsigned int 
	m__w_stopsig
:8;

92 #if 
__BYTE_ORDER
 == 
__BIG_ENDIAN


94 unsigned int 
	m__w_stopsig
:8;

95 unsigned int 
	m__w_stopval
:8;

97 } 
	m__wait_stopped
;

100 #define 
	#w_termsig
 
__wait_terminated
.
__w_termsig


	)

101 #define 
	#w_coredump
 
__wait_terminated
.
__w_coredump


	)

102 #define 
	#w_retcode
 
__wait_terminated
.
__w_retcode


	)

103 #define 
	#w_stopsig
 
__wait_stopped
.
__w_stopsig


	)

104 #define 
	#w_stopval
 
__wait_stopped
.
__w_stopval


	)

	@/usr/include/features.h

19 #ifndef 
_FEATURES_H


20 #define 
	#_FEATURES_H
 1

	)

96 #undef 
__USE_ISOC99


97 #undef 
__USE_ISOC95


98 #undef 
__USE_POSIX


99 #undef 
__USE_POSIX2


100 #undef 
__USE_POSIX199309


101 #undef 
__USE_POSIX199506


102 #undef 
__USE_XOPEN


103 #undef 
__USE_XOPEN_EXTENDED


104 #undef 
__USE_UNIX98


105 #undef 
__USE_XOPEN2K


106 #undef 
__USE_XOPEN2KXSI


107 #undef 
__USE_XOPEN2K8


108 #undef 
__USE_XOPEN2K8XSI


109 #undef 
__USE_LARGEFILE


110 #undef 
__USE_LARGEFILE64


111 #undef 
__USE_FILE_OFFSET64


112 #undef 
__USE_BSD


113 #undef 
__USE_SVID


114 #undef 
__USE_MISC


115 #undef 
__USE_ATFILE


116 #undef 
__USE_GNU


117 #undef 
__USE_REENTRANT


118 #undef 
__USE_FORTIFY_LEVEL


119 #undef 
__FAVOR_BSD


120 #undef 
__KERNEL_STRICT_NAMES


124 #ifndef 
_LOOSE_KERNEL_NAMES


125 #define 
	#__KERNEL_STRICT_NAMES


	)

129 #define 
	#__USE_ANSI
 1

	)

138 #if 
defined
 
__GNUC__
 && defined 
__GNUC_MINOR__


139 #define 
	#__GNUC_PREREQ
(
maj
, 
min
) \

140 ((
__GNUC__
 << 16) + 
__GNUC_MINOR__
 >= ((
maj
) << 16) + (
min
))

	)

142 #define 
	#__GNUC_PREREQ
(
maj
, 
min
) 0

	)

147 #if 
defined
 
_BSD_SOURCE
 && \

148 !(
defined
 
	g_POSIX_SOURCE
 || defined 
	g_POSIX_C_SOURCE
 || \

149 
defined
 
	g_XOPEN_SOURCE
 || defined 
	g_GNU_SOURCE
 || defined 
	g_SVID_SOURCE
)

150 #define 
	#__FAVOR_BSD
 1

	)

154 #ifdef 
_GNU_SOURCE


155 #undef 
_ISOC95_SOURCE


156 #define 
	#_ISOC95_SOURCE
 1

	)

157 #undef 
_ISOC99_SOURCE


158 #define 
	#_ISOC99_SOURCE
 1

	)

159 #undef 
_POSIX_SOURCE


160 #define 
	#_POSIX_SOURCE
 1

	)

161 #undef 
_POSIX_C_SOURCE


162 #define 
	#_POSIX_C_SOURCE
 200809L

	)

163 #undef 
_XOPEN_SOURCE


164 #define 
	#_XOPEN_SOURCE
 700

	)

165 #undef 
_XOPEN_SOURCE_EXTENDED


166 #define 
	#_XOPEN_SOURCE_EXTENDED
 1

	)

167 #undef 
_LARGEFILE64_SOURCE


168 #define 
	#_LARGEFILE64_SOURCE
 1

	)

169 #undef 
_BSD_SOURCE


170 #define 
	#_BSD_SOURCE
 1

	)

171 #undef 
_SVID_SOURCE


172 #define 
	#_SVID_SOURCE
 1

	)

173 #undef 
_ATFILE_SOURCE


174 #define 
	#_ATFILE_SOURCE
 1

	)

179 #if (!
defined
 
__STRICT_ANSI__
 && !defined 
_ISOC99_SOURCE
 && \

180 !
defined
 
	g_POSIX_SOURCE
 && !defined 
	g_POSIX_C_SOURCE
 && \

181 !
defined
 
	g_XOPEN_SOURCE
 && !defined 
	g_BSD_SOURCE
 && !defined 
	g_SVID_SOURCE
)

182 #define 
	#_BSD_SOURCE
 1

	)

183 #define 
	#_SVID_SOURCE
 1

	)

190 #if (
defined
 
_ISOC99_SOURCE
 || defined 
_ISOC9X_SOURCE
 \

191 || (
defined
 
	g__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L))

192 #define 
	#__USE_ISOC99
 1

	)

196 #if (
defined
 
_ISOC99_SOURCE
 || defined 
_ISOC9X_SOURCE
 \

197 || (
defined
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199409L))

198 #define 
	#__USE_ISOC95
 1

	)

203 #if ((!
defined
 
__STRICT_ANSI__
 || (
_XOPEN_SOURCE
 - 0) >= 500) && \

204 !
defined
 
_POSIX_SOURCE
 && !defined 
_POSIX_C_SOURCE
)

205 #define 
	#_POSIX_SOURCE
 1

	)

206 #if 
defined
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 500

207 #define 
	#_POSIX_C_SOURCE
 2

	)

208 #elif 
defined
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 600

209 #define 
	#_POSIX_C_SOURCE
 199506L

	)

210 #elif 
defined
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 700

211 #define 
	#_POSIX_C_SOURCE
 200112L

	)

213 #define 
	#_POSIX_C_SOURCE
 200809L

	)

215 #define 
	#__USE_POSIX_IMPLICITLY
 1

	)

218 #if 
defined
 
_POSIX_SOURCE
 || 
_POSIX_C_SOURCE
 >= 1 || defined 
_XOPEN_SOURCE


219 #define 
	#__USE_POSIX
 1

	)

222 #if 
defined
 
_POSIX_C_SOURCE
 && _POSIX_C_SOURCE >= 2 || defined 
_XOPEN_SOURCE


223 #define 
	#__USE_POSIX2
 1

	)

226 #if (
_POSIX_C_SOURCE
 - 0) >= 199309L

227 #define 
	#__USE_POSIX199309
 1

	)

230 #if (
_POSIX_C_SOURCE
 - 0) >= 199506L

231 #define 
	#__USE_POSIX199506
 1

	)

234 #if (
_POSIX_C_SOURCE
 - 0) >= 200112L

235 #define 
	#__USE_XOPEN2K
 1

	)

236 #undef 
__USE_ISOC95


237 #define 
	#__USE_ISOC95
 1

	)

238 #undef 
__USE_ISOC99


239 #define 
	#__USE_ISOC99
 1

	)

242 #if (
_POSIX_C_SOURCE
 - 0) >= 200809L

243 #define 
	#__USE_XOPEN2K8
 1

	)

244 #undef 
_ATFILE_SOURCE


245 #define 
	#_ATFILE_SOURCE
 1

	)

248 #ifdef 
_XOPEN_SOURCE


249 #define 
	#__USE_XOPEN
 1

	)

250 #if (
_XOPEN_SOURCE
 - 0) >= 500

251 #define 
	#__USE_XOPEN_EXTENDED
 1

	)

252 #define 
	#__USE_UNIX98
 1

	)

253 #undef 
_LARGEFILE_SOURCE


254 #define 
	#_LARGEFILE_SOURCE
 1

	)

255 #if (
_XOPEN_SOURCE
 - 0) >= 600

256 #if (
_XOPEN_SOURCE
 - 0) >= 700

257 #define 
	#__USE_XOPEN2K8
 1

	)

258 #define 
	#__USE_XOPEN2K8XSI
 1

	)

260 #define 
	#__USE_XOPEN2K
 1

	)

261 #define 
	#__USE_XOPEN2KXSI
 1

	)

262 #undef 
__USE_ISOC95


263 #define 
	#__USE_ISOC95
 1

	)

264 #undef 
__USE_ISOC99


265 #define 
	#__USE_ISOC99
 1

	)

268 #ifdef 
_XOPEN_SOURCE_EXTENDED


269 #define 
	#__USE_XOPEN_EXTENDED
 1

	)

274 #ifdef 
_LARGEFILE_SOURCE


275 #define 
	#__USE_LARGEFILE
 1

	)

278 #ifdef 
_LARGEFILE64_SOURCE


279 #define 
	#__USE_LARGEFILE64
 1

	)

282 #if 
defined
 
_FILE_OFFSET_BITS
 && _FILE_OFFSET_BITS == 64

283 #define 
	#__USE_FILE_OFFSET64
 1

	)

286 #if 
defined
 
_BSD_SOURCE
 || defined 
_SVID_SOURCE


287 #define 
	#__USE_MISC
 1

	)

290 #ifdef 
_BSD_SOURCE


291 #define 
	#__USE_BSD
 1

	)

294 #ifdef 
_SVID_SOURCE


295 #define 
	#__USE_SVID
 1

	)

298 #ifdef 
_ATFILE_SOURCE


299 #define 
	#__USE_ATFILE
 1

	)

302 #ifdef 
_GNU_SOURCE


303 #define 
	#__USE_GNU
 1

	)

306 #if 
defined
 
_REENTRANT
 || defined 
_THREAD_SAFE


307 #define 
	#__USE_REENTRANT
 1

	)

310 #if 
defined
 
_FORTIFY_SOURCE
 && _FORTIFY_SOURCE > 0 \

311 && 
defined
 
__OPTIMIZE__
 && __OPTIMIZE__ > 0

312 #if !
__GNUC_PREREQ
 (4, 1)

313 #ifdef 
__GNUC_RH_RELEASE__


314 #warning 
_FORTIFY_SOURCE
 
supported
 
only
 
with
 
GCC
 4.1 
and
 
later


316 #define 
	#__USE_FORTIFY_LEVEL
 0

	)

317 #elif 
_FORTIFY_SOURCE
 > 1

318 #define 
	#__USE_FORTIFY_LEVEL
 2

	)

320 #define 
	#__USE_FORTIFY_LEVEL
 1

	)

323 #define 
	#__USE_FORTIFY_LEVEL
 0

	)

327 #define 
	#__STDC_IEC_559__
 1

	)

328 #define 
	#__STDC_IEC_559_COMPLEX__
 1

	)

331 #define 
	#__STDC_ISO_10646__
 200009L

	)

339 #undef 
__GNU_LIBRARY__


340 #define 
	#__GNU_LIBRARY__
 6

	)

344 #define 
	#__GLIBC__
 2

	)

345 #define 
	#__GLIBC_MINOR__
 12

	)

347 #define 
	#__GLIBC_PREREQ
(
maj
, 
min
) \

348 ((
__GLIBC__
 << 16) + 
__GLIBC_MINOR__
 >= ((
maj
) << 16) + (
min
))

	)

351 #if 
defined
 
__GNUC__
 \

352 || (
defined
 
	g__PGI
 && defined 
	g__i386__
 ) \

353 || (
defined
 
	g__INTEL_COMPILER
 && (defined 
	g__i386__
 || defined 
	g__ia64__
)) \

354 || (
defined
 
	g__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L)

355 #define 
	#__GLIBC_HAVE_LONG_LONG
 1

	)

359 #ifndef 
__ASSEMBLER__


360 #ifndef 
_SYS_CDEFS_H


361 #include 
	~<sys/cdefs.h
>

366 #if 
defined
 
__USE_FILE_OFFSET64
 && !defined 
__REDIRECT


367 #define 
	#__USE_LARGEFILE
 1

	)

368 #define 
	#__USE_LARGEFILE64
 1

	)

374 #if 
__GNUC_PREREQ
 (2, 7) && 
defined
 
__OPTIMIZE__
 \

375 && !
defined
 
	g__OPTIMIZE_SIZE__
 && !defined 
	g__NO_INLINE__
 \

376 && 
defined
 
	g__extern_inline


377 #define 
	#__USE_EXTERN_INLINES
 1

	)

385 #include 
	~<gnu/stubs.h
>

	@/usr/include/getopt.h

21 #ifndef 
_GETOPT_H


23 #ifndef 
__need_getopt


24 #define 
	#_GETOPT_H
 1

	)

34 #if !
defined
 
__GNU_LIBRARY__


35 #include 
	~<ctype.h
>

38 #ifndef 
__THROW


39 #ifndef 
__GNUC_PREREQ


40 #define 
	#__GNUC_PREREQ
(
maj
, 
min
) (0)

	)

42 #if 
defined
 
__cplusplus
 && 
__GNUC_PREREQ
 (2,8)

43 #define 
	#__THROW
 
	`throw
 ()

	)

45 #define 
	#__THROW


	)

49 #ifdef 
__cplusplus


59 extern char *
optarg
;

73 extern int 
optind
;

78 extern int 
opterr
;

82 extern int 
optopt
;

84 #ifndef 
__need_getopt


106 struct 
	soption


108 const char *
	gname
;

111 int 
	ghas_arg
;

112 int *
	gflag
;

113 int 
	gval
;

118 #define 
	#no_argument
 0

	)

119 #define 
	#required_argument
 1

	)

120 #define 
	#optional_argument
 2

	)

148 #ifdef 
__GNU_LIBRARY__


152 extern int 
getopt
 (int 
___argc
, char *const *
___argv
, const char *
__shortopts
)

153 
__THROW
;

155 #if 
defined
 
__need_getopt
 && defined 
__USE_POSIX2
 \

156 && !
defined
 
	g__USE_POSIX_IMPLICITLY
 && !defined 
	g__USE_GNU


160 #ifdef 
__REDIRECT


161 extern int 
__REDIRECT
 (
getopt
, (int 
___argc
, char *const *
___argv
,

162 const char *
__shortopts
),

163 
__posix_getopt
) 
__THROW
;

165 extern int 
__posix_getopt
 (int 
___argc
, char *const *
___argv
,

166 const char *
__shortopts
) 
__THROW
;

167 #define 
	#getopt
 
__posix_getopt


	)

171 extern int 
getopt
 ();

174 #ifndef 
__need_getopt


175 extern int 
getopt_long
 (int 
___argc
, char *const *
___argv
,

176 const char *
__shortopts
,

177 const struct 
option
 *
__longopts
, int *
__longind
)

178 
__THROW
;

179 extern int 
getopt_long_only
 (int 
___argc
, char *const *
___argv
,

180 const char *
__shortopts
,

181 const struct 
option
 *
__longopts
, int *
__longind
)

182 
__THROW
;

186 #ifdef 
__cplusplus


191 #undef 
__need_getopt


	@/usr/include/libio.h

29 #ifndef 
_IO_STDIO_H


30 #define 
	#_IO_STDIO_H


	)

32 #include 
	~<_G_config.h
>

34 #define 
	#_IO_pos_t
 
_G_fpos_t


	)

35 #define 
	#_IO_fpos_t
 
_G_fpos_t


	)

36 #define 
	#_IO_fpos64_t
 
_G_fpos64_t


	)

37 #define 
	#_IO_size_t
 
_G_size_t


	)

38 #define 
	#_IO_ssize_t
 
_G_ssize_t


	)

39 #define 
	#_IO_off_t
 
_G_off_t


	)

40 #define 
	#_IO_off64_t
 
_G_off64_t


	)

41 #define 
	#_IO_pid_t
 
_G_pid_t


	)

42 #define 
	#_IO_uid_t
 
_G_uid_t


	)

43 #define 
	#_IO_iconv_t
 
_G_iconv_t


	)

44 #define 
	#_IO_HAVE_SYS_WAIT
 
_G_HAVE_SYS_WAIT


	)

45 #define 
	#_IO_HAVE_ST_BLKSIZE
 
_G_HAVE_ST_BLKSIZE


	)

46 #define 
	#_IO_BUFSIZ
 
_G_BUFSIZ


	)

47 #define 
	#_IO_va_list
 
_G_va_list


	)

48 #define 
	#_IO_wint_t
 
_G_wint_t


	)

50 #ifdef 
_G_NEED_STDARG_H


52 #define 
	#__need___va_list


	)

53 #include 
	~<stdarg.h
>

54 #ifdef 
__GNUC_VA_LIST


55 #undef 
_IO_va_list


56 #define 
	#_IO_va_list
 
__gnuc_va_list


	)

60 #ifndef 
__P


61 #if 
_G_HAVE_SYS_CDEFS


62 #include 
	~<sys/cdefs.h
>

64 #ifdef 
__STDC__


65 #define 
	#__P
(
p
) 
	)
p

66 #define 
	#__PMT
(
p
) 
	)
p

68 #define 
	#__P
(
p
) ()

	)

69 #define 
	#__PMT
(
p
) ()

	)

75 #ifndef 
_PARAMS


76 #define 
	#_PARAMS
(
protos
) 
	`__P
(protos)

	)

79 #ifndef 
__STDC__


81 #define const

	)

84 #define 
	#_IO_UNIFIED_JUMPTABLES
 1

	)

85 #ifndef 
_G_HAVE_PRINTF_FP


86 #define 
	#_IO_USE_DTOA
 1

	)

89 #ifndef 
EOF


90 #define 
	#EOF
 (-1)

	)

92 #ifndef 
NULL


93 #if 
defined
 
__GNUG__
 && \

94 (
	g__GNUC__
 > 2 || (__GNUC__ == 2 && 
__GNUC_MINOR__
 >= 8))

95 #define 
	#NULL
 (
__null
)

	)

97 #if !
defined
(
__cplusplus
)

98 #define 
	#NULL
 ((void*)0)

	)

100 #define 
	#NULL
 (0)

	)

105 #define 
	#_IOS_INPUT
 1

	)

106 #define 
	#_IOS_OUTPUT
 2

	)

107 #define 
	#_IOS_ATEND
 4

	)

108 #define 
	#_IOS_APPEND
 8

	)

109 #define 
	#_IOS_TRUNC
 16

	)

110 #define 
	#_IOS_NOCREATE
 32

	)

111 #define 
	#_IOS_NOREPLACE
 64

	)

112 #define 
	#_IOS_BIN
 128

	)

120 #define 
	#_IO_MAGIC
 0xFBAD0000

	)

121 #define 
	#_OLD_STDIO_MAGIC
 0xFABC0000

	)

122 #define 
	#_IO_MAGIC_MASK
 0xFFFF0000

	)

123 #define 
	#_IO_USER_BUF
 1

	)

124 #define 
	#_IO_UNBUFFERED
 2

	)

125 #define 
	#_IO_NO_READS
 4

	)

126 #define 
	#_IO_NO_WRITES
 8

	)

127 #define 
	#_IO_EOF_SEEN
 0x10

	)

128 #define 
	#_IO_ERR_SEEN
 0x20

	)

129 #define 
	#_IO_DELETE_DONT_CLOSE
 0x40

	)

130 #define 
	#_IO_LINKED
 0x80

	)

131 #define 
	#_IO_IN_BACKUP
 0x100

	)

132 #define 
	#_IO_LINE_BUF
 0x200

	)

133 #define 
	#_IO_TIED_PUT_GET
 0x400

	)

134 #define 
	#_IO_CURRENTLY_PUTTING
 0x800

	)

135 #define 
	#_IO_IS_APPENDING
 0x1000

	)

136 #define 
	#_IO_IS_FILEBUF
 0x2000

	)

137 #define 
	#_IO_BAD_SEEN
 0x4000

	)

138 #define 
	#_IO_USER_LOCK
 0x8000

	)

140 #define 
	#_IO_FLAGS2_MMAP
 1

	)

141 #define 
	#_IO_FLAGS2_NOTCANCEL
 2

	)

142 #ifdef 
_LIBC


143 #define 
	#_IO_FLAGS2_FORTIFY
 4

	)

145 #define 
	#_IO_FLAGS2_USER_WBUF
 8

	)

146 #ifdef 
_LIBC


147 #define 
	#_IO_FLAGS2_SCANF_STD
 16

	)

151 #define 
	#_IO_SKIPWS
 01

	)

152 #define 
	#_IO_LEFT
 02

	)

153 #define 
	#_IO_RIGHT
 04

	)

154 #define 
	#_IO_INTERNAL
 010

	)

155 #define 
	#_IO_DEC
 020

	)

156 #define 
	#_IO_OCT
 040

	)

157 #define 
	#_IO_HEX
 0100

	)

158 #define 
	#_IO_SHOWBASE
 0200

	)

159 #define 
	#_IO_SHOWPOINT
 0400

	)

160 #define 
	#_IO_UPPERCASE
 01000

	)

161 #define 
	#_IO_SHOWPOS
 02000

	)

162 #define 
	#_IO_SCIENTIFIC
 04000

	)

163 #define 
	#_IO_FIXED
 010000

	)

164 #define 
	#_IO_UNITBUF
 020000

	)

165 #define 
	#_IO_STDIO
 040000

	)

166 #define 
	#_IO_DONT_CLOSE
 0100000

	)

167 #define 
	#_IO_BOOLALPHA
 0200000

	)

170 struct 
_IO_jump_t
; struct 
	g_IO_FILE
;

173 #ifdef 
_IO_MTSAFE_IO


174 #if 
defined
 
__GLIBC__
 && __GLIBC__ >= 2

175 #include 
	~<bits/stdio-lock.h
>

180 typedef void 
	t_IO_lock_t
;

186 struct 
	s_IO_marker
 {

187 struct 
_IO_marker
 *
	m_next
;

188 struct 
_IO_FILE
 *
	m_sbuf
;

192 int 
	m_pos
;

194 void 
set_streampos
(
streampos
 
sp
) { 
	m_spos
 = sp; }

195 void 
set_offset
(int 
offset
) { 
	m_pos
 = offset; 
	m_spos
 = (
streampos
)(-2); }

196 
	mpublic
:

197 
streammarker
(
streambuf
 *
sb
);

198 ~
streammarker
();

199 int 
saving
() { return 
	m_spos
 == -2; }

200 int 
delta
(
streammarker
&);

201 int 
delta
();

206 enum 
	e__codecvt_result


208 
	m__codecvt_ok
,

209 
	m__codecvt_partial
,

210 
	m__codecvt_error
,

211 
	m__codecvt_noconv


214 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


217 struct 
	s_IO_codecvt


219 void (*
	m__codecvt_destr
) (struct 
	m_IO_codecvt
 *);

220 enum 
__codecvt_result
 (*
__codecvt_do_out
) (struct 
	m_IO_codecvt
 *,

221 
	m__mbstate_t
 *,

222 const 
	mwchar_t
 *,

223 const 
	mwchar_t
 *,

224 const 
	mwchar_t
 **, char *,

226 enum 
__codecvt_result
 (*
__codecvt_do_unshift
) (struct 
	m_IO_codecvt
 *,

227 
	m__mbstate_t
 *, char *,

229 enum 
__codecvt_result
 (*
__codecvt_do_in
) (struct 
	m_IO_codecvt
 *,

230 
	m__mbstate_t
 *,

232 const char **, 
	mwchar_t
 *,

233 
	mwchar_t
 *, wchar_t **);

234 int (*
	m__codecvt_do_encoding
) (struct 
	m_IO_codecvt
 *);

235 int (*
	m__codecvt_do_always_noconv
) (struct 
	m_IO_codecvt
 *);

236 int (*
	m__codecvt_do_length
) (struct 
	m_IO_codecvt
 *, 
	m__mbstate_t
 *,

237 const char *, const char *, 
	m_IO_size_t
);

238 int (*
	m__codecvt_do_max_length
) (struct 
	m_IO_codecvt
 *);

240 
_IO_iconv_t
 
	m__cd_in
;

241 
_IO_iconv_t
 
	m__cd_out
;

245 struct 
	s_IO_wide_data


247 
wchar_t
 *
	m_IO_read_ptr
;

248 
wchar_t
 *
	m_IO_read_end
;

249 
wchar_t
 *
	m_IO_read_base
;

250 
wchar_t
 *
	m_IO_write_base
;

251 
wchar_t
 *
	m_IO_write_ptr
;

252 
wchar_t
 *
	m_IO_write_end
;

253 
wchar_t
 *
	m_IO_buf_base
;

254 
wchar_t
 *
	m_IO_buf_end
;

256 
wchar_t
 *
	m_IO_save_base
;

257 
wchar_t
 *
	m_IO_backup_base
;

259 
wchar_t
 *
	m_IO_save_end
;

261 
__mbstate_t
 
	m_IO_state
;

262 
__mbstate_t
 
	m_IO_last_state
;

263 struct 
_IO_codecvt
 
	m_codecvt
;

265 
wchar_t
 
	m_shortbuf
[1];

267 const struct 
_IO_jump_t
 *
	m_wide_vtable
;

271 struct 
	s_IO_FILE
 {

272 int 
	m_flags
;

273 #define 
	#_IO_file_flags
 
_flags


	)

277 char* 
	m_IO_read_ptr
;

278 char* 
	m_IO_read_end
;

279 char* 
	m_IO_read_base
;

280 char* 
	m_IO_write_base
;

281 char* 
	m_IO_write_ptr
;

282 char* 
	m_IO_write_end
;

283 char* 
	m_IO_buf_base
;

284 char* 
	m_IO_buf_end
;

286 char *
	m_IO_save_base
;

287 char *
	m_IO_backup_base
;

288 char *
	m_IO_save_end
;

290 struct 
_IO_marker
 *
	m_markers
;

292 struct 
_IO_FILE
 *
	m_chain
;

294 int 
	m_fileno
;

296 int 
	m_blksize
;

298 int 
	m_flags2
;

300 
_IO_off_t
 
	m_old_offset
;

302 #define 
	#__HAVE_COLUMN


	)

304 unsigned short 
	m_cur_column
;

305 signed char 
	m_vtable_offset
;

306 char 
	m_shortbuf
[1];

310 
_IO_lock_t
 *
	m_lock
;

311 #ifdef 
_IO_USE_OLD_IO_FILE


314 struct 
	s_IO_FILE_complete


316 struct 
_IO_FILE
 
	m_file
;

318 #if 
defined
 
_G_IO_IO_FILE_VERSION
 && _G_IO_IO_FILE_VERSION == 0x20001

319 
_IO_off64_t
 
	m_offset
;

320 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


322 struct 
_IO_codecvt
 *
	m_codecvt
;

323 struct 
_IO_wide_data
 *
	m_wide_data
;

324 struct 
_IO_FILE
 *
	m_freeres_list
;

325 void *
	m_freeres_buf
;

326 
size_t
 
	m_freeres_size
;

328 void *
	m__pad1
;

329 void *
	m__pad2
;

330 void *
	m__pad3
;

331 void *
	m__pad4
;

332 
size_t
 
	m__pad5
;

334 int 
	m_mode
;

336 char 
	m_unused2
[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (
size_t
)];

340 #ifndef 
__cplusplus


341 typedef struct 
_IO_FILE
 
	t_IO_FILE
;

344 struct 
	g_IO_FILE_plus
;

346 extern struct 
_IO_FILE_plus
 
_IO_2_1_stdin_
;

347 extern struct 
_IO_FILE_plus
 
_IO_2_1_stdout_
;

348 extern struct 
_IO_FILE_plus
 
_IO_2_1_stderr_
;

349 #ifndef 
_LIBC


350 #define 
	#_IO_stdin
 ((
_IO_FILE
*)(&
_IO_2_1_stdin_
))

	)

351 #define 
	#_IO_stdout
 ((
_IO_FILE
*)(&
_IO_2_1_stdout_
))

	)

352 #define 
	#_IO_stderr
 ((
_IO_FILE
*)(&
_IO_2_1_stderr_
))

	)

354 extern 
_IO_FILE
 *
_IO_stdin
 
attribute_hidden
;

355 extern 
_IO_FILE
 *
_IO_stdout
 
attribute_hidden
;

356 extern 
_IO_FILE
 *
_IO_stderr
 
attribute_hidden
;

364 typedef 
__ssize_t
 
	t__io_read_fn
 (void *
	t__cookie
, char *
	t__buf
, 
	tsize_t
 
	t__nbytes
);

372 typedef 
__ssize_t
 
	t__io_write_fn
 (void *
	t__cookie
, 
	t__const
 char *
	t__buf
,

373 
	tsize_t
 
	t__n
);

381 typedef int 
	t__io_seek_fn
 (void *
	t__cookie
, 
	t_IO_off64_t
 *
	t__pos
, int 
	t__w
);

384 typedef int 
	t__io_close_fn
 (void *
	t__cookie
);

387 #ifdef 
_GNU_SOURCE


389 typedef 
__io_read_fn
 
	tcookie_read_function_t
;

390 typedef 
__io_write_fn
 
	tcookie_write_function_t
;

391 typedef 
__io_seek_fn
 
	tcookie_seek_function_t
;

392 typedef 
__io_close_fn
 
	tcookie_close_function_t
;

397 
__io_read_fn
 *
	mread
;

398 
__io_write_fn
 *
	mwrite
;

399 
__io_seek_fn
 *
	mseek
;

400 
__io_close_fn
 *
	mclose
;

401 } 
	t_IO_cookie_io_functions_t
;

402 typedef 
_IO_cookie_io_functions_t
 
	tcookie_io_functions_t
;

404 struct 
	g_IO_cookie_file
;

407 extern void 
_IO_cookie_init
 (struct 
_IO_cookie_file
 *
__cfile
, int 
__read_write
,

408 void *
__cookie
, 
_IO_cookie_io_functions_t
 
__fns
);

412 #ifdef 
__cplusplus


416 extern int 
__underflow
 (
_IO_FILE
 *);

417 extern int 
__uflow
 (
_IO_FILE
 *);

418 extern int 
__overflow
 (
_IO_FILE
 *, int);

419 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


420 extern 
_IO_wint_t
 
__wunderflow
 (
_IO_FILE
 *);

421 extern 
_IO_wint_t
 
__wuflow
 (
_IO_FILE
 *);

422 extern 
_IO_wint_t
 
__woverflow
 (
_IO_FILE
 *, _IO_wint_t);

425 #if 
__GNUC__
 >= 3

426 #define 
	#_IO_BE
(
expr
, 
res
) 
	`__builtin_expect
 ((expr), res)

	)

428 #define 
	#_IO_BE
(
expr
, 
res
) (expr)

	)

431 #define 
	#_IO_getc_unlocked
(
_fp
) \

432 (
	`_IO_BE
 ((
_fp
)->
_IO_read_ptr
 >= (_fp)->
_IO_read_end
, 0) \

433 ? 
	`__uflow
 (
_fp
) : *(unsigned char *) (_fp)->
_IO_read_ptr
++)

	)

434 #define 
	#_IO_peekc_unlocked
(
_fp
) \

435 (
	`_IO_BE
 ((
_fp
)->
_IO_read_ptr
 >= (_fp)->
_IO_read_end
, 0) \

436 && 
	`__underflow
 (
_fp
) == 
EOF
 ? EOF \

437 : *(unsigned char *) (
_fp
)->
_IO_read_ptr
)

	)

438 #define 
	#_IO_putc_unlocked
(
_ch
, 
_fp
) \

439 (
	`_IO_BE
 ((
_fp
)->
_IO_write_ptr
 >= (_fp)->
_IO_write_end
, 0) \

440 ? 
	`__overflow
 (
_fp
, (unsigned char) (
_ch
)) \

441 : (unsigned char) (*(
_fp
)->
_IO_write_ptr
++ = (
_ch
)))

	)

443 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


444 #define 
	#_IO_getwc_unlocked
(
_fp
) \

445 (
	`_IO_BE
 ((
_fp
)->
_wide_data
 == 
NULL
 \

446 || ((
_fp
)->
_wide_data
->
_IO_read_ptr
 \

447 >= (
_fp
)->
_wide_data
->
_IO_read_end
), 0) \

448 ? 
	`__wuflow
 (
_fp
) : (
_IO_wint_t
) *(_fp)->
_wide_data
->
_IO_read_ptr
++)

	)

449 #define 
	#_IO_putwc_unlocked
(
_wch
, 
_fp
) \

450 (
	`_IO_BE
 ((
_fp
)->
_wide_data
 == 
NULL
 \

451 || ((
_fp
)->
_wide_data
->
_IO_write_ptr
 \

452 >= (
_fp
)->
_wide_data
->
_IO_write_end
), 0) \

453 ? 
	`__woverflow
 (
_fp
, 
_wch
) \

454 : (
_IO_wint_t
) (*(
_fp
)->
_wide_data
->
_IO_write_ptr
++ = (
_wch
)))

	)

457 #define 
	#_IO_feof_unlocked
(
__fp
) (((__fp)->
_flags
 & 
_IO_EOF_SEEN
) != 0)

	)

458 #define 
	#_IO_ferror_unlocked
(
__fp
) (((__fp)->
_flags
 & 
_IO_ERR_SEEN
) != 0)

	)

460 extern int 
_IO_getc
 (
_IO_FILE
 *
__fp
);

461 extern int 
_IO_putc
 (int 
__c
, 
_IO_FILE
 *
__fp
);

462 extern int 
_IO_feof
 (
_IO_FILE
 *
__fp
) 
__THROW
;

463 extern int 
_IO_ferror
 (
_IO_FILE
 *
__fp
) 
__THROW
;

465 extern int 
_IO_peekc_locked
 (
_IO_FILE
 *
__fp
);

468 #define 
	#_IO_PENDING_OUTPUT_COUNT
(
_fp
) \

469 ((
_fp
)->
_IO_write_ptr
 - (_fp)->
_IO_write_base
)

	)

471 extern void 
_IO_flockfile
 (
_IO_FILE
 *) 
__THROW
;

472 extern void 
_IO_funlockfile
 (
_IO_FILE
 *) 
__THROW
;

473 extern int 
_IO_ftrylockfile
 (
_IO_FILE
 *) 
__THROW
;

475 #ifdef 
_IO_MTSAFE_IO


476 #define 
	#_IO_peekc
(
_fp
) 
	`_IO_peekc_locked
 (_fp)

	)

477 #define 
	#_IO_flockfile
(
_fp
) \

478 if (((
_fp
)->
_flags
 & 
_IO_USER_LOCK
) == 0) 
	`_IO_flockfile
 (_fp)

	)

479 #define 
	#_IO_funlockfile
(
_fp
) \

480 if (((
_fp
)->
_flags
 & 
_IO_USER_LOCK
) == 0) 
	`_IO_funlockfile
 (_fp)

	)

482 #define 
	#_IO_peekc
(
_fp
) 
	`_IO_peekc_unlocked
 (_fp)

	)

483 #define 
	#_IO_flockfile
(
_fp
)

	)

484 #define 
	#_IO_funlockfile
(
_fp
)

	)

485 #define 
	#_IO_ftrylockfile
(
_fp
)

	)

486 #define 
	#_IO_cleanup_region_start
(
_fct
, 
_fp
)

	)

487 #define 
	#_IO_cleanup_region_end
(
_Doit
)

	)

490 extern int 
_IO_vfscanf
 (
_IO_FILE
 * 
__restrict
, const char * __restrict,

491 
_IO_va_list
, int *
__restrict
);

492 extern int 
_IO_vfprintf
 (
_IO_FILE
 *
__restrict
, const char *__restrict,

493 
_IO_va_list
);

494 extern 
_IO_ssize_t
 
_IO_padn
 (
_IO_FILE
 *, int, _IO_ssize_t);

495 extern 
_IO_size_t
 
_IO_sgetn
 (
_IO_FILE
 *, void *, _IO_size_t);

497 extern 
_IO_off64_t
 
_IO_seekoff
 (
_IO_FILE
 *, _IO_off64_t, int, int);

498 extern 
_IO_off64_t
 
_IO_seekpos
 (
_IO_FILE
 *, _IO_off64_t, int);

500 extern void 
_IO_free_backup_area
 (
_IO_FILE
 *) 
__THROW
;

502 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


503 extern 
_IO_wint_t
 
_IO_getwc
 (
_IO_FILE
 *
__fp
);

504 extern 
_IO_wint_t
 
_IO_putwc
 (
wchar_t
 
__wc
, 
_IO_FILE
 *
__fp
);

505 extern int 
_IO_fwide
 (
_IO_FILE
 *
__fp
, int 
__mode
) 
__THROW
;

506 #if 
__GNUC__
 >= 2

509 #if 
defined
 
_LIBC
 && defined 
SHARED


510 #include 
	~<shlib-compat.h
>

511 #if 
SHLIB_COMPAT
 (
libc
, 
GLIBC_2_0
, 
GLIBC_2_1
)

512 #define 
	#_IO_fwide_maybe_incompatible
 \

513 (
	`__builtin_expect
 (&
_IO_stdin_used
 == 
NULL
, 0))

	)

514 extern const int 
_IO_stdin_used
;

515 
weak_extern
 (
_IO_stdin_used
);

518 #ifndef 
_IO_fwide_maybe_incompatible


519 #define 
	#_IO_fwide_maybe_incompatible
 (0)

	)

523 #define 
	#_IO_fwide
(
__fp
, 
__mode
) \

524 ({ int 
__result
 = (
__mode
); \

525 if (
__result
 < 0 && ! 
_IO_fwide_maybe_incompatible
) \

527 if ((
__fp
)->
_mode
 == 0) \

529 (
__fp
)->
_mode
 = -1; \

530 
__result
 = (
__fp
)->
_mode
; \

532 else if (
	`__builtin_constant_p
 (
__mode
) && (__mode) == 0) \

533 
__result
 = 
_IO_fwide_maybe_incompatible
 ? -1 : (
__fp
)->
_mode
; \

535 
__result
 = 
	`_IO_fwide
 (
__fp
, __result); \

536 
__result
; })

	)

539 extern int 
_IO_vfwscanf
 (
_IO_FILE
 * 
__restrict
, const 
wchar_t
 * __restrict,

540 
_IO_va_list
, int *
__restrict
);

541 extern int 
_IO_vfwprintf
 (
_IO_FILE
 *
__restrict
, const 
wchar_t
 *__restrict,

542 
_IO_va_list
);

543 extern 
_IO_ssize_t
 
_IO_wpadn
 (
_IO_FILE
 *, 
wint_t
, _IO_ssize_t);

544 extern void 
_IO_free_wbackup_area
 (
_IO_FILE
 *) 
__THROW
;

547 #ifdef 
__LDBL_COMPAT


548 #include 
	~<bits/libio-ldbl.h
>

551 #ifdef 
__cplusplus


	@/usr/include/sys/types.h

23 #ifndef 
_SYS_TYPES_H


24 #define 
	#_SYS_TYPES_H
 1

	)

26 #include 
	~<features.h
>

28 
	g__BEGIN_DECLS


30 #include 
	~<bits/types.h
>

32 #ifdef 
__USE_BSD


33 #ifndef 
__u_char_defined


34 typedef 
__u_char
 
	tu_char
;

35 typedef 
__u_short
 
	tu_short
;

36 typedef 
__u_int
 
	tu_int
;

37 typedef 
__u_long
 
	tu_long
;

38 typedef 
__quad_t
 
	tquad_t
;

39 typedef 
__u_quad_t
 
	tu_quad_t
;

40 typedef 
__fsid_t
 
	tfsid_t
;

41 #define 
	#__u_char_defined


	)

45 typedef 
__loff_t
 
	tloff_t
;

47 #ifndef 
__ino_t_defined


48 #ifndef 
__USE_FILE_OFFSET64


49 typedef 
__ino_t
 
	tino_t
;

51 typedef 
__ino64_t
 
	tino_t
;

53 #define 
	#__ino_t_defined


	)

55 #if 
defined
 
__USE_LARGEFILE64
 && !defined 
__ino64_t_defined


56 typedef 
__ino64_t
 
	tino64_t
;

57 #define 
	#__ino64_t_defined


	)

60 #ifndef 
__dev_t_defined


61 typedef 
__dev_t
 
	tdev_t
;

62 #define 
	#__dev_t_defined


	)

65 #ifndef 
__gid_t_defined


66 typedef 
__gid_t
 
	tgid_t
;

67 #define 
	#__gid_t_defined


	)

70 #ifndef 
__mode_t_defined


71 typedef 
__mode_t
 
	tmode_t
;

72 #define 
	#__mode_t_defined


	)

75 #ifndef 
__nlink_t_defined


76 typedef 
__nlink_t
 
	tnlink_t
;

77 #define 
	#__nlink_t_defined


	)

80 #ifndef 
__uid_t_defined


81 typedef 
__uid_t
 
	tuid_t
;

82 #define 
	#__uid_t_defined


	)

85 #ifndef 
__off_t_defined


86 #ifndef 
__USE_FILE_OFFSET64


87 typedef 
__off_t
 
	toff_t
;

89 typedef 
__off64_t
 
	toff_t
;

91 #define 
	#__off_t_defined


	)

93 #if 
defined
 
__USE_LARGEFILE64
 && !defined 
__off64_t_defined


94 typedef 
__off64_t
 
	toff64_t
;

95 #define 
	#__off64_t_defined


	)

98 #ifndef 
__pid_t_defined


99 typedef 
__pid_t
 
	tpid_t
;

100 #define 
	#__pid_t_defined


	)

103 #if (
defined
 
__USE_SVID
 || defined 
__USE_XOPEN
 || defined 
__USE_XOPEN2K8
) \

104 && !
defined
 
__id_t_defined


105 typedef 
__id_t
 
	tid_t
;

106 #define 
	#__id_t_defined


	)

109 #ifndef 
__ssize_t_defined


110 typedef 
__ssize_t
 
	tssize_t
;

111 #define 
	#__ssize_t_defined


	)

114 #ifdef 
__USE_BSD


115 #ifndef 
__daddr_t_defined


116 typedef 
__daddr_t
 
	tdaddr_t
;

117 typedef 
__caddr_t
 
	tcaddr_t
;

118 #define 
	#__daddr_t_defined


	)

122 #if (
defined
 
__USE_SVID
 || defined 
__USE_XOPEN
) && !defined 
__key_t_defined


123 typedef 
__key_t
 
	tkey_t
;

124 #define 
	#__key_t_defined


	)

127 #if 
defined
 
__USE_XOPEN
 || defined 
__USE_XOPEN2K8


128 #define 
	#__need_clock_t


	)

130 #define 
	#__need_time_t


	)

131 #define 
	#__need_timer_t


	)

132 #define 
	#__need_clockid_t


	)

133 #include 
	~<time.h
>

135 #ifdef 
__USE_XOPEN


136 #ifndef 
__useconds_t_defined


137 typedef 
__useconds_t
 
	tuseconds_t
;

138 #define 
	#__useconds_t_defined


	)

140 #ifndef 
__suseconds_t_defined


141 typedef 
__suseconds_t
 
	tsuseconds_t
;

142 #define 
	#__suseconds_t_defined


	)

146 #define 
	#__need_size_t


	)

147 #include 
	~<stddef.h
>

149 #ifdef 
__USE_MISC


151 typedef unsigned long int 
	tulong
;

152 typedef unsigned short int 
	tushort
;

153 typedef unsigned int 
	tuint
;

158 #if !
__GNUC_PREREQ
 (2, 7)

161 #ifndef 
__int8_t_defined


162 #define 
	#__int8_t_defined


	)

163 typedef char 
	tint8_t
;

164 typedef short int 
	tint16_t
;

165 typedef int 
	tint32_t
;

166 #if 
__WORDSIZE
 == 64

167 typedef long int 
	tint64_t
;

168 #elif 
__GLIBC_HAVE_LONG_LONG


169 
__extension__
 typedef long long int 
	tint64_t
;

174 typedef unsigned char 
	tu_int8_t
;

175 typedef unsigned short int 
	tu_int16_t
;

176 typedef unsigned int 
	tu_int32_t
;

177 #if 
__WORDSIZE
 == 64

178 typedef unsigned long int 
	tu_int64_t
;

179 #elif 
__GLIBC_HAVE_LONG_LONG


180 
__extension__
 typedef unsigned long long int 
	tu_int64_t
;

183 typedef int 
	tregister_t
;

188 #define 
	#__intN_t
(
N
, 
MODE
) \

189 typedef int int##
	tN
##
	t_t
 
	t__attribute__
 ((
	t__mode__
 (
	tMODE
)))

	)

190 #define 
	t__u_intN_t
(
	tN
, 
	tMODE
) \

191 typedef unsigned int 
	tu_int
##
	tN
##
	t_t
 
	t__attribute__
 ((
	t__mode__
 (
	tMODE
)))

	)

193 #ifndef 
	t__int8_t_defined


194 #define 
	t__int8_t_defined


	)

195 
	t__intN_t
 (8, 
	t__QI__
);

196 
__intN_t
 (16, 
__HI__
);

197 
__intN_t
 (32, 
__SI__
);

198 
__intN_t
 (64, 
__DI__
);

201 
__u_intN_t
 (8, 
__QI__
);

202 
__u_intN_t
 (16, 
__HI__
);

203 
__u_intN_t
 (32, 
__SI__
);

204 
__u_intN_t
 (64, 
__DI__
);

206 typedef int 
	tregister_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__word__
)));

212 #define 
	#__BIT_TYPES_DEFINED__
 1

	)

215 #ifdef 
__USE_BSD


217 #include 
	~<endian.h
>

220 #include 
	~<sys/select.h
>

223 #include 
	~<sys/sysmacros.h
>

227 #if (
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K8
) \

228 && !
defined
 
__blksize_t_defined


229 typedef 
__blksize_t
 
	tblksize_t
;

230 #define 
	#__blksize_t_defined


	)

234 #ifndef 
__USE_FILE_OFFSET64


235 #ifndef 
__blkcnt_t_defined


236 typedef 
__blkcnt_t
 
	tblkcnt_t
;

237 #define 
	#__blkcnt_t_defined


	)

239 #ifndef 
__fsblkcnt_t_defined


240 typedef 
__fsblkcnt_t
 
	tfsblkcnt_t
;

241 #define 
	#__fsblkcnt_t_defined


	)

243 #ifndef 
__fsfilcnt_t_defined


244 typedef 
__fsfilcnt_t
 
	tfsfilcnt_t
;

245 #define 
	#__fsfilcnt_t_defined


	)

248 #ifndef 
__blkcnt_t_defined


249 typedef 
__blkcnt64_t
 
	tblkcnt_t
;

250 #define 
	#__blkcnt_t_defined


	)

252 #ifndef 
__fsblkcnt_t_defined


253 typedef 
__fsblkcnt64_t
 
	tfsblkcnt_t
;

254 #define 
	#__fsblkcnt_t_defined


	)

256 #ifndef 
__fsfilcnt_t_defined


257 typedef 
__fsfilcnt64_t
 
	tfsfilcnt_t
;

258 #define 
	#__fsfilcnt_t_defined


	)

262 #ifdef 
__USE_LARGEFILE64


263 typedef 
__blkcnt64_t
 
	tblkcnt64_t
;

264 typedef 
__fsblkcnt64_t
 
	tfsblkcnt64_t
;

265 typedef 
__fsfilcnt64_t
 
	tfsfilcnt64_t
;

270 #if 
defined
 
__USE_POSIX199506
 || defined 
__USE_UNIX98


271 #include 
	~<bits/pthreadtypes.h
>

274 
	g__END_DECLS


	@/usr/include/xlocale.h

21 #ifndef 
_XLOCALE_H


22 #define 
	#_XLOCALE_H
 1

	)

28 typedef struct 
	s__locale_struct


31 struct 
__locale_data
 *
	m__locales
[13];

34 const unsigned short int *
	m__ctype_b
;

35 const int *
	m__ctype_tolower
;

36 const int *
	m__ctype_toupper
;

39 const char *
	m__names
[13];

40 } *
	t__locale_t
;

43 typedef 
__locale_t
 
	tlocale_t
;

	@/usr/include/_G_config.h

4 #ifndef 
_G_config_h


5 #define 
	#_G_config_h
 1

	)

9 #include 
	~<bits/types.h
>

10 #define 
	#__need_size_t


	)

11 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


12 #define 
	#__need_wchar_t


	)

14 #define 
	#__need_NULL


	)

15 #include 
	~<stddef.h
>

16 #define 
	#__need_mbstate_t


	)

17 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


18 #define 
	#__need_wint_t


	)

20 #include 
	~<wchar.h
>

21 #define 
	#_G_size_t
 
size_t


	)

24 
__off_t
 
	m__pos
;

25 
__mbstate_t
 
	m__state
;

26 } 
	t_G_fpos_t
;

29 
__off64_t
 
	m__pos
;

30 
__mbstate_t
 
	m__state
;

31 } 
	t_G_fpos64_t
;

32 #define 
	#_G_ssize_t
 
__ssize_t


	)

33 #define 
	#_G_off_t
 
__off_t


	)

34 #define 
	#_G_off64_t
 
__off64_t


	)

35 #define 
	#_G_pid_t
 
__pid_t


	)

36 #define 
	#_G_uid_t
 
__uid_t


	)

37 #define 
	#_G_wchar_t
 
wchar_t


	)

38 #define 
	#_G_wint_t
 
wint_t


	)

39 #define 
	#_G_stat64
 
stat64


	)

40 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


41 #include 
	~<gconv.h
>

44 struct 
__gconv_info
 
	m__cd
;

47 struct 
__gconv_info
 
	m__cd
;

48 struct 
__gconv_step_data
 
	m__data
;

49 } 
	m__combined
;

50 } 
	t_G_iconv_t
;

53 typedef int 
	t_G_int16_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__HI__
)));

54 typedef int 
	t_G_int32_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__SI__
)));

55 typedef unsigned int 
	t_G_uint16_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__HI__
)));

56 typedef unsigned int 
	t_G_uint32_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__SI__
)));

58 #define 
	#_G_HAVE_BOOL
 1

	)

62 #define 
	#_G_HAVE_ATEXIT
 1

	)

63 #define 
	#_G_HAVE_SYS_CDEFS
 1

	)

64 #define 
	#_G_HAVE_SYS_WAIT
 1

	)

65 #define 
	#_G_NEED_STDARG_H
 1

	)

66 #define 
	#_G_va_list
 
__gnuc_va_list


	)

68 #define 
	#_G_HAVE_PRINTF_FP
 1

	)

69 #define 
	#_G_HAVE_MMAP
 1

	)

70 #define 
	#_G_HAVE_MREMAP
 1

	)

71 #define 
	#_G_HAVE_LONG_DOUBLE_IO
 1

	)

72 #define 
	#_G_HAVE_IO_FILE_OPEN
 1

	)

73 #define 
	#_G_HAVE_IO_GETLINE_INFO
 1

	)

75 #define 
	#_G_IO_IO_FILE_VERSION
 0x20001

	)

77 #define 
	#_G_OPEN64
 
__open64


	)

78 #define 
	#_G_LSEEK64
 
__lseek64


	)

79 #define 
	#_G_MMAP64
 
__mmap64


	)

80 #define 
	#_G_FSTAT64
(
fd
,
buf
) 
	`__fxstat64
 (
_STAT_VER
, fd, buf)

	)

83 #define 
	#_G_HAVE_ST_BLKSIZE
 
	`defined
 (
_STATBUF_ST_BLKSIZE
)

	)

85 #define 
	#_G_BUFSIZ
 8192

	)

88 #define 
	#_G_NAMES_HAVE_UNDERSCORE
 0

	)

89 #define 
	#_G_VTABLE_LABEL_HAS_LENGTH
 1

	)

90 #define 
	#_G_USING_THUNKS
 1

	)

91 #define 
	#_G_VTABLE_LABEL_PREFIX
 "__vt_"

	)

92 #define 
	#_G_VTABLE_LABEL_PREFIX_ID
 
__vt_


	)

95 #if 
defined
 
__cplusplus
 || defined 
__STDC__


96 #define 
	#_G_ARGS
(
ARGLIST
) 
	)
ARGLIST

98 #define 
	#_G_ARGS
(
ARGLIST
) ()

	)

	@/usr/include/bits/libio-ldbl.h

20 #ifndef 
_IO_STDIO_H


24 
	$__LDBL_REDIR_DECL
 (
_IO_vfscanf
)

25 
	`__LDBL_REDIR_DECL
 (
_IO_vfprintf
)

	@/usr/include/bits/pthreadtypes.h

20 #ifndef 
_BITS_PTHREADTYPES_H


21 #define 
	#_BITS_PTHREADTYPES_H
 1

	)

23 #include 
	~<bits/wordsize.h
>

25 #if 
__WORDSIZE
 == 64

26 #define 
	#__SIZEOF_PTHREAD_ATTR_T
 56

	)

27 #define 
	#__SIZEOF_PTHREAD_MUTEX_T
 40

	)

28 #define 
	#__SIZEOF_PTHREAD_MUTEXATTR_T
 4

	)

29 #define 
	#__SIZEOF_PTHREAD_COND_T
 48

	)

30 #define 
	#__SIZEOF_PTHREAD_CONDATTR_T
 4

	)

31 #define 
	#__SIZEOF_PTHREAD_RWLOCK_T
 56

	)

32 #define 
	#__SIZEOF_PTHREAD_RWLOCKATTR_T
 8

	)

33 #define 
	#__SIZEOF_PTHREAD_BARRIER_T
 32

	)

34 #define 
	#__SIZEOF_PTHREAD_BARRIERATTR_T
 4

	)

36 #define 
	#__SIZEOF_PTHREAD_ATTR_T
 36

	)

37 #define 
	#__SIZEOF_PTHREAD_MUTEX_T
 24

	)

38 #define 
	#__SIZEOF_PTHREAD_MUTEXATTR_T
 4

	)

39 #define 
	#__SIZEOF_PTHREAD_COND_T
 48

	)

40 #define 
	#__SIZEOF_PTHREAD_CONDATTR_T
 4

	)

41 #define 
	#__SIZEOF_PTHREAD_RWLOCK_T
 32

	)

42 #define 
	#__SIZEOF_PTHREAD_RWLOCKATTR_T
 8

	)

43 #define 
	#__SIZEOF_PTHREAD_BARRIER_T
 20

	)

44 #define 
	#__SIZEOF_PTHREAD_BARRIERATTR_T
 4

	)

50 typedef unsigned long int 
	tpthread_t
;

55 char 
	m__size
[
__SIZEOF_PTHREAD_ATTR_T
];

56 long int 
	m__align
;

57 } 
	tpthread_attr_t
;

60 #if 
__WORDSIZE
 == 64

61 typedef struct 
	s__pthread_internal_list


63 struct 
__pthread_internal_list
 *
	m__prev
;

64 struct 
__pthread_internal_list
 *
	m__next
;

65 } 
	t__pthread_list_t
;

67 typedef struct 
	s__pthread_internal_slist


69 struct 
__pthread_internal_slist
 *
	m__next
;

70 } 
	t__pthread_slist_t
;

78 struct 
	s__pthread_mutex_s


80 int 
	m__lock
;

81 unsigned int 
	m__count
;

82 int 
	m__owner
;

83 #if 
__WORDSIZE
 == 64

84 unsigned int 
	m__nusers
;

88 int 
	m__kind
;

89 #if 
__WORDSIZE
 == 64

90 int 
	m__spins
;

91 
__pthread_list_t
 
	m__list
;

92 #define 
	#__PTHREAD_MUTEX_HAVE_PREV
 1

	)

94 unsigned int 
	m__nusers
;

95 
__extension__
 union

97 int 
	m__spins
;

98 
__pthread_slist_t
 
	m__list
;

101 } 
	m__data
;

102 char 
	m__size
[
__SIZEOF_PTHREAD_MUTEX_T
];

103 long int 
	m__align
;

104 } 
	tpthread_mutex_t
;

108 char 
	m__size
[
__SIZEOF_PTHREAD_MUTEXATTR_T
];

109 int 
	m__align
;

110 } 
	tpthread_mutexattr_t
;

119 int 
	m__lock
;

120 unsigned int 
	m__futex
;

121 
__extension__
 unsigned long long int 
	m__total_seq
;

122 
__extension__
 unsigned long long int 
	m__wakeup_seq
;

123 
__extension__
 unsigned long long int 
	m__woken_seq
;

124 void *
	m__mutex
;

125 unsigned int 
	m__nwaiters
;

126 unsigned int 
	m__broadcast_seq
;

127 } 
	m__data
;

128 char 
	m__size
[
__SIZEOF_PTHREAD_COND_T
];

129 
__extension__
 long long int 
	m__align
;

130 } 
	tpthread_cond_t
;

134 char 
	m__size
[
__SIZEOF_PTHREAD_CONDATTR_T
];

135 int 
	m__align
;

136 } 
	tpthread_condattr_t
;

140 typedef unsigned int 
	tpthread_key_t
;

144 typedef int 
	tpthread_once_t
;

147 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K


152 #if 
__WORDSIZE
 == 64

155 int 
	m__lock
;

156 unsigned int 
	m__nr_readers
;

157 unsigned int 
	m__readers_wakeup
;

158 unsigned int 
	m__writer_wakeup
;

159 unsigned int 
	m__nr_readers_queued
;

160 unsigned int 
	m__nr_writers_queued
;

161 int 
	m__writer
;

162 int 
	m__shared
;

163 unsigned long int 
	m__pad1
;

164 unsigned long int 
	m__pad2
;

167 unsigned int 
	m__flags
;

168 } 
	m__data
;

172 int 
	m__lock
;

173 unsigned int 
	m__nr_readers
;

174 unsigned int 
	m__readers_wakeup
;

175 unsigned int 
	m__writer_wakeup
;

176 unsigned int 
	m__nr_readers_queued
;

177 unsigned int 
	m__nr_writers_queued
;

180 unsigned char 
	m__flags
;

181 unsigned char 
	m__shared
;

182 unsigned char 
	m__pad1
;

183 unsigned char 
	m__pad2
;

184 int 
	m__writer
;

185 } 
	m__data
;

187 char 
	m__size
[
__SIZEOF_PTHREAD_RWLOCK_T
];

188 long int 
	m__align
;

189 } 
	tpthread_rwlock_t
;

193 char 
	m__size
[
__SIZEOF_PTHREAD_RWLOCKATTR_T
];

194 long int 
	m__align
;

195 } 
	tpthread_rwlockattr_t
;

199 #ifdef 
__USE_XOPEN2K


201 typedef volatile int 
	tpthread_spinlock_t
;

208 char 
	m__size
[
__SIZEOF_PTHREAD_BARRIER_T
];

209 long int 
	m__align
;

210 } 
	tpthread_barrier_t
;

214 char 
	m__size
[
__SIZEOF_PTHREAD_BARRIERATTR_T
];

215 int 
	m__align
;

216 } 
	tpthread_barrierattr_t
;

220 #if 
__WORDSIZE
 == 32

222 #define 
	#__cleanup_fct_attribute
 
	`__attribute__
 ((
	`__regparm__
 (1)))

	)

	@/usr/include/bits/stdio-lock.h

20 #ifndef 
_BITS_STDIO_LOCK_H


21 #define 
	#_BITS_STDIO_LOCK_H
 1

	)

23 #include 
	~<bits/libc-lock.h
>

25 
	$__libc_lock_define_recursive
 (typedef, 
_IO_lock_t
)

28 #ifdef 
	t_LIBC_LOCK_RECURSIVE_INITIALIZER


29 #define 
	t_IO_lock_initializer
 
	t_LIBC_LOCK_RECURSIVE_INITIALIZER


	)

30 #elif 
	t_IO_MTSAFE_IO


31 #error 
	tlibio
 
	tneeds
 
	trecursive
 
	tmutexes
 for 
	t_IO_MTSAFE_IO


34 #define 
	t_IO_lock_init
(
	t_name
) 
	t__libc_lock_init_recursive
 (_name)

	)

35 #define 
	t_IO_lock_fini
(
	t_name
) 
	t__libc_lock_fini_recursive
 (_name)

	)

36 #define 
	t_IO_lock_lock
(
	t_name
) 
	t__libc_lock_lock_recursive
 (_name)

	)

37 #define 
	t_IO_lock_trylock
(
	t_name
) 
	t__libc_lock_trylock_recursive
 (_name)

	)

38 #define 
	t_IO_lock_unlock
(
	t_name
) 
	t__libc_lock_unlock_recursive
 (_name)

	)

41 #define 
	t_IO_cleanup_region_start
(
	t_fct
, 
	t_fp
) \

42 
	t__libc_cleanup_region_start
 (((
	t_fp
)->
	t_flags
 & 
	t_IO_USER_LOCK
) == 0, 
	t_fct
, _fp)

	)

43 #define 
	t_IO_cleanup_region_start_noarg
(
	t_fct
) \

44 
	t__libc_cleanup_region_start
 (1, 
	t_fct
, 
	tNULL
)

	)

45 #define 
	t_IO_cleanup_region_end
(
	t_doit
) \

46 
	t__libc_cleanup_region_end
 (
	t_doit
)

	)

48 #if 
	tdefined
 
	t_LIBC
 && !defined 
	tNOT_IN_libc


49 #define 
	t_IO_acquire_lock
(
	t_fp
) \

50 
	t_IO_cleanup_region_start
 ((void (*) (void *)) 
	t_IO_funlockfile
, (
	t_fp
)); \

51 
	`_IO_flockfile
 (
_fp
)

	)

53 #define 
	#_IO_release_lock
(
_fp
) \

54 
	`_IO_funlockfile
 (
_fp
); \

55 
	`_IO_cleanup_region_end
 (0)

	)

	@/usr/include/bits/typesizes.h

20 #ifndef 
_BITS_TYPES_H


24 #ifndef 
_BITS_TYPESIZES_H


25 #define 
	#_BITS_TYPESIZES_H
 1

	)

30 #define 
	#__DEV_T_TYPE
 
__UQUAD_TYPE


	)

31 #define 
	#__UID_T_TYPE
 
__U32_TYPE


	)

32 #define 
	#__GID_T_TYPE
 
__U32_TYPE


	)

33 #define 
	#__INO_T_TYPE
 
__ULONGWORD_TYPE


	)

34 #define 
	#__INO64_T_TYPE
 
__UQUAD_TYPE


	)

35 #define 
	#__MODE_T_TYPE
 
__U32_TYPE


	)

36 #define 
	#__NLINK_T_TYPE
 
__UWORD_TYPE


	)

37 #define 
	#__OFF_T_TYPE
 
__SLONGWORD_TYPE


	)

38 #define 
	#__OFF64_T_TYPE
 
__SQUAD_TYPE


	)

39 #define 
	#__PID_T_TYPE
 
__S32_TYPE


	)

40 #define 
	#__RLIM_T_TYPE
 
__ULONGWORD_TYPE


	)

41 #define 
	#__RLIM64_T_TYPE
 
__UQUAD_TYPE


	)

42 #define 
	#__BLKCNT_T_TYPE
 
__SLONGWORD_TYPE


	)

43 #define 
	#__BLKCNT64_T_TYPE
 
__SQUAD_TYPE


	)

44 #define 
	#__FSBLKCNT_T_TYPE
 
__ULONGWORD_TYPE


	)

45 #define 
	#__FSBLKCNT64_T_TYPE
 
__UQUAD_TYPE


	)

46 #define 
	#__FSFILCNT_T_TYPE
 
__ULONGWORD_TYPE


	)

47 #define 
	#__FSFILCNT64_T_TYPE
 
__UQUAD_TYPE


	)

48 #define 
	#__ID_T_TYPE
 
__U32_TYPE


	)

49 #define 
	#__CLOCK_T_TYPE
 
__SLONGWORD_TYPE


	)

50 #define 
	#__TIME_T_TYPE
 
__SLONGWORD_TYPE


	)

51 #define 
	#__USECONDS_T_TYPE
 
__U32_TYPE


	)

52 #define 
	#__SUSECONDS_T_TYPE
 
__SLONGWORD_TYPE


	)

53 #define 
	#__DADDR_T_TYPE
 
__S32_TYPE


	)

54 #define 
	#__SWBLK_T_TYPE
 
__SLONGWORD_TYPE


	)

55 #define 
	#__KEY_T_TYPE
 
__S32_TYPE


	)

56 #define 
	#__CLOCKID_T_TYPE
 
__S32_TYPE


	)

57 #define 
	#__TIMER_T_TYPE
 void *

	)

58 #define 
	#__BLKSIZE_T_TYPE
 
__SLONGWORD_TYPE


	)

59 #define 
	#__FSID_T_TYPE
 struct { int 
__val
[2]; }

	)

60 #define 
	#__SSIZE_T_TYPE
 
__SWORD_TYPE


	)

63 #define 
	#__FD_SETSIZE
 1024

	)

	@/usr/include/bits/wordsize.h

3 #if 
defined
 
__x86_64__


4 #define 
	#__WORDSIZE
 64

	)

5 #define 
	#__WORDSIZE_COMPAT32
 1

	)

7 #define 
	#__WORDSIZE
 32

	)

	@/usr/include/ctype.h

24 #ifndef 
_CTYPE_H


25 #define 
	#_CTYPE_H
 1

	)

27 #include 
	~<features.h
>

28 #include 
	~<bits/types.h
>

30 
	g__BEGIN_DECLS


32 #ifndef 
_ISbit


41 #include 
	~<endian.h
>

42 #if 
__BYTE_ORDER
 == 
__BIG_ENDIAN


43 #define 
	#_ISbit
(
bit
) (1 << (bit))

	)

45 #define 
	#_ISbit
(
bit
) ((bit) < 8 ? ((1 << (bit)) << 8) : ((1 << (bit)) >> 8))

	)

50 
	m_ISupper
 = 
_ISbit
 (0),

51 
	m_ISlower
 = 
_ISbit
 (1),

52 
	m_ISalpha
 = 
_ISbit
 (2),

53 
	m_ISdigit
 = 
_ISbit
 (3),

54 
	m_ISxdigit
 = 
_ISbit
 (4),

55 
	m_ISspace
 = 
_ISbit
 (5),

56 
	m_ISprint
 = 
_ISbit
 (6),

57 
	m_ISgraph
 = 
_ISbit
 (7),

58 
	m_ISblank
 = 
_ISbit
 (8),

59 
	m_IScntrl
 = 
_ISbit
 (9),

60 
	m_ISpunct
 = 
_ISbit
 (10),

61 
	m_ISalnum
 = 
_ISbit
 (11)

81 extern 
__const
 unsigned short int **
	$__ctype_b_loc
 (void)

82 
__THROW
 
	`__attribute__
 ((
__const
));

83 extern 
__const
 
__int32_t
 **
	$__ctype_tolower_loc
 (void)

84 
__THROW
 
	`__attribute__
 ((
__const
));

85 extern 
__const
 
__int32_t
 **
	$__ctype_toupper_loc
 (void)

86 
__THROW
 
	`__attribute__
 ((
__const
));

88 #define 
	#__isctype
(
c
, 
type
) \

89 ((*
	`__ctype_b_loc
 ())[(int) (
c
)] & (unsigned short int) 
type
)

	)

91 #define 
	#__isascii
(
c
) (((c) & ~0x7f) == 0)

	)

92 #define 
	#__toascii
(
c
) ((c) & 0x7f)

	)

94 #define 
	#__exctype
(
name
) extern int 
	`name
 (int) 
__THROW


	)

96 
__BEGIN_NAMESPACE_STD


102 
	`__exctype
 (
isalnum
);

103 
	`__exctype
 (
isalpha
);

104 
	`__exctype
 (
iscntrl
);

105 
	`__exctype
 (
isdigit
);

106 
	`__exctype
 (
islower
);

107 
	`__exctype
 (
isgraph
);

108 
	`__exctype
 (
isprint
);

109 
	`__exctype
 (
ispunct
);

110 
	`__exctype
 (
isspace
);

111 
	`__exctype
 (
isupper
);

112 
	`__exctype
 (
isxdigit
);

116 extern int 
	$tolower
 (int 
__c
) 
__THROW
;

119 extern int 
	$toupper
 (int 
__c
) 
__THROW
;

121 
__END_NAMESPACE_STD


125 #ifdef 
__USE_ISOC99


126 
__BEGIN_NAMESPACE_C99


128 
	`__exctype
 (
isblank
);

130 
__END_NAMESPACE_C99


133 #ifdef 
__USE_GNU


135 extern int 
	$isctype
 (int 
__c
, int 
__mask
) 
__THROW
;

138 #if 
defined
 
__USE_SVID
 || defined 
__USE_MISC
 || defined 
__USE_XOPEN


142 extern int 
	$isascii
 (int 
__c
) 
__THROW
;

146 extern int 
	$toascii
 (int 
__c
) 
__THROW
;

150 
	`__exctype
 (
_toupper
);

151 
	`__exctype
 (
_tolower
);

155 #define 
	#__tobody
(
c
, 
f
, 
a
, 
args
) \

156 (
__extension__
 \

157 ({ int 
__res
; \

158 if (sizeof (
c
) > 1) \

160 if (
	`__builtin_constant_p
 (
c
)) \

162 int 
__c
 = (
c
); \

163 
__res
 = 
__c
 < -128 || __c > 255 ? __c : (
a
)[__c]; \

166 
__res
 = 
f
 
args
; \

169 
__res
 = (
a
)[(int) (
c
)]; \

170 
__res
; 
	}
}))

	)

172 #if !
defined
 
__NO_CTYPE
 && !defined 
__cplusplus


173 #define 
	#isalnum
(
c
) 
	`__isctype
((c), 
_ISalnum
)

	)

174 #define 
	#isalpha
(
c
) 
	`__isctype
((c), 
_ISalpha
)

	)

175 #define 
	#iscntrl
(
c
) 
	`__isctype
((c), 
_IScntrl
)

	)

176 #define 
	#isdigit
(
c
) 
	`__isctype
((c), 
_ISdigit
)

	)

177 #define 
	#islower
(
c
) 
	`__isctype
((c), 
_ISlower
)

	)

178 #define 
	#isgraph
(
c
) 
	`__isctype
((c), 
_ISgraph
)

	)

179 #define 
	#isprint
(
c
) 
	`__isctype
((c), 
_ISprint
)

	)

180 #define 
	#ispunct
(
c
) 
	`__isctype
((c), 
_ISpunct
)

	)

181 #define 
	#isspace
(
c
) 
	`__isctype
((c), 
_ISspace
)

	)

182 #define 
	#isupper
(
c
) 
	`__isctype
((c), 
_ISupper
)

	)

183 #define 
	#isxdigit
(
c
) 
	`__isctype
((c), 
_ISxdigit
)

	)

185 #ifdef 
__USE_ISOC99


186 #define 
	#isblank
(
c
) 
	`__isctype
((c), 
_ISblank
)

	)

189 #ifdef 
__USE_EXTERN_INLINES


190 
__extern_inline
 int

191 
__NTH
 (
	$tolower
 (int 
__c
))

193 return 
__c
 >= -128 && __c < 256 ? (*
	`__ctype_tolower_loc
 ())[__c] : __c;

194 
	}
}

196 
__extern_inline
 int

197 
__NTH
 (
	$toupper
 (int 
__c
))

199 return 
__c
 >= -128 && __c < 256 ? (*
	`__ctype_toupper_loc
 ())[__c] : __c;

200 
	}
}

203 #if 
__GNUC__
 >= 2 && 
defined
 
__OPTIMIZE__
 && !defined 
__cplusplus


204 #define 
	#tolower
(
c
) 
	`__tobody
 (c, 
tolower
, *
	`__ctype_tolower_loc
 (), (c))

	)

205 #define 
	#toupper
(
c
) 
	`__tobody
 (c, 
toupper
, *
	`__ctype_toupper_loc
 (), (c))

	)

208 #if 
defined
 
__USE_SVID
 || defined 
__USE_MISC
 || defined 
__USE_XOPEN


209 #define 
	#isascii
(
c
) 
	`__isascii
 (c)

	)

210 #define 
	#toascii
(
c
) 
	`__toascii
 (c)

	)

212 #define 
	#_tolower
(
c
) ((int) (*
	`__ctype_tolower_loc
 ())[(int) (c)])

	)

213 #define 
	#_toupper
(
c
) ((int) (*
	`__ctype_toupper_loc
 ())[(int) (c)])

	)

219 #ifdef 
__USE_XOPEN2K8


233 #include 
	~<xlocale.h
>

237 #define 
	#__isctype_l
(
c
, 
type
, 
locale
) \

238 ((
locale
)->
__ctype_b
[(int) (
c
)] & (unsigned short int) 
type
)

	)

240 #define 
	#__exctype_l
(
name
) \

241 extern int 
	`name
 (int, 
__locale_t
) 
__THROW


	)

247 
__exctype_l
 (
isalnum_l
);

248 
__exctype_l
 (
isalpha_l
);

249 
__exctype_l
 (
iscntrl_l
);

250 
__exctype_l
 (
isdigit_l
);

251 
__exctype_l
 (
islower_l
);

252 
__exctype_l
 (
isgraph_l
);

253 
__exctype_l
 (
isprint_l
);

254 
__exctype_l
 (
ispunct_l
);

255 
__exctype_l
 (
isspace_l
);

256 
__exctype_l
 (
isupper_l
);

257 
__exctype_l
 (
isxdigit_l
);

259 
__exctype_l
 (
isblank_l
);

263 extern int 
	$__tolower_l
 (int 
__c
, 
__locale_t
 
__l
) 
__THROW
;

264 extern int 
	$tolower_l
 (int 
__c
, 
__locale_t
 
__l
) 
__THROW
;

267 extern int 
	$__toupper_l
 (int 
__c
, 
__locale_t
 
__l
) 
__THROW
;

268 extern int 
	$toupper_l
 (int 
__c
, 
__locale_t
 
__l
) 
__THROW
;

270 #if 
__GNUC__
 >= 2 && 
defined
 
__OPTIMIZE__
 && !defined 
__cplusplus


271 #define 
	#__tolower_l
(
c
, 
locale
) \

272 
	`__tobody
 (
c
, 
__tolower_l
, (
locale
)->
__ctype_tolower
, (c, locale))

	)

273 #define 
	#__toupper_l
(
c
, 
locale
) \

274 
	`__tobody
 (
c
, 
__toupper_l
, (
locale
)->
__ctype_toupper
, (c, locale))

	)

275 #define 
	#tolower_l
(
c
, 
locale
) 
	`__tolower_l
 ((c), (locale))

	)

276 #define 
	#toupper_l
(
c
, 
locale
) 
	`__toupper_l
 ((c), (locale))

	)

280 #ifndef 
__NO_CTYPE


281 #define 
	#__isalnum_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISalnum
, (l))

	)

282 #define 
	#__isalpha_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISalpha
, (l))

	)

283 #define 
	#__iscntrl_l
(
c
,
l
) 
	`__isctype_l
((c), 
_IScntrl
, (l))

	)

284 #define 
	#__isdigit_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISdigit
, (l))

	)

285 #define 
	#__islower_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISlower
, (l))

	)

286 #define 
	#__isgraph_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISgraph
, (l))

	)

287 #define 
	#__isprint_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISprint
, (l))

	)

288 #define 
	#__ispunct_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISpunct
, (l))

	)

289 #define 
	#__isspace_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISspace
, (l))

	)

290 #define 
	#__isupper_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISupper
, (l))

	)

291 #define 
	#__isxdigit_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISxdigit
, (l))

	)

293 #define 
	#__isblank_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISblank
, (l))

	)

295 #if 
defined
 
__USE_SVID
 || defined 
__USE_MISC


296 #define 
	#__isascii_l
(
c
,
l
) ((l), 
	`__isascii
 (c))

	)

297 #define 
	#__toascii_l
(
c
,
l
) ((l), 
	`__toascii
 (c))

	)

300 #define 
	#isalnum_l
(
c
,
l
) 
	`__isalnum_l
 ((c), (l))

	)

301 #define 
	#isalpha_l
(
c
,
l
) 
	`__isalpha_l
 ((c), (l))

	)

302 #define 
	#iscntrl_l
(
c
,
l
) 
	`__iscntrl_l
 ((c), (l))

	)

303 #define 
	#isdigit_l
(
c
,
l
) 
	`__isdigit_l
 ((c), (l))

	)

304 #define 
	#islower_l
(
c
,
l
) 
	`__islower_l
 ((c), (l))

	)

305 #define 
	#isgraph_l
(
c
,
l
) 
	`__isgraph_l
 ((c), (l))

	)

306 #define 
	#isprint_l
(
c
,
l
) 
	`__isprint_l
 ((c), (l))

	)

307 #define 
	#ispunct_l
(
c
,
l
) 
	`__ispunct_l
 ((c), (l))

	)

308 #define 
	#isspace_l
(
c
,
l
) 
	`__isspace_l
 ((c), (l))

	)

309 #define 
	#isupper_l
(
c
,
l
) 
	`__isupper_l
 ((c), (l))

	)

310 #define 
	#isxdigit_l
(
c
,
l
) 
	`__isxdigit_l
 ((c), (l))

	)

312 #define 
	#isblank_l
(
c
,
l
) 
	`__isblank_l
 ((c), (l))

	)

314 #if 
defined
 
__USE_SVID
 || defined 
__USE_MISC


315 #define 
	#isascii_l
(
c
,
l
) 
	`__isascii_l
 ((c), (l))

	)

316 #define 
	#toascii_l
(
c
,
l
) 
	`__toascii_l
 ((c), (l))

	)

323 
__END_DECLS


	@/usr/include/endian.h

19 #ifndef 
_ENDIAN_H


20 #define 
	#_ENDIAN_H
 1

	)

22 #include 
	~<features.h
>

32 #define 
	#__LITTLE_ENDIAN
 1234

	)

33 #define 
	#__BIG_ENDIAN
 4321

	)

34 #define 
	#__PDP_ENDIAN
 3412

	)

37 #include 
	~<bits/endian.h
>

41 #ifndef 
__FLOAT_WORD_ORDER


42 #define 
	#__FLOAT_WORD_ORDER
 
__BYTE_ORDER


	)

45 #ifdef 
__USE_BSD


46 #define 
	#LITTLE_ENDIAN
 
__LITTLE_ENDIAN


	)

47 #define 
	#BIG_ENDIAN
 
__BIG_ENDIAN


	)

48 #define 
	#PDP_ENDIAN
 
__PDP_ENDIAN


	)

49 #define 
	#BYTE_ORDER
 
__BYTE_ORDER


	)

52 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


53 #define 
	#__LONG_LONG_PAIR
(
HI
, 
LO
) LO, 
	)
HI

54 #elif 
__BYTE_ORDER
 == 
__BIG_ENDIAN


55 #define 
	#__LONG_LONG_PAIR
(
HI
, 
LO
) HI, 
	)
LO

59 #ifdef 
__USE_BSD


61 #include 
	~<bits/byteswap.h
>

63 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


64 #define 
	#htobe16
(
x
) 
	`__bswap_16
 (x)

	)

65 #define 
	#htole16
(
x
) (x)

	)

66 #define 
	#be16toh
(
x
) 
	`__bswap_16
 (x)

	)

67 #define 
	#le16toh
(
x
) (x)

	)

69 #define 
	#htobe32
(
x
) 
	`__bswap_32
 (x)

	)

70 #define 
	#htole32
(
x
) (x)

	)

71 #define 
	#be32toh
(
x
) 
	`__bswap_32
 (x)

	)

72 #define 
	#le32toh
(
x
) (x)

	)

74 #define 
	#htobe64
(
x
) 
	`__bswap_64
 (x)

	)

75 #define 
	#htole64
(
x
) (x)

	)

76 #define 
	#be64toh
(
x
) 
	`__bswap_64
 (x)

	)

77 #define 
	#le64toh
(
x
) (x)

	)

79 #define 
	#htobe16
(
x
) (x)

	)

80 #define 
	#htole16
(
x
) 
	`__bswap_16
 (x)

	)

81 #define 
	#be16toh
(
x
) (x)

	)

82 #define 
	#le16toh
(
x
) 
	`__bswap_16
 (x)

	)

84 #define 
	#htobe32
(
x
) (x)

	)

85 #define 
	#htole32
(
x
) 
	`__bswap_32
 (x)

	)

86 #define 
	#be32toh
(
x
) (x)

	)

87 #define 
	#le32toh
(
x
) 
	`__bswap_32
 (x)

	)

89 #define 
	#htobe64
(
x
) (x)

	)

90 #define 
	#htole64
(
x
) 
	`__bswap_64
 (x)

	)

91 #define 
	#be64toh
(
x
) (x)

	)

92 #define 
	#le64toh
(
x
) 
	`__bswap_64
 (x)

	)

	@/usr/include/gnu/stubs.h

4 #include 
	~<bits/wordsize.h
>

6 #if 
__WORDSIZE
 == 32

7 #include 
	~<gnu/stubs-32.h
>

8 #elif 
__WORDSIZE
 == 64

9 #include 
	~<gnu/stubs-64.h
>

	@/usr/include/linux/errno.h

1 #ifndef 
_LINUX_ERRNO_H


2 #define 
	#_LINUX_ERRNO_H


	)

4 #include 
	~<asm/errno.h
>

	@/usr/include/sys/cdefs.h

20 #ifndef 
_SYS_CDEFS_H


21 #define 
	#_SYS_CDEFS_H
 1

	)

24 #ifndef 
_FEATURES_H


25 #include 
	~<features.h
>

31 #if 
defined
 
__GNUC__
 && !defined 
__STDC__


36 #undef 
__P


37 #undef 
__PMT


39 #ifdef 
__GNUC__


46 #if !
defined
 
__cplusplus
 && 
__GNUC_PREREQ
 (3, 3)

47 #define 
	#__THROW
 
	`__attribute__
 ((
__nothrow__
))

	)

48 #define 
	#__NTH
(
fct
) 
	`__attribute__
 ((
__nothrow__
)) 
	)
fct

50 #if 
defined
 
__cplusplus
 && 
__GNUC_PREREQ
 (2,8)

51 #define 
	#__THROW
 
	`throw
 ()

	)

52 #define 
	#__NTH
(
fct
) fct 
	`throw
 ()

	)

54 #define 
	#__THROW


	)

55 #define 
	#__NTH
(
fct
) 
	)
fct

61 #define 
	#__inline


	)

63 #define 
	#__THROW


	)

64 #define 
	#__NTH
(
fct
) 
	)
fct

66 #define 
	#__const
 const

	)

67 #define 
	#__signed
 signed

	)

68 #define 
	#__volatile
 volatile

	)

74 #define 
	#__P
(
args
) 
	)
args

75 #define 
	#__PMT
(
args
) 
	)
args

80 #define 
	#__CONCAT
(
x
,
y
) x ## 
	)
y

81 #define 
	#__STRING
(
x
) #x

	)

84 #define 
	#__ptr_t
 void *

	)

85 #define 
	#__long_double_t
 long double

	)

89 #ifdef 
__cplusplus


90 #define 
	#__BEGIN_DECLS
 extern "C" {

	)

91 #define 
	#__END_DECLS
 }

	)

93 #define 
	#__BEGIN_DECLS


	)

94 #define 
	#__END_DECLS


	)

103 #if 
defined
 
__cplusplus
 && defined 
_GLIBCPP_USE_NAMESPACES


104 #define 
	#__BEGIN_NAMESPACE_STD
 
namespace
 
std
 {

	)

105 #define 
	#__END_NAMESPACE_STD
 }

	)

106 #define 
	#__USING_NAMESPACE_STD
(
name
) 
using
 
std
::name;

	)

107 #define 
	#__BEGIN_NAMESPACE_C99
 
namespace
 
__c99
 {

	)

108 #define 
	#__END_NAMESPACE_C99
 }

	)

109 #define 
	#__USING_NAMESPACE_C99
(
name
) 
using
 
__c99
::name;

	)

114 #define 
	#__BEGIN_NAMESPACE_STD


	)

115 #define 
	#__END_NAMESPACE_STD


	)

116 #define 
	#__USING_NAMESPACE_STD
(
name
)

	)

117 #define 
	#__BEGIN_NAMESPACE_C99


	)

118 #define 
	#__END_NAMESPACE_C99


	)

119 #define 
	#__USING_NAMESPACE_C99
(
name
)

	)

124 #ifndef 
__BOUNDED_POINTERS__


125 #define 
	#__bounded


	)

126 #define 
	#__unbounded


	)

127 #define 
	#__ptrvalue


	)

132 #define 
	#__bos
(
ptr
) 
	`__builtin_object_size
 (ptr, 
__USE_FORTIFY_LEVEL
 > 1)

	)

133 #define 
	#__bos0
(
ptr
) 
	`__builtin_object_size
 (ptr, 0)

	)

135 #if 
__GNUC_PREREQ
 (4,3) \

136 || (
defined
 
	g__GNUC_RH_RELEASE__
 && 
	g__GNUC__
 == 4 \

137 && 
__GNUC_MINOR__
 == 1 && 
__GNUC_PATCHLEVEL__
 == 2 \

138 && 
__GNUC_RH_RELEASE__
 >= 31)

139 #define 
	#__warndecl
(
name
, 
msg
) \

140 extern void 
	`name
 (void) 
	`__attribute__
((
	`__warning__
 (
msg
)))

	)

141 #define 
	#__warnattr
(
msg
) 
	`__attribute__
((
	`__warning__
 (msg)))

	)

142 #define 
	#__errordecl
(
name
, 
msg
) \

143 extern void 
	`name
 (void) 
	`__attribute__
((
	`__error__
 (
msg
)))

	)

145 #define 
	#__warndecl
(
name
, 
msg
) extern void 
	`name
 (void)

	)

146 #define 
	#__warnattr
(
msg
)

	)

147 #define 
	#__errordecl
(
name
, 
msg
) extern void 
	`name
 (void)

	)

151 #if 
__GNUC_PREREQ
 (2,97)

153 #define 
	#__flexarr
 []

	)

155 #ifdef 
__GNUC__


156 #define 
	#__flexarr
 [0]

	)

158 #if 
defined
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L

159 #define 
	#__flexarr
 []

	)

162 #define 
	#__flexarr
 [1]

	)

178 #if 
defined
 
__GNUC__
 && __GNUC__ >= 2

180 #define 
	#__REDIRECT
(
name
, 
proto
, 
alias
) name proto 
	`__asm__
 (
	`__ASMNAME
 (#alias))

	)

181 #ifdef 
__cplusplus


182 #define 
	#__REDIRECT_NTH
(
name
, 
proto
, 
alias
) \

183 
name
 
proto
 
__THROW
 
	`__asm__
 (
	`__ASMNAME
 (#alias))

	)

185 #define 
	#__REDIRECT_NTH
(
name
, 
proto
, 
alias
) \

186 
name
 
proto
 
	`__asm__
 (
	`__ASMNAME
 (#alias)) 
__THROW


	)

188 #define 
	#__ASMNAME
(
cname
) 
	`__ASMNAME2
 (
__USER_LABEL_PREFIX__
, cname)

	)

189 #define 
	#__ASMNAME2
(
prefix
, 
cname
) 
	`__STRING
 (prefix) 
	)
cname

202 #if !
defined
 
__GNUC__
 || __GNUC__ < 2

203 #define 
	#__attribute__
(
xyz
)

	)

209 #if 
__GNUC_PREREQ
 (2,96)

210 #define 
	#__attribute_malloc__
 
	`__attribute__
 ((
__malloc__
))

	)

212 #define 
	#__attribute_malloc__


	)

218 #if 
__GNUC_PREREQ
 (2,96)

219 #define 
	#__attribute_pure__
 
	`__attribute__
 ((
__pure__
))

	)

221 #define 
	#__attribute_pure__


	)

227 #if 
__GNUC_PREREQ
 (3,1)

228 #define 
	#__attribute_used__
 
	`__attribute__
 ((
__used__
))

	)

229 #define 
	#__attribute_noinline__
 
	`__attribute__
 ((
__noinline__
))

	)

231 #define 
	#__attribute_used__
 
	`__attribute__
 ((
__unused__
))

	)

232 #define 
	#__attribute_noinline__


	)

236 #if 
__GNUC_PREREQ
 (3,2)

237 #define 
	#__attribute_deprecated__
 
	`__attribute__
 ((
__deprecated__
))

	)

239 #define 
	#__attribute_deprecated__


	)

248 #if 
__GNUC_PREREQ
 (2,8)

249 #define 
	#__attribute_format_arg__
(
x
) 
	`__attribute__
 ((
	`__format_arg__
 (x)))

	)

251 #define 
	#__attribute_format_arg__
(
x
)

	)

258 #if 
__GNUC_PREREQ
 (2,97)

259 #define 
	#__attribute_format_strfmon__
(
a
,
b
) \

260 
	`__attribute__
 ((
	`__format__
 (
__strfmon__
, 
a
, 
b
)))

	)

262 #define 
	#__attribute_format_strfmon__
(
a
,
b
)

	)

267 #if 
__GNUC_PREREQ
 (3,3)

268 #define 
	#__nonnull
(
params
) 
	`__attribute__
 ((
__nonnull__
 params))

	)

270 #define 
	#__nonnull
(
params
)

	)

275 #if 
__GNUC_PREREQ
 (3,4)

276 #define 
	#__attribute_warn_unused_result__
 \

277 
	`__attribute__
 ((
__warn_unused_result__
))

	)

278 #if 
__USE_FORTIFY_LEVEL
 > 0

279 #define 
	#__wur
 
__attribute_warn_unused_result__


	)

282 #define 
	#__attribute_warn_unused_result__


	)

284 #ifndef 
__wur


285 #define 
	#__wur


	)

289 #if 
__GNUC_PREREQ
 (3,2)

290 #define 
	#__always_inline
 
__inline
 
	`__attribute__
 ((
__always_inline__
))

	)

292 #define 
	#__always_inline
 
__inline


	)

297 #if !
defined
 
__cplusplus
 || 
__GNUC_PREREQ
 (4,3) \

298 || (
defined
 
__GNUC_RH_RELEASE__
 && 
__GNUC__
 == 4 \

299 && 
__GNUC_MINOR__
 == 1 && 
__GNUC_PATCHLEVEL__
 == 2 \

300 && 
__GNUC_RH_RELEASE__
 >= 31)

301 #if 
defined
 
__GNUC_STDC_INLINE__
 || defined 
__cplusplus


302 #define 
	#__extern_inline
 extern 
__inline
 
	`__attribute__
 ((
__gnu_inline__
))

	)

303 #if 
__GNUC_PREREQ
 (4,3) \

304 || (
defined
 
__GNUC_RH_RELEASE__
 && 
__GNUC__
 == 4 \

305 && 
__GNUC_MINOR__
 == 1 && 
__GNUC_PATCHLEVEL__
 == 2 \

306 && 
__GNUC_RH_RELEASE__
 >= 31)

307 #define 
	#__extern_always_inline
 \

308 extern 
__always_inline
 
	`__attribute__
 ((
__gnu_inline__
, 
__artificial__
))

	)

310 #define 
	#__extern_always_inline
 \

311 extern 
__always_inline
 
	`__attribute__
 ((
__gnu_inline__
))

	)

314 #define 
	#__extern_inline
 extern 
__inline


	)

315 #if 
__GNUC_PREREQ
 (4,3)

316 #define 
	#__extern_always_inline
 \

317 extern 
__always_inline
 
	`__attribute__
 ((
__artificial__
))

	)

319 #define 
	#__extern_always_inline
 extern 
__always_inline


	)

326 #if 
__GNUC_PREREQ
 (4,3) \

327 || (
defined
 
__GNUC_RH_RELEASE__
 && 
__GNUC__
 == 4 \

328 && 
__GNUC_MINOR__
 == 1 && 
__GNUC_PATCHLEVEL__
 == 2 \

329 && 
__GNUC_RH_RELEASE__
 >= 31)

330 #define 
	#__va_arg_pack
() 
	`__builtin_va_arg_pack
 ()

	)

331 #define 
	#__va_arg_pack_len
() 
	`__builtin_va_arg_pack_len
 ()

	)

338 #if !
__GNUC_PREREQ
 (2,8)

339 #define 
	#__extension__


	)

343 #if !
__GNUC_PREREQ
 (2,92)

344 #define 
	#__restrict


	)

350 #if 
__GNUC_PREREQ
 (3,1) && !
defined
 
__GNUG__


351 #define 
	#__restrict_arr
 
__restrict


	)

353 #ifdef 
__GNUC__


354 #define 
	#__restrict_arr


	)

356 #if 
defined
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L

357 #define 
	#__restrict_arr
 
restrict


	)

360 #define 
	#__restrict_arr


	)

365 #include 
	~<bits/wordsize.h
>

367 #if 
defined
 
__LONG_DOUBLE_MATH_OPTIONAL
 && defined 
__NO_LONG_DOUBLE_MATH


368 #define 
	#__LDBL_COMPAT
 1

	)

369 #ifdef 
__REDIRECT


370 #define 
	#__LDBL_REDIR1
(
name
, 
proto
, 
alias
) 
	`__REDIRECT
 (name, proto, alias)

	)

371 #define 
	#__LDBL_REDIR
(
name
, 
proto
) \

372 
	`__LDBL_REDIR1
 (
name
, 
proto
, 
__nldbl_
##name)

	)

373 #define 
	#__LDBL_REDIR1_NTH
(
name
, 
proto
, 
alias
) 
	`__REDIRECT_NTH
 (name, proto, alias)

	)

374 #define 
	#__LDBL_REDIR_NTH
(
name
, 
proto
) \

375 
	`__LDBL_REDIR1_NTH
 (
name
, 
proto
, 
__nldbl_
##name)

	)

376 #define 
	#__LDBL_REDIR1_DECL
(
name
, 
alias
) \

377 extern 
	`__typeof
 (
name
) name 
	`__asm
 (
	`__ASMNAME
 (#alias));

	)

378 #define 
	#__LDBL_REDIR_DECL
(
name
) \

379 extern 
	`__typeof
 (
name
) name 
	`__asm
 (
	`__ASMNAME
 ("__nldbl_" #name));

	)

380 #define 
	#__REDIRECT_LDBL
(
name
, 
proto
, 
alias
) \

381 
	`__LDBL_REDIR1
 (
name
, 
proto
, 
__nldbl_
##
alias
)

	)

382 #define 
	#__REDIRECT_NTH_LDBL
(
name
, 
proto
, 
alias
) \

383 
	`__LDBL_REDIR1_NTH
 (
name
, 
proto
, 
__nldbl_
##
alias
)

	)

386 #if !
defined
 
__LDBL_COMPAT
 || !defined 
__REDIRECT


387 #define 
	#__LDBL_REDIR1
(
name
, 
proto
, 
alias
) name 
	)
proto

388 #define 
	#__LDBL_REDIR
(
name
, 
proto
) name 
	)
proto

389 #define 
	#__LDBL_REDIR1_NTH
(
name
, 
proto
, 
alias
) name proto 
__THROW


	)

390 #define 
	#__LDBL_REDIR_NTH
(
name
, 
proto
) name proto 
__THROW


	)

391 #define 
	#__LDBL_REDIR_DECL
(
name
)

	)

392 #ifdef 
__REDIRECT


393 #define 
	#__REDIRECT_LDBL
(
name
, 
proto
, 
alias
) 
	`__REDIRECT
 (name, proto, alias)

	)

394 #define 
	#__REDIRECT_NTH_LDBL
(
name
, 
proto
, 
alias
) \

395 
	`__REDIRECT_NTH
 (
name
, 
proto
, 
alias
)

	)

	@/usr/include/sys/select.h

22 #ifndef 
_SYS_SELECT_H


23 #define 
	#_SYS_SELECT_H
 1

	)

25 #include 
	~<features.h
>

28 #include 
	~<bits/types.h
>

31 #include 
	~<bits/select.h
>

34 #include 
	~<bits/sigset.h
>

36 #ifndef 
__sigset_t_defined


37 #define 
	#__sigset_t_defined


	)

38 typedef 
__sigset_t
 
	tsigset_t
;

42 #define 
	#__need_time_t


	)

43 #define 
	#__need_timespec


	)

44 #include 
	~<time.h
>

45 #define 
	#__need_timeval


	)

46 #include 
	~<bits/time.h
>

48 #ifndef 
__suseconds_t_defined


49 typedef 
__suseconds_t
 
	tsuseconds_t
;

50 #define 
	#__suseconds_t_defined


	)

55 typedef long int 
	t__fd_mask
;

58 #undef 
__NFDBITS


59 #undef 
__FDELT


60 #undef 
__FDMASK


62 #define 
	#__NFDBITS
 (8 * (int) sizeof (
__fd_mask
))

	)

63 #define 
	#__FDELT
(
d
) ((d) / 
__NFDBITS
)

	)

64 #define 
	#__FDMASK
(
d
) ((
__fd_mask
) 1 << ((d) % 
__NFDBITS
))

	)

71 #ifdef 
__USE_XOPEN


72 
__fd_mask
 
	mfds_bits
[
__FD_SETSIZE
 / 
__NFDBITS
];

73 #define 
	#__FDS_BITS
(
set
) ((set)->
fds_bits
)

	)

75 
__fd_mask
 
	m__fds_bits
[
__FD_SETSIZE
 / 
__NFDBITS
];

76 #define 
	#__FDS_BITS
(
set
) ((set)->
__fds_bits
)

	)

78 } 
	tfd_set
;

81 #define 
	#FD_SETSIZE
 
__FD_SETSIZE


	)

83 #ifdef 
__USE_MISC


85 typedef 
__fd_mask
 
	tfd_mask
;

88 #define 
	#NFDBITS
 
__NFDBITS


	)

93 #define 
	#FD_SET
(
fd
, 
fdsetp
) 
	`__FD_SET
 (fd, fdsetp)

	)

94 #define 
	#FD_CLR
(
fd
, 
fdsetp
) 
	`__FD_CLR
 (fd, fdsetp)

	)

95 #define 
	#FD_ISSET
(
fd
, 
fdsetp
) 
	`__FD_ISSET
 (fd, fdsetp)

	)

96 #define 
	#FD_ZERO
(
fdsetp
) 
	`__FD_ZERO
 (fdsetp)

	)

99 
__BEGIN_DECLS


109 extern int 
select
 (int 
__nfds
, 
fd_set
 *
__restrict
 
__readfds
,

110 
fd_set
 *
__restrict
 
__writefds
,

111 
fd_set
 *
__restrict
 
__exceptfds
,

112 struct 
timeval
 *
__restrict
 
__timeout
);

114 #ifdef 
__USE_XOPEN2K


121 extern int 
pselect
 (int 
__nfds
, 
fd_set
 *
__restrict
 
__readfds
,

122 
fd_set
 *
__restrict
 
__writefds
,

123 
fd_set
 *
__restrict
 
__exceptfds
,

124 const struct 
timespec
 *
__restrict
 
__timeout
,

125 const 
__sigset_t
 *
__restrict
 
__sigmask
);

128 
	g__END_DECLS


	@/usr/include/sys/sysmacros.h

21 #ifndef 
_SYS_SYSMACROS_H


22 #define 
	#_SYS_SYSMACROS_H
 1

	)

24 #include 
	~<features.h
>

29 #ifdef 
__GLIBC_HAVE_LONG_LONG


30 
__extension__


31 extern unsigned int 
	$gnu_dev_major
 (unsigned long long int 
__dev
)

32 
__THROW
;

33 
__extension__


34 extern unsigned int 
	$gnu_dev_minor
 (unsigned long long int 
__dev
)

35 
__THROW
;

36 
__extension__


37 extern unsigned long long int 
	$gnu_dev_makedev
 (unsigned int 
__major
,

38 unsigned int 
__minor
)

39 
__THROW
;

41 #if 
defined
 
__GNUC__
 && __GNUC__ >= 2 && defined 
__USE_EXTERN_INLINES


42 
__extension__
 
__extern_inline
 unsigned int

43 
	`__NTH
 (
	$gnu_dev_major
 (unsigned long long int 
__dev
))

45 return ((
__dev
 >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);

46 
	}
}

48 
__extension__
 
__extern_inline
 unsigned int

49 
__NTH
 (
	$gnu_dev_minor
 (unsigned long long int 
__dev
))

51 return (
__dev
 & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);

52 
	}
}

54 
__extension__
 
__extern_inline
 unsigned long long int

55 
__NTH
 (
	$gnu_dev_makedev
 (unsigned int 
__major
, unsigned int 
__minor
))

57 return ((
__minor
 & 0xff) | ((
__major
 & 0xfff) << 8)

58 | (((unsigned long long int) (
__minor
 & ~0xff)) << 12)

59 | (((unsigned long long int) (
__major
 & ~0xfff)) << 32));

60 
	}
}

65 #define 
	#major
(
dev
) 
	`gnu_dev_major
 (dev)

	)

66 #define 
	#minor
(
dev
) 
	`gnu_dev_minor
 (dev)

	)

67 #define 
	#makedev
(
maj
, 
min
) 
	`gnu_dev_makedev
 (maj, min)

	)

	@/usr/include/time.h

23 #ifndef 
_TIME_H


25 #if (! 
defined
 
__need_time_t
 && !defined 
__need_clock_t
 && \

26 ! 
defined
 
	g__need_timespec
)

27 #define 
	#_TIME_H
 1

	)

28 #include 
	~<features.h
>

30 
	g__BEGIN_DECLS


34 #ifdef 
_TIME_H


36 #define 
	#__need_size_t


	)

37 #define 
	#__need_NULL


	)

38 #include 
	~<stddef.h
>

42 #include 
	~<bits/time.h
>

45 #if !
defined
 
__STRICT_ANSI__
 && !defined 
__USE_XOPEN2K


46 #ifndef 
CLK_TCK


47 #define 
	#CLK_TCK
 
CLOCKS_PER_SEC


	)

53 #if !
defined
 
__clock_t_defined
 && (defined 
_TIME_H
 || defined 
__need_clock_t
)

54 #define 
	#__clock_t_defined
 1

	)

56 #include 
	~<bits/types.h
>

58 
__BEGIN_NAMESPACE_STD


60 typedef 
__clock_t
 
	tclock_t
;

61 
	g__END_NAMESPACE_STD


62 #if 
defined
 
__USE_XOPEN
 || defined 
__USE_POSIX
 || defined 
__USE_MISC


63 
	$__USING_NAMESPACE_STD
(
clock_t
)

67 #undef 
__need_clock_t


69 #if !
defined
 
__time_t_defined
 && (defined 
_TIME_H
 || defined 
__need_time_t
)

70 #define 
	#__time_t_defined
 1

	)

72 #include 
	~<bits/types.h
>

74 
__BEGIN_NAMESPACE_STD


76 typedef 
__time_t
 
	ttime_t
;

77 
__END_NAMESPACE_STD


78 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC
 || defined 
__USE_SVID


79 
	$__USING_NAMESPACE_STD
(
time_t
)

83 #undef 
__need_time_t


85 #if !
defined
 
__clockid_t_defined
 && \

86 ((
defined
 
_TIME_H
 && defined 
__USE_POSIX199309
) || defined 
__need_clockid_t
)

87 #define 
	#__clockid_t_defined
 1

	)

89 #include 
	~<bits/types.h
>

92 typedef 
__clockid_t
 
	tclockid_t
;

95 #undef 
__clockid_time_t


97 #if !
defined
 
__timer_t_defined
 && \

98 ((
defined
 
_TIME_H
 && defined 
__USE_POSIX199309
) || defined 
__need_timer_t
)

99 #define 
	#__timer_t_defined
 1

	)

101 #include 
	~<bits/types.h
>

104 typedef 
__timer_t
 
	ttimer_t
;

107 #undef 
__need_timer_t


110 #if !
defined
 
__timespec_defined
 && \

111 ((
defined
 
_TIME_H
 && \

112 (
defined
 
__USE_POSIX199309
 || defined 
__USE_MISC
)) || \

113 
defined
 
__need_timespec
)

114 #define 
	#__timespec_defined
 1

	)

116 #include 
	~<bits/types.h
>

120 struct 
	stimespec


122 
__time_t
 
tv_sec
;

123 long int 
tv_nsec
;

127 #undef 
__need_timespec


130 #ifdef 
_TIME_H


131 
__BEGIN_NAMESPACE_STD


133 struct 
	stm


135 int 
tm_sec
;

136 int 
tm_min
;

137 int 
tm_hour
;

138 int 
tm_mday
;

139 int 
tm_mon
;

140 int 
tm_year
;

141 int 
tm_wday
;

142 int 
tm_yday
;

143 int 
tm_isdst
;

145 #ifdef 
__USE_BSD


146 long int 
tm_gmtoff
;

147 
__const
 char *
tm_zone
;

149 long int 
__tm_gmtoff
;

150 
__const
 char *
__tm_zone
;

153 
__END_NAMESPACE_STD


154 #if 
defined
 
__USE_XOPEN
 || defined 
__USE_POSIX
 || defined 
__USE_MISC


155 
	$__USING_NAMESPACE_STD
(
tm
)

159 #ifdef 
__USE_POSIX199309


161 struct 
	sitimerspec


163 struct 
timespec
 
it_interval
;

164 struct 
timespec
 
it_value
;

168 struct 
sigevent
;

172 #ifdef 
__USE_XOPEN2K


173 #ifndef 
__pid_t_defined


174 typedef 
__pid_t
 
	tpid_t
;

175 #define 
	#__pid_t_defined


	)

180 
__BEGIN_NAMESPACE_STD


183 extern 
clock_t
 
	$clock
 (void) 
__THROW
;

186 extern 
time_t
 
	$time
 (
time_t
 *
__timer
) 
__THROW
;

189 extern double 
	$difftime
 (
time_t
 
__time1
, time_t 
__time0
)

190 
__THROW
 
	`__attribute__
 ((
__const__
));

193 extern 
time_t
 
	$mktime
 (struct 
tm
 *
__tp
) 
__THROW
;

199 extern 
size_t
 
	$strftime
 (char *
__restrict
 
__s
, 
size_t
 
__maxsize
,

200 
__const
 char *
__restrict
 
__format
,

201 
__const
 struct 
tm
 *
__restrict
 
__tp
) 
__THROW
;

202 
__END_NAMESPACE_STD


204 #ifdef 
__USE_XOPEN


207 extern char *
	$strptime
 (
__const
 char *
__restrict
 
__s
,

208 
__const
 char *
__restrict
 
__fmt
, struct 
tm
 *
__tp
)

209 
__THROW
;

212 #ifdef 
__USE_XOPEN2K8


215 #include 
	~<xlocale.h
>

217 extern 
size_t
 
	$strftime_l
 (char *
__restrict
 
__s
, 
size_t
 
__maxsize
,

218 
__const
 char *
__restrict
 
__format
,

219 
__const
 struct 
tm
 *
__restrict
 
__tp
,

220 
__locale_t
 
__loc
) 
__THROW
;

223 #ifdef 
__USE_GNU


224 extern char *
	$strptime_l
 (
__const
 char *
__restrict
 
__s
,

225 
__const
 char *
__restrict
 
__fmt
, struct 
tm
 *
__tp
,

226 
__locale_t
 
__loc
) 
__THROW
;

230 
__BEGIN_NAMESPACE_STD


233 extern struct 
tm
 *
	$gmtime
 (
__const
 
time_t
 *
__timer
) 
__THROW
;

237 extern struct 
tm
 *
	$localtime
 (
__const
 
time_t
 *
__timer
) 
__THROW
;

238 
__END_NAMESPACE_STD


240 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


243 extern struct 
tm
 *
	$gmtime_r
 (
__const
 
time_t
 *
__restrict
 
__timer
,

244 struct 
tm
 *
__restrict
 
__tp
) 
__THROW
;

248 extern struct 
tm
 *
	$localtime_r
 (
__const
 
time_t
 *
__restrict
 
__timer
,

249 struct 
tm
 *
__restrict
 
__tp
) 
__THROW
;

252 
__BEGIN_NAMESPACE_STD


255 extern char *
	$asctime
 (
__const
 struct 
tm
 *
__tp
) 
__THROW
;

258 extern char *
	$ctime
 (
__const
 
time_t
 *
__timer
) 
__THROW
;

259 
__END_NAMESPACE_STD


261 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


266 extern char *
	$asctime_r
 (
__const
 struct 
tm
 *
__restrict
 
__tp
,

267 char *
__restrict
 
__buf
) 
__THROW
;

270 extern char *
	$ctime_r
 (
__const
 
time_t
 *
__restrict
 
__timer
,

271 char *
__restrict
 
__buf
) 
__THROW
;

276 extern char *
__tzname
[2];

277 extern int 
__daylight
;

278 extern long int 
__timezone
;

281 #ifdef 
__USE_POSIX


283 extern char *
tzname
[2];

287 extern void 
	$tzset
 (void) 
__THROW
;

290 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN


291 extern int 
daylight
;

292 extern long int 
timezone
;

295 #ifdef 
__USE_SVID


298 extern int 
	$stime
 (
__const
 
time_t
 *
__when
) 
__THROW
;

304 #define 
	#__isleap
(
year
) \

305 ((
year
) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))

	)

308 #ifdef 
__USE_MISC


313 extern 
time_t
 
	$timegm
 (struct 
tm
 *
__tp
) 
__THROW
;

316 extern 
time_t
 
	$timelocal
 (struct 
tm
 *
__tp
) 
__THROW
;

319 extern int 
	$dysize
 (int 
__year
) 
__THROW
 
	`__attribute__
 ((
__const__
));

323 #ifdef 
__USE_POSIX199309


328 extern int 
	`nanosleep
 (
__const
 struct 
timespec
 *
__requested_time
,

329 struct 
timespec
 *
__remaining
);

333 extern int 
	$clock_getres
 (
clockid_t
 
__clock_id
, struct 
timespec
 *
__res
) 
__THROW
;

336 extern int 
	$clock_gettime
 (
clockid_t
 
__clock_id
, struct 
timespec
 *
__tp
) 
__THROW
;

339 extern int 
	$clock_settime
 (
clockid_t
 
__clock_id
, 
__const
 struct 
timespec
 *
__tp
)

340 
__THROW
;

342 #ifdef 
__USE_XOPEN2K


347 extern int 
	`clock_nanosleep
 (
clockid_t
 
__clock_id
, int 
__flags
,

348 
__const
 struct 
timespec
 *
__req
,

349 struct 
timespec
 *
__rem
);

352 extern int 
	$clock_getcpuclockid
 (
pid_t
 
__pid
, 
clockid_t
 *
__clock_id
) 
__THROW
;

357 extern int 
	$timer_create
 (
clockid_t
 
__clock_id
,

358 struct 
sigevent
 *
__restrict
 
__evp
,

359 
timer_t
 *
__restrict
 
__timerid
) 
__THROW
;

362 extern int 
	$timer_delete
 (
timer_t
 
__timerid
) 
__THROW
;

365 extern int 
	$timer_settime
 (
timer_t
 
__timerid
, int 
__flags
,

366 
__const
 struct 
itimerspec
 *
__restrict
 
__value
,

367 struct 
itimerspec
 *
__restrict
 
__ovalue
) 
__THROW
;

370 extern int 
	$timer_gettime
 (
timer_t
 
__timerid
, struct 
itimerspec
 *
__value
)

371 
__THROW
;

374 extern int 
	$timer_getoverrun
 (
timer_t
 
__timerid
) 
__THROW
;

378 #ifdef 
__USE_XOPEN_EXTENDED


390 extern int 
getdate_err
;

399 extern struct 
tm
 *
	`getdate
 (
__const
 char *
__string
);

402 #ifdef 
__USE_GNU


413 extern int 
	`getdate_r
 (
__const
 char *
__restrict
 
__string
,

414 struct 
tm
 *
__restrict
 
__resbufp
);

417 
__END_DECLS


	@/usr/include/asm/errno.h

1 #include 
	~<asm-generic/errno.h
>

	@/usr/include/bits/byteswap.h

21 #if !
defined
 
_BYTESWAP_H
 && !defined 
_NETINET_IN_H
 && !defined 
_ENDIAN_H


25 #ifndef 
_BITS_BYTESWAP_H


26 #define 
	#_BITS_BYTESWAP_H
 1

	)

28 #include 
	~<bits/wordsize.h
>

31 #define 
	#__bswap_constant_16
(
x
) \

32 ((unsigned short int) ((((
x
) >> 8) & 0xff) | (((x) & 0xff) << 8)))

	)

34 #if 
defined
 
__GNUC__
 && __GNUC__ >= 2

35 #define 
	#__bswap_16
(
x
) \

36 (
__extension__
 \

37 ({ register unsigned short int 
__v
, 
__x
 = (unsigned short int) (
x
); \

38 if (
	`__builtin_constant_p
 (
__x
)) \

39 
__v
 = 
	`__bswap_constant_16
 (
__x
); \

41 
	`__asm__
 ("rorw $8, %w0" \

42 : "=r" (
__v
) \

43 : "0" (
__x
) \

45 
__v
; }))

	)

48 #define 
	#__bswap_16
(
x
) \

49 (
__extension__
 \

50 ({ register unsigned short int 
__x
 = (unsigned short int) (
x
); \

51 
	`__bswap_constant_16
 (
__x
); }))

	)

56 #define 
	#__bswap_constant_32
(
x
) \

57 ((((
x
) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >> 8) | \

58 (((
x
) & 0x0000ff00) << 8) | (((x) & 0x000000ff) << 24))

	)

60 #if 
defined
 
__GNUC__
 && __GNUC__ >= 2

61 #if 
__WORDSIZE
 == 64 || (
defined
 
__i486__
 || defined 
__pentium__
 \

62 || 
defined
 
	g__pentiumpro__
 || defined 
	g__pentium4__
 \

63 || 
defined
 
	g__k8__
 || defined 
	g__athlon__
 \

64 || 
defined
 
	g__k6__
 || defined 
	g__nocona__
 \

65 || 
defined
 
	g__core2__
 || defined 
	g__geode__
 \

66 || 
defined
 
	g__amdfam10__
)

69 #define 
	#__bswap_32
(
x
) \

70 (
__extension__
 \

71 ({ register unsigned int 
__v
, 
__x
 = (
x
); \

72 if (
	`__builtin_constant_p
 (
__x
)) \

73 
__v
 = 
	`__bswap_constant_32
 (
__x
); \

75 
	`__asm__
 ("bswap %0" : "=r" (
__v
) : "0" (
__x
)); \

76 
__v
; }))

	)

78 #define 
	#__bswap_32
(
x
) \

79 (
__extension__
 \

80 ({ register unsigned int 
__v
, 
__x
 = (
x
); \

81 if (
	`__builtin_constant_p
 (
__x
)) \

82 
__v
 = 
	`__bswap_constant_32
 (
__x
); \

84 
	`__asm__
 ("rorw $8, %w0;" \

87 : "=r" (
__v
) \

88 : "0" (
__x
) \

90 
__v
; }))

	)

93 #define 
	#__bswap_32
(
x
) \

94 (
__extension__
 \

95 ({ register unsigned int 
__x
 = (
x
); 
	`__bswap_constant_32
 (__x); }))

	)

99 #if 
defined
 
__GNUC__
 && __GNUC__ >= 2

101 #define 
	#__bswap_constant_64
(
x
) \

102 ((((
x
) & 0xff00000000000000ull) >> 56) \

103 | (((
x
) & 0x00ff000000000000ull) >> 40) \

104 | (((
x
) & 0x0000ff0000000000ull) >> 24) \

105 | (((
x
) & 0x000000ff00000000ull) >> 8) \

106 | (((
x
) & 0x00000000ff000000ull) << 8) \

107 | (((
x
) & 0x0000000000ff0000ull) << 24) \

108 | (((
x
) & 0x000000000000ff00ull) << 40) \

109 | (((
x
) & 0x00000000000000ffull) << 56))

	)

111 #if 
__WORDSIZE
 == 64

112 #define 
	#__bswap_64
(
x
) \

113 (
__extension__
 \

114 ({ register unsigned long 
__v
, 
__x
 = (
x
); \

115 if (
	`__builtin_constant_p
 (
__x
)) \

116 
__v
 = 
	`__bswap_constant_64
 (
__x
); \

118 
	`__asm__
 ("bswap %q0" : "=r" (
__v
) : "0" (
__x
)); \

119 
__v
; }))

	)

121 #define 
	#__bswap_64
(
x
) \

122 (
__extension__
 \

123 ({ union { 
__extension__
 unsigned long long int 
__ll
; \

124 unsigned int 
__l
[2]; } 
__w
, 
__r
; \

125 if (
	`__builtin_constant_p
 (
x
)) \

126 
__r
.
__ll
 = 
	`__bswap_constant_64
 (
x
); \

129 
__w
.
__ll
 = (
x
); \

130 
__r
.
__l
[0] = 
	`__bswap_32
 (
__w
.__l[1]); \

131 
__r
.
__l
[1] = 
	`__bswap_32
 (
__w
.__l[0]); \

133 
__r
.
__ll
; }))

	)

	@/usr/include/bits/endian.h

3 #ifndef 
_ENDIAN_H


7 #define 
	#__BYTE_ORDER
 
__LITTLE_ENDIAN


	)

	@/usr/include/bits/libc-lock.h

21 #ifndef 
_BITS_LIBC_LOCK_H


22 #define 
	#_BITS_LIBC_LOCK_H
 1

	)

24 #include 
	~<pthread.h
>

27 #ifdef 
_IO_MTSAFE_IO


28 typedef 
pthread_mutex_t
 
	t__libc_lock_t
;

29 typedef struct { 
pthread_mutex_t
 
	mmutex
; } 
	t__libc_lock_recursive_t
;

30 #ifdef 
__USE_UNIX98


31 typedef 
pthread_rwlock_t
 
	t__libc_rwlock_t
;

33 typedef struct 
__libc_rwlock_opaque__
 
	t__libc_rwlock_t
;

35 typedef 
__libc_lock_recursive_t
 
	t__rtld_lock_recursive_t
;

37 typedef struct 
__libc_lock_opaque__
 
	t__libc_lock_t
;

38 typedef struct 
__libc_lock_recursive_opaque__
 
	t__libc_lock_recursive_t
;

39 typedef struct 
__libc_rwlock_opaque__
 
	t__libc_rwlock_t
;

43 typedef 
pthread_key_t
 
	t__libc_key_t
;

52 #define 
	#__libc_lock_define
(
CLASS
,
NAME
) \

53 
CLASS
 
__libc_lock_t
 
NAME
;

	)

54 #define 
	#__libc_rwlock_define
(
CLASS
,
NAME
) \

55 
CLASS
 
__libc_rwlock_t
 
NAME
;

	)

56 #define 
	#__libc_lock_define_recursive
(
CLASS
,
NAME
) \

57 
CLASS
 
__libc_lock_recursive_t
 
NAME
;

	)

58 #define 
	#__rtld_lock_define_recursive
(
CLASS
,
NAME
) \

59 
CLASS
 
__rtld_lock_recursive_t
 
NAME
;

	)

70 #if 
__LT_SPINLOCK_INIT
 == 0

71 #define 
	#__libc_lock_define_initialized
(
CLASS
,
NAME
) \

72 
CLASS
 
__libc_lock_t
 
NAME
;

	)

74 #define 
	#__libc_lock_define_initialized
(
CLASS
,
NAME
) \

75 
CLASS
 
__libc_lock_t
 
NAME
 = 
PTHREAD_MUTEX_INITIALIZER
;

	)

78 #define 
	#__libc_rwlock_define_initialized
(
CLASS
,
NAME
) \

79 
CLASS
 
__libc_rwlock_t
 
NAME
 = 
PTHREAD_RWLOCK_INITIALIZER
;

	)

83 #define 
	#__libc_lock_define_initialized_recursive
(
CLASS
,
NAME
) \

84 
CLASS
 
__libc_lock_recursive_t
 
NAME
 = 
_LIBC_LOCK_RECURSIVE_INITIALIZER
;

	)

85 #define 
	#_LIBC_LOCK_RECURSIVE_INITIALIZER
 \

86 {
PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
}

	)

88 #define 
	#__rtld_lock_define_initialized_recursive
(
CLASS
,
NAME
) \

89 
CLASS
 
__rtld_lock_recursive_t
 
NAME
 = 
_RTLD_LOCK_RECURSIVE_INITIALIZER
;

	)

90 #define 
	#_RTLD_LOCK_RECURSIVE_INITIALIZER
 \

91 {
PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
}

	)

93 #if 
defined
 
__PIC__


94 #define 
	#__libc_maybe_call
(
FUNC
, 
ARGS
, 
ELSE
) \

95 (
	`__extension__
 ({ 
	`__typeof
 (
FUNC
) *
_fn
 = (FUNC); \

96 
_fn
 != 
NULL
 ? (*_fn) 
ARGS
 : 
ELSE
; }))

	)

98 #define 
	#__libc_maybe_call
(
FUNC
, 
ARGS
, 
ELSE
) \

99 (
FUNC
 != 
NULL
 ? FUNC 
ARGS
 : 
ELSE
)

	)

101 #define 
	#__libc_maybe_call2
(
FUNC
, 
ARGS
, 
ELSE
) 
	`__libc_maybe_call
 (
__
##FUNC, ARGS, ELSE)

	)

105 #define 
	#__libc_lock_init
(
NAME
) \

106 (
	`__libc_maybe_call2
 (
pthread_mutex_init
, (&(
NAME
), 
NULL
), 0))

	)

107 #define 
	#__libc_rwlock_init
(
NAME
) \

108 (
	`__libc_maybe_call
 (
__pthread_rwlock_init
, (&(
NAME
), 
NULL
), 0));

	)

111 #define 
	#__libc_lock_init_recursive
(
NAME
) \

113 if (
__pthread_mutex_init
 != 
NULL
) \

115 
pthread_mutexattr_t
 
__attr
; \

116 
	`__pthread_mutexattr_init
 (&
__attr
); \

117 
	`__pthread_mutexattr_settype
 (&
__attr
, 
PTHREAD_MUTEX_RECURSIVE_NP
); \

118 
	`__pthread_mutex_init
 (&(
NAME
).
mutex
, &
__attr
); \

119 
	`__pthread_mutexattr_destroy
 (&
__attr
); \

121 } while (0);

	)

122 #define 
	#__rtld_lock_init_recursive
(
NAME
) \

123 
	`__libc_lock_init_recursive
 (
NAME
)

	)

128 #define 
	#__libc_lock_fini
(
NAME
) \

129 (
	`__libc_maybe_call2
 (
pthread_mutex_destroy
, (&(
NAME
)), 0));

	)

130 #define 
	#__libc_rwlock_fini
(
NAME
) \

131 (
	`__libc_maybe_call
 (
__pthread_rwlock_destroy
, (&(
NAME
)), 0));

	)

134 #define 
	#__libc_lock_fini_recursive
(
NAME
) 
	`__libc_lock_fini
 ((NAME).
mutex
)

	)

135 #define 
	#__rtld_lock_fini_recursive
(
NAME
) 
	`__libc_lock_fini_recursive
 (NAME)

	)

138 #define 
	#__libc_lock_lock
(
NAME
) \

139 (
	`__libc_maybe_call2
 (
pthread_mutex_lock
, (&(
NAME
)), 0));

	)

140 #define 
	#__libc_rwlock_rdlock
(
NAME
) \

141 (
	`__libc_maybe_call
 (
__pthread_rwlock_rdlock
, (&(
NAME
)), 0));

	)

142 #define 
	#__libc_rwlock_wrlock
(
NAME
) \

143 (
	`__libc_maybe_call
 (
__pthread_rwlock_wrlock
, (&(
NAME
)), 0));

	)

146 #define 
	#__libc_lock_lock_recursive
(
NAME
) 
	`__libc_lock_lock
 ((NAME).
mutex
)

	)

149 #define 
	#__libc_lock_trylock
(
NAME
) \

150 (
	`__libc_maybe_call2
 (
pthread_mutex_trylock
, (&(
NAME
)), 0))

	)

151 #define 
	#__libc_rwlock_tryrdlock
(
NAME
) \

152 (
	`__libc_maybe_call
 (
__pthread_rwlock_tryrdlock
, (&(
NAME
)), 0))

	)

153 #define 
	#__libc_rwlock_trywrlock
(
NAME
) \

154 (
	`__libc_maybe_call
 (
__pthread_rwlock_trywrlock
, (&(
NAME
)), 0))

	)

157 #define 
	#__libc_lock_trylock_recursive
(
NAME
) 
	`__libc_lock_trylock
 ((NAME).
mutex
)

	)

158 #define 
	#__rtld_lock_trylock_recursive
(
NAME
) \

159 
	`__libc_lock_trylock_recursive
 (
NAME
)

	)

162 #define 
	#__libc_lock_unlock
(
NAME
) \

163 (
	`__libc_maybe_call2
 (
pthread_mutex_unlock
, (&(
NAME
)), 0));

	)

164 #define 
	#__libc_rwlock_unlock
(
NAME
) \

165 (
	`__libc_maybe_call
 (
__pthread_rwlock_unlock
, (&(
NAME
)), 0));

	)

168 #define 
	#__libc_lock_unlock_recursive
(
NAME
) 
	`__libc_lock_unlock
 ((NAME).
mutex
)

	)

170 #define 
	#__rtld_lock_lock_recursive
(
NAME
) 
	`__libc_lock_lock_recursive
 (NAME)

	)

171 #define 
	#__rtld_lock_unlock_recursive
(
NAME
) 
	`__libc_lock_unlock_recursive
 (NAME)

	)

174 #if 
PTHREAD_ONCE_INIT
 == 0

177 #define 
	#__libc_once_define
(
CLASS
, 
NAME
) \

178 
CLASS
 
pthread_once_t
 
NAME


	)

180 #define 
	#__libc_once_define
(
CLASS
, 
NAME
) \

181 
CLASS
 
pthread_once_t
 
NAME
 = 
PTHREAD_ONCE_INIT


	)

185 #define 
	#__libc_once
(
ONCE_CONTROL
, 
INIT_FUNCTION
) \

187 if (
__pthread_once
 != 
NULL
) \

188 
	`__pthread_once
 (&(
ONCE_CONTROL
), (
INIT_FUNCTION
)); \

189 else if ((
ONCE_CONTROL
) == 
PTHREAD_ONCE_INIT
) { \

190 
	`INIT_FUNCTION
 (); \

191 (
ONCE_CONTROL
) = 2; \

193 } while (0)

	)

197 #define 
	#__libc_cleanup_region_start
(
DOIT
, 
FCT
, 
ARG
) \

198 { struct 
_pthread_cleanup_buffer
 
_buffer
; \

199 int 
_avail
 = (
DOIT
) && 
_pthread_cleanup_push_defer
 != 
NULL
; \

200 if (
_avail
) { \

201 
	`_pthread_cleanup_push_defer
 (&
_buffer
, (
FCT
), (
ARG
)); \

202 }

	)

205 #define 
	#__libc_cleanup_region_end
(
DOIT
) \

206 if (
_avail
) { \

207 
	`_pthread_cleanup_pop_restore
 (&
_buffer
, (
DOIT
)); \

209 }

	)

212 #define 
	#__libc_cleanup_end
(
DOIT
) \

213 if (
_avail
) { \

214 
	`_pthread_cleanup_pop_restore
 (&
_buffer
, (
DOIT
)); \

215 }

	)

217 #define 
	#__libc_cleanup_push
(
fct
, 
arg
) \

218 { struct 
_pthread_cleanup_buffer
 
_buffer
; \

219 
	`__libc_maybe_call
 (
_pthread_cleanup_push
, (&
_buffer
, (
fct
), (
arg
)), 0)

	)

221 #define 
	#__libc_cleanup_pop
(
execute
) \

222 
	`__libc_maybe_call
 (
_pthread_cleanup_pop
, (&
_buffer
, 
execute
), 0); \

223 }

	)

226 #define 
	#__libc_key_create
(
KEY
, 
DESTRUCTOR
) \

227 (
	`__libc_maybe_call
 (
__pthread_key_create
, (
KEY
, 
DESTRUCTOR
), 1))

	)

230 #define 
	#__libc_getspecific
(
KEY
) \

231 (
	`__libc_maybe_call
 (
__pthread_getspecific
, (
KEY
), 
NULL
))

	)

234 #define 
	#__libc_setspecific
(
KEY
, 
VALUE
) \

235 (
	`__libc_maybe_call
 (
__pthread_setspecific
, (
KEY
, 
VALUE
), 0))

	)

239 #define 
	#__libc_atfork
(
PREPARE
, 
PARENT
, 
CHILD
) \

240 (
	`__libc_maybe_call
 (
__pthread_atfork
, (
PREPARE
, 
PARENT
, 
CHILD
), 0))

	)

242 
__BEGIN_DECLS


244 extern void 
_pthread_cleanup_push_defer
 (struct 
_pthread_cleanup_buffer
 *
__buffer
,

245 void (*
__routine
) (void *),

246 void *
__arg
) 
__THROW
;

248 extern void 
	$_pthread_cleanup_pop_restore
 (struct 
_pthread_cleanup_buffer
 *
__buffer
,

249 int 
__execute
) 
__THROW
;

255 extern int 
	`__pthread_mutex_init
 (
pthread_mutex_t
 *
__mutex
,

256 
__const
 
pthread_mutexattr_t
 *
__mutex_attr
);

258 extern int 
	`__pthread_mutex_destroy
 (
pthread_mutex_t
 *
__mutex
);

260 extern int 
	`__pthread_mutex_trylock
 (
pthread_mutex_t
 *
__mutex
);

262 extern int 
	`__pthread_mutex_lock
 (
pthread_mutex_t
 *
__mutex
);

264 extern int 
	`__pthread_mutex_unlock
 (
pthread_mutex_t
 *
__mutex
);

266 extern int 
	`__pthread_mutexattr_init
 (
pthread_mutexattr_t
 *
__attr
);

268 extern int 
	`__pthread_mutexattr_destroy
 (
pthread_mutexattr_t
 *
__attr
);

270 extern int 
	`__pthread_mutexattr_settype
 (
pthread_mutexattr_t
 *
__attr
,

271 int 
__kind
);

273 #ifdef 
__USE_UNIX98


274 extern int 
	`__pthread_rwlock_init
 (
pthread_rwlock_t
 *
__rwlock
,

275 
__const
 
pthread_rwlockattr_t
 *
__attr
);

277 extern int 
	`__pthread_rwlock_destroy
 (
pthread_rwlock_t
 *
__rwlock
);

279 extern int 
	`__pthread_rwlock_rdlock
 (
pthread_rwlock_t
 *
__rwlock
);

281 extern int 
	`__pthread_rwlock_tryrdlock
 (
pthread_rwlock_t
 *
__rwlock
);

283 extern int 
	`__pthread_rwlock_wrlock
 (
pthread_rwlock_t
 *
__rwlock
);

285 extern int 
	`__pthread_rwlock_trywrlock
 (
pthread_rwlock_t
 *
__rwlock
);

287 extern int 
	`__pthread_rwlock_unlock
 (
pthread_rwlock_t
 *
__rwlock
);

290 extern int 
	`__pthread_key_create
 (
pthread_key_t
 *
__key
,

291 void (*
__destr_function
) (void *));

293 extern int 
	`__pthread_setspecific
 (
pthread_key_t
 
__key
,

294 
__const
 void *
__pointer
);

296 extern void *
	`__pthread_getspecific
 (
pthread_key_t
 
__key
);

298 extern int 
	`__pthread_once
 (
pthread_once_t
 *
__once_control
,

299 void (*
__init_routine
) (void));

301 extern int 
	`__pthread_atfork
 (void (*
__prepare
) (void),

302 void (*
__parent
) (void),

303 void (*
__child
) (void));

305 
__END_DECLS


309 #ifndef 
__NO_WEAK_PTHREAD_ALIASES


310 #pragma 
weak
 
__pthread_mutex_init


311 #pragma 
weak
 
__pthread_mutex_destroy


312 #pragma 
weak
 
__pthread_mutex_lock


313 #pragma 
weak
 
__pthread_mutex_trylock


314 #pragma 
weak
 
__pthread_mutex_unlock


315 #pragma 
weak
 
__pthread_mutexattr_init


316 #pragma 
weak
 
__pthread_mutexattr_destroy


317 #pragma 
weak
 
__pthread_mutexattr_settype


318 #pragma 
weak
 
__pthread_rwlock_destroy


319 #pragma 
weak
 
__pthread_rwlock_rdlock


320 #pragma 
weak
 
__pthread_rwlock_tryrdlock


321 #pragma 
weak
 
__pthread_rwlock_wrlock


322 #pragma 
weak
 
__pthread_rwlock_trywrlock


323 #pragma 
weak
 
__pthread_rwlock_unlock


324 #pragma 
weak
 
__pthread_key_create


325 #pragma 
weak
 
__pthread_setspecific


326 #pragma 
weak
 
__pthread_getspecific


327 #pragma 
weak
 
__pthread_once


328 #pragma 
weak
 
__pthread_initialize


329 #pragma 
weak
 
__pthread_atfork


330 #pragma 
weak
 
_pthread_cleanup_push_defer


331 #pragma 
weak
 
_pthread_cleanup_pop_restore


332 #pragma 
weak
 
_pthread_cleanup_push


333 #pragma 
weak
 
_pthread_cleanup_pop


338 #define 
	#__libc_mutex_unlock
 
__pthread_mutex_unlock


	)

	@/usr/include/bits/select.h

19 #ifndef 
_SYS_SELECT_H


23 #include 
	~<bits/wordsize.h
>

26 #if 
defined
 
__GNUC__
 && __GNUC__ >= 2

28 #if 
__WORDSIZE
 == 64

29 #define 
	#__FD_ZERO_STOS
 "stosq"

	)

31 #define 
	#__FD_ZERO_STOS
 "stosl"

	)

34 #define 
	#__FD_ZERO
(
fdsp
) \

36 int 
__d0
, 
__d1
; \

37 
__asm__
 
	`__volatile__
 ("cld; rep; " 
__FD_ZERO_STOS
 \

38 : "=c" (
__d0
), "=D" (
__d1
) \

39 : "a" (0), "0" (sizeof (
fd_set
) \

40 / sizeof (
__fd_mask
)), \

41 "1" (&
	`__FDS_BITS
 (
fdsp
)[0]) \

43 } while (0)

	)

49 #define 
	#__FD_ZERO
(
set
) \

51 unsigned int 
__i
; \

52 
fd_set
 *
__arr
 = (
set
); \

53 for (
__i
 = 0; __i < sizeof (
fd_set
) / sizeof (
__fd_mask
); ++__i) \

54 
	`__FDS_BITS
 (
__arr
)[
__i
] = 0; \

55 } while (0)

	)

59 #define 
	#__FD_SET
(
d
, 
set
) (
	`__FDS_BITS
 (set)[
	`__FDELT
 (d)] |= 
	`__FDMASK
 (d))

	)

60 #define 
	#__FD_CLR
(
d
, 
set
) (
	`__FDS_BITS
 (set)[
	`__FDELT
 (d)] &= ~
	`__FDMASK
 (d))

	)

61 #define 
	#__FD_ISSET
(
d
, 
set
) \

62 ((
	`__FDS_BITS
 (
set
)[
	`__FDELT
 (
d
)] & 
	`__FDMASK
 (d)) != 0)

	)

	@/usr/include/bits/sigset.h

21 #ifndef 
_SIGSET_H_types


22 #define 
	#_SIGSET_H_types
 1

	)

24 typedef int 
	t__sig_atomic_t
;

28 #define 
	#_SIGSET_NWORDS
 (1024 / (8 * sizeof (unsigned long int)))

	)

31 unsigned long int 
	m__val
[
_SIGSET_NWORDS
];

32 } 
	t__sigset_t
;

43 #if !
defined
 
_SIGSET_H_fns
 && defined 
_SIGNAL_H


44 #define 
	#_SIGSET_H_fns
 1

	)

46 #ifndef 
_EXTERN_INLINE


47 #define 
	#_EXTERN_INLINE
 
__extern_inline


	)

51 #define 
	#__sigmask
(
sig
) \

52 (((unsigned long int) 1) << (((
sig
) - 1) % (8 * sizeof (unsigned long int))))

	)

55 #define 
	#__sigword
(
sig
) (((sig) - 1) / (8 * sizeof (unsigned long int)))

	)

57 #if 
defined
 
__GNUC__
 && __GNUC__ >= 2

58 #define 
	#__sigemptyset
(
set
) \

59 (
	`__extension__
 ({ int 
__cnt
 = 
_SIGSET_NWORDS
; \

60 
sigset_t
 *
__set
 = (
set
); \

61 while (--
__cnt
 >= 0) 
__set
->
__val
[__cnt] = 0; \

62 0; }))

	)

63 #define 
	#__sigfillset
(
set
) \

64 (
	`__extension__
 ({ int 
__cnt
 = 
_SIGSET_NWORDS
; \

65 
sigset_t
 *
__set
 = (
set
); \

66 while (--
__cnt
 >= 0) 
__set
->
__val
[__cnt] = ~0UL; \

67 0; }))

	)

69 #ifdef 
__USE_GNU


73 #define 
	#__sigisemptyset
(
set
) \

74 (
	`__extension__
 ({ int 
__cnt
 = 
_SIGSET_NWORDS
; \

75 const 
sigset_t
 *
__set
 = (
set
); \

76 int 
__ret
 = 
__set
->
__val
[--
__cnt
]; \

77 while (!
__ret
 && --
__cnt
 >= 0) \

78 
__ret
 = 
__set
->
__val
[
__cnt
]; \

79 
__ret
 == 0; }))

	)

80 #define 
	#__sigandset
(
dest
, 
left
, 
right
) \

81 (
	`__extension__
 ({ int 
__cnt
 = 
_SIGSET_NWORDS
; \

82 
sigset_t
 *
__dest
 = (
dest
); \

83 const 
sigset_t
 *
__left
 = (
left
); \

84 const 
sigset_t
 *
__right
 = (
right
); \

85 while (--
__cnt
 >= 0) \

86 
__dest
->
__val
[
__cnt
] = (
__left
->__val[__cnt] \

87 & 
__right
->
__val
[
__cnt
]); \

88 0; }))

	)

89 #define 
	#__sigorset
(
dest
, 
left
, 
right
) \

90 (
	`__extension__
 ({ int 
__cnt
 = 
_SIGSET_NWORDS
; \

91 
sigset_t
 *
__dest
 = (
dest
); \

92 const 
sigset_t
 *
__left
 = (
left
); \

93 const 
sigset_t
 *
__right
 = (
right
); \

94 while (--
__cnt
 >= 0) \

95 
__dest
->
__val
[
__cnt
] = (
__left
->__val[__cnt] \

96 | 
__right
->
__val
[
__cnt
]); \

97 0; }))

	)

104 extern int 
__sigismember
 (
__const
 
__sigset_t
 *, int);

105 extern int 
__sigaddset
 (
__sigset_t
 *, int);

106 extern int 
__sigdelset
 (
__sigset_t
 *, int);

108 #ifdef 
__USE_EXTERN_INLINES


109 #define 
	#__SIGSETFN
(
NAME
, 
BODY
, 
CONST
) \

110 
_EXTERN_INLINE
 int \

111 
	`NAME
 (
CONST
 
__sigset_t
 *
__set
, int 
__sig
) \

113 unsigned long int 
__mask
 = 
	`__sigmask
 (
__sig
); \

114 unsigned long int 
__word
 = 
	`__sigword
 (
__sig
); \

115 return 
BODY
; \

116 }

	)

118 
__SIGSETFN
 (
__sigismember
, (
__set
->
__val
[
__word
] & 
__mask
) ? 1 : 0, 
__const
)

119 
__SIGSETFN
 (
__sigaddset
, ((
__set
->
__val
[
__word
] |= 
__mask
), 0), )

120 
__SIGSETFN
 (
__sigdelset
, ((
__set
->
__val
[
__word
] &= ~
__mask
), 0), )

122 #undef 
__SIGSETFN


	@/usr/include/bits/time.h

24 #ifndef 
__need_timeval


25 #ifndef 
_BITS_TIME_H


26 #define 
	#_BITS_TIME_H
 1

	)

34 #define 
	#CLOCKS_PER_SEC
 1000000l

	)

36 #if !
defined
 
__STRICT_ANSI__
 && !defined 
__USE_XOPEN2K


39 #include 
	~<bits/types.h
>

40 extern long int 
__sysconf
 (int);

41 #define 
	#CLK_TCK
 ((
__clock_t
) 
	`__sysconf
 (2))

	)

44 #ifdef 
__USE_POSIX199309


46 #define 
	#CLOCK_REALTIME
 0

	)

48 #define 
	#CLOCK_MONOTONIC
 1

	)

50 #define 
	#CLOCK_PROCESS_CPUTIME_ID
 2

	)

52 #define 
	#CLOCK_THREAD_CPUTIME_ID
 3

	)

54 #define 
	#CLOCK_MONOTONIC_RAW
 4

	)

56 #define 
	#CLOCK_REALTIME_COARSE
 5

	)

58 #define 
	#CLOCK_MONOTONIC_COARSE
 6

	)

61 #define 
	#TIMER_ABSTIME
 1

	)

67 #ifdef 
__need_timeval


68 #undef 
__need_timeval


69 #ifndef 
_STRUCT_TIMEVAL


70 #define 
	#_STRUCT_TIMEVAL
 1

	)

71 #include 
	~<bits/types.h
>

75 struct 
	stimeval


77 
__time_t
 
	mtv_sec
;

78 
__suseconds_t
 
	mtv_usec
;

	@/usr/include/gconv.h

23 #ifndef 
_GCONV_H


24 #define 
	#_GCONV_H
 1

	)

26 #include 
	~<features.h
>

27 #define 
	#__need_mbstate_t


	)

28 #define 
	#__need_wint_t


	)

29 #include 
	~<wchar.h
>

30 #define 
	#__need_size_t


	)

31 #define 
	#__need_wchar_t


	)

32 #include 
	~<stddef.h
>

35 #define 
	#__UNKNOWN_10646_CHAR
 ((
wchar_t
) 0xfffd)

	)

40 
	m__GCONV_OK
 = 0,

41 
	m__GCONV_NOCONV
,

42 
	m__GCONV_NODB
,

43 
	m__GCONV_NOMEM
,

45 
	m__GCONV_EMPTY_INPUT
,

46 
	m__GCONV_FULL_OUTPUT
,

47 
	m__GCONV_ILLEGAL_INPUT
,

48 
	m__GCONV_INCOMPLETE_INPUT
,

50 
	m__GCONV_ILLEGAL_DESCRIPTOR
,

51 
	m__GCONV_INTERNAL_ERROR


58 
	m__GCONV_IS_LAST
 = 0x0001,

59 
	m__GCONV_IGNORE_ERRORS
 = 0x0002

64 struct 
	g__gconv_step
;

65 struct 
	g__gconv_step_data
;

66 struct 
	g__gconv_loaded_object
;

67 struct 
	g__gconv_trans_data
;

71 typedef int (*
	t__gconv_fct
) (struct 
	t__gconv_step
 *, struct 
	t__gconv_step_data
 *,

72 
	t__const
 unsigned char **, __const unsigned char *,

73 unsigned char **, 
	tsize_t
 *, int, int);

76 typedef 
	$wint_t
 (*
	t__gconv_btowc_fct
) (struct 
	t__gconv_step
 *, unsigned char);

79 typedef int (*
	t__gconv_init_fct
) (struct 
	t__gconv_step
 *);

80 typedef void (*
	t__gconv_end_fct
) (struct 
	t__gconv_step
 *);

84 typedef int (*
	t__gconv_trans_fct
) (struct 
	t__gconv_step
 *,

85 struct 
	t__gconv_step_data
 *, void *,

86 
	t__const
 unsigned char *,

87 
	t__const
 unsigned char **,

88 
	t__const
 unsigned char *, unsigned char **,

89 
	tsize_t
 *);

92 typedef int (*
	t__gconv_trans_context_fct
) (void *, 
	t__const
 unsigned char *,

93 
	t__const
 unsigned char *,

97 typedef int (*
	t__gconv_trans_query_fct
) (
	t__const
 char *, __const char ***,

98 
	tsize_t
 *);

101 typedef int (*
	t__gconv_trans_init_fct
) (void **, const char *);

102 typedef void (*
	t__gconv_trans_end_fct
) (void *);

104 struct 
	s__gconv_trans_data


107 
__gconv_trans_fct
 
__trans_fct
;

108 
__gconv_trans_context_fct
 
__trans_context_fct
;

109 
__gconv_trans_end_fct
 
__trans_end_fct
;

110 void *
__data
;

111 struct 
__gconv_trans_data
 *
__next
;

116 struct 
	s__gconv_step


118 struct 
__gconv_loaded_object
 *
__shlib_handle
;

119 
__const
 char *
__modname
;

121 int 
__counter
;

123 char *
__from_name
;

124 char *
__to_name
;

126 
__gconv_fct
 
__fct
;

127 
__gconv_btowc_fct
 
__btowc_fct
;

128 
__gconv_init_fct
 
__init_fct
;

129 
__gconv_end_fct
 
__end_fct
;

133 int 
__min_needed_from
;

134 int 
__max_needed_from
;

135 int 
__min_needed_to
;

136 int 
__max_needed_to
;

139 int 
__stateful
;

141 void *
__data
;

146 struct 
	s__gconv_step_data


148 unsigned char *
__outbuf
;

149 unsigned char *
__outbufend
;

153 int 
__flags
;

157 int 
__invocation_counter
;

161 int 
__internal_use
;

163 
__mbstate_t
 *
__statep
;

164 
__mbstate_t
 
__state
;

168 struct 
__gconv_trans_data
 *
__trans
;

173 typedef struct 
	s__gconv_info


175 
size_t
 
__nsteps
;

176 struct 
__gconv_step
 *
__steps
;

177 
__extension__
 struct 
__gconv_step_data
 
__data
 
__flexarr
;

178 } *
	t__gconv_t
;

	@/usr/include/gnu/stubs-32.h

6 #ifdef 
_LIBC


7 #error 
Applications
 
may
 
not
 
define
 
the
 
macro
 
_LIBC


10 #define 
	#__stub___kernel_cosl


	)

11 #define 
	#__stub___kernel_sinl


	)

12 #define 
	#__stub___kernel_tanl


	)

13 #define 
	#__stub_chflags


	)

14 #define 
	#__stub_fattach


	)

15 #define 
	#__stub_fchflags


	)

16 #define 
	#__stub_fdetach


	)

17 #define 
	#__stub_gtty


	)

18 #define 
	#__stub_lchmod


	)

19 #define 
	#__stub_revoke


	)

20 #define 
	#__stub_setlogin


	)

21 #define 
	#__stub_sigreturn


	)

22 #define 
	#__stub_sstk


	)

23 #define 
	#__stub_stty


	)

	@/usr/include/gnu/stubs-64.h

6 #ifdef 
_LIBC


7 #error 
Applications
 
may
 
not
 
define
 
the
 
macro
 
_LIBC


10 #define 
	#__stub_bdflush


	)

11 #define 
	#__stub_chflags


	)

12 #define 
	#__stub_fattach


	)

13 #define 
	#__stub_fchflags


	)

14 #define 
	#__stub_fdetach


	)

15 #define 
	#__stub_getmsg


	)

16 #define 
	#__stub_gtty


	)

17 #define 
	#__stub_lchmod


	)

18 #define 
	#__stub_putmsg


	)

19 #define 
	#__stub_revoke


	)

20 #define 
	#__stub_setlogin


	)

21 #define 
	#__stub_sigreturn


	)

22 #define 
	#__stub_sstk


	)

23 #define 
	#__stub_stty


	)

	@/usr/include/wchar.h

24 #ifndef 
_WCHAR_H


26 #if !
defined
 
__need_mbstate_t
 && !defined 
__need_wint_t


27 #define 
	#_WCHAR_H
 1

	)

28 #include 
	~<features.h
>

31 #ifdef 
_WCHAR_H


33 #define 
	#__need___FILE


	)

34 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K


35 #define 
	#__need_FILE


	)

37 #include 
	~<stdio.h
>

39 #define 
	#__need___va_list


	)

40 #include 
	~<stdarg.h
>

42 #include 
	~<bits/wchar.h
>

45 #define 
	#__need_size_t


	)

46 #define 
	#__need_wchar_t


	)

47 #define 
	#__need_NULL


	)

49 #if 
defined
 
_WCHAR_H
 || defined 
__need_wint_t
 || !defined 
__WINT_TYPE__


50 #undef 
__need_wint_t


51 #define 
	#__need_wint_t


	)

52 #include 
	~<stddef.h
>

56 #ifndef 
_WINT_T


61 #define 
	#_WINT_T


	)

62 typedef unsigned int 
	twint_t
;

66 #if 
defined
 
__cplusplus
 && defined 
_GLIBCPP_USE_NAMESPACES
 \

67 && 
defined
 
__WINT_TYPE__


68 
__BEGIN_NAMESPACE_STD


69 typedef 
__WINT_TYPE__
 
	twint_t
;

70 
	g__END_NAMESPACE_STD


75 #if 
defined
 
__cplusplus
 && 
__GNUC_PREREQ
 (4, 4)

76 #define 
	#__CORRECT_ISO_CPP_WCHAR_H_PROTO


	)

80 #if (
defined
 
_WCHAR_H
 || defined 
__need_mbstate_t
) && !defined 
__mbstate_t_defined


81 #define 
	#__mbstate_t_defined
 1

	)

85 int 
	m__count
;

88 #ifdef 
__WINT_TYPE__


89 
__WINT_TYPE__
 
	m__wch
;

91 
wint_t
 
	m__wch
;

93 char 
	m__wchb
[4];

94 } 
	m__value
;

95 } 
	t__mbstate_t
;

97 #undef 
__need_mbstate_t


102 #ifdef 
_WCHAR_H


104 
__BEGIN_NAMESPACE_C99


106 typedef 
__mbstate_t
 
	tmbstate_t
;

107 
	g__END_NAMESPACE_C99


108 #ifdef 
__USE_GNU


109 
	$__USING_NAMESPACE_C99
(
mbstate_t
)

112 #ifndef 
WCHAR_MIN


114 #define 
	#WCHAR_MIN
 
__WCHAR_MIN


	)

115 #define 
	#WCHAR_MAX
 
__WCHAR_MAX


	)

118 #ifndef 
WEOF


119 #define 
	#WEOF
 (0xffffffffu)

	)

124 #if 
defined
 
__USE_XOPEN
 && !defined 
__USE_UNIX98


125 #include 
	~<wctype.h
>

129 
__BEGIN_DECLS


131 
__BEGIN_NAMESPACE_STD


134 struct 
tm
;

135 
__END_NAMESPACE_STD


139 
	$__USING_NAMESPACE_STD
(
tm
)

142 
__BEGIN_NAMESPACE_STD


144 extern 
wchar_t
 *
	$wcscpy
 (
wchar_t
 *
__restrict
 
__dest
,

145 
__const
 
wchar_t
 *
__restrict
 
__src
) 
__THROW
;

147 extern 
wchar_t
 *
	$wcsncpy
 (
wchar_t
 *
__restrict
 
__dest
,

148 
__const
 
wchar_t
 *
__restrict
 
__src
, 
size_t
 
__n
)

149 
__THROW
;

152 extern 
wchar_t
 *
	$wcscat
 (
wchar_t
 *
__restrict
 
__dest
,

153 
__const
 
wchar_t
 *
__restrict
 
__src
) 
__THROW
;

155 extern 
wchar_t
 *
	$wcsncat
 (
wchar_t
 *
__restrict
 
__dest
,

156 
__const
 
wchar_t
 *
__restrict
 
__src
, 
size_t
 
__n
)

157 
__THROW
;

160 extern int 
	$wcscmp
 (
__const
 
wchar_t
 *
__s1
, __const wchar_t *
__s2
)

161 
__THROW
 
__attribute_pure__
;

163 extern int 
	$wcsncmp
 (
__const
 
wchar_t
 *
__s1
, __const wchar_t *
__s2
, 
size_t
 
__n
)

164 
__THROW
 
__attribute_pure__
;

165 
__END_NAMESPACE_STD


167 #ifdef 
__USE_XOPEN2K8


169 extern int 
	$wcscasecmp
 (
__const
 
wchar_t
 *
__s1
, __const wchar_t *
__s2
) 
__THROW
;

172 extern int 
	$wcsncasecmp
 (
__const
 
wchar_t
 *
__s1
, __const wchar_t *
__s2
,

173 
size_t
 
__n
) 
__THROW
;

177 #include 
	~<xlocale.h
>

179 extern int 
	$wcscasecmp_l
 (
__const
 
wchar_t
 *
__s1
, __const wchar_t *
__s2
,

180 
__locale_t
 
__loc
) 
__THROW
;

182 extern int 
	$wcsncasecmp_l
 (
__const
 
wchar_t
 *
__s1
, __const wchar_t *
__s2
,

183 
size_t
 
__n
, 
__locale_t
 
__loc
) 
__THROW
;

186 
__BEGIN_NAMESPACE_STD


189 extern int 
	$wcscoll
 (
__const
 
wchar_t
 *
__s1
, __const wchar_t *
__s2
) 
__THROW
;

193 extern 
size_t
 
	$wcsxfrm
 (
wchar_t
 *
__restrict
 
__s1
,

194 
__const
 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
) 
__THROW
;

195 
__END_NAMESPACE_STD


197 #ifdef 
__USE_XOPEN2K8


203 extern int 
	$wcscoll_l
 (
__const
 
wchar_t
 *
__s1
, __const wchar_t *
__s2
,

204 
__locale_t
 
__loc
) 
__THROW
;

209 extern 
size_t
 
	$wcsxfrm_l
 (
wchar_t
 *
__s1
, 
__const
 wchar_t *
__s2
,

210 
size_t
 
__n
, 
__locale_t
 
__loc
) 
__THROW
;

213 extern 
wchar_t
 *
	$wcsdup
 (
__const
 
wchar_t
 *
__s
) 
__THROW
 
__attribute_malloc__
;

216 
__BEGIN_NAMESPACE_STD


218 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


219 extern "C++" 
wchar_t
 *
	$wcschr
 (
wchar_t
 *
__wcs
, wchar_t 
__wc
)

220 
__THROW
 
	`__asm
 ("wcschr") 
__attribute_pure__
;

221 extern "C++" 
__const
 
wchar_t
 *
	$wcschr
 (
__const
 
wchar_t
 *
__wcs
, wchar_t 
__wc
)

222 
__THROW
 
	`__asm
 ("wcschr") 
__attribute_pure__
;

224 extern 
wchar_t
 *
	$wcschr
 (
__const
 
wchar_t
 *
__wcs
, wchar_t 
__wc
)

225 
__THROW
 
__attribute_pure__
;

228 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


229 extern "C++" 
wchar_t
 *
	$wcsrchr
 (
wchar_t
 *
__wcs
, wchar_t 
__wc
)

230 
__THROW
 
	`__asm
 ("wcsrchr") 
__attribute_pure__
;

231 extern "C++" 
__const
 
wchar_t
 *
	$wcsrchr
 (
__const
 
wchar_t
 *
__wcs
, wchar_t 
__wc
)

232 
__THROW
 
	`__asm
 ("wcsrchr") 
__attribute_pure__
;

234 extern 
wchar_t
 *
	$wcsrchr
 (
__const
 
wchar_t
 *
__wcs
, wchar_t 
__wc
)

235 
__THROW
 
__attribute_pure__
;

237 
__END_NAMESPACE_STD


239 #ifdef 
__USE_GNU


242 extern 
wchar_t
 *
	$wcschrnul
 (
__const
 
wchar_t
 *
__s
, wchar_t 
__wc
)

243 
__THROW
 
__attribute_pure__
;

246 
__BEGIN_NAMESPACE_STD


249 extern 
size_t
 
	$wcscspn
 (
__const
 
wchar_t
 *
__wcs
, __const wchar_t *
__reject
)

250 
__THROW
 
__attribute_pure__
;

253 extern 
size_t
 
	$wcsspn
 (
__const
 
wchar_t
 *
__wcs
, __const wchar_t *
__accept
)

254 
__THROW
 
__attribute_pure__
;

256 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


257 extern "C++" 
wchar_t
 *
	$wcspbrk
 (
wchar_t
 *
__wcs
, 
__const
 wchar_t *
__accept
)

258 
__THROW
 
	`__asm
 ("wcspbrk") 
__attribute_pure__
;

259 extern "C++" 
__const
 
wchar_t
 *
	$wcspbrk
 (
__const
 
wchar_t
 *
__wcs
,

260 
__const
 
wchar_t
 *
__accept
)

261 
__THROW
 
	`__asm
 ("wcspbrk") 
__attribute_pure__
;

263 extern 
wchar_t
 *
	$wcspbrk
 (
__const
 
wchar_t
 *
__wcs
, __const wchar_t *
__accept
)

264 
__THROW
 
__attribute_pure__
;

267 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


268 extern "C++" 
wchar_t
 *
	$wcsstr
 (
wchar_t
 *
__haystack
, 
__const
 wchar_t *
__needle
)

269 
__THROW
 
	`__asm
 ("wcsstr") 
__attribute_pure__
;

270 extern "C++" 
__const
 
wchar_t
 *
	$wcsstr
 (
__const
 
wchar_t
 *
__haystack
,

271 
__const
 
wchar_t
 *
__needle
)

272 
__THROW
 
	`__asm
 ("wcsstr") 
__attribute_pure__
;

274 extern 
wchar_t
 *
	$wcsstr
 (
__const
 
wchar_t
 *
__haystack
, __const wchar_t *
__needle
)

275 
__THROW
 
__attribute_pure__
;

279 extern 
wchar_t
 *
	$wcstok
 (
wchar_t
 *
__restrict
 
__s
,

280 
__const
 
wchar_t
 *
__restrict
 
__delim
,

281 
wchar_t
 **
__restrict
 
__ptr
) 
__THROW
;

284 extern 
size_t
 
	$wcslen
 (
__const
 
wchar_t
 *
__s
) 
__THROW
 
__attribute_pure__
;

285 
__END_NAMESPACE_STD


287 #ifdef 
__USE_XOPEN


289 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


290 extern "C++" 
wchar_t
 *
	$wcswcs
 (
wchar_t
 *
__haystack
, 
__const
 wchar_t *
__needle
)

291 
__THROW
 
	`__asm
 ("wcswcs") 
__attribute_pure__
;

292 extern "C++" 
__const
 
wchar_t
 *
	$wcswcs
 (
__const
 
wchar_t
 *
__haystack
,

293 
__const
 
wchar_t
 *
__needle
)

294 
__THROW
 
	`__asm
 ("wcswcs") 
__attribute_pure__
;

296 extern 
wchar_t
 *
	$wcswcs
 (
__const
 
wchar_t
 *
__haystack
, __const wchar_t *
__needle
)

297 
__THROW
 
__attribute_pure__
;

301 #ifdef 
__USE_XOPEN2K8


303 extern 
size_t
 
	$wcsnlen
 (
__const
 
wchar_t
 *
__s
, 
size_t
 
__maxlen
)

304 
__THROW
 
__attribute_pure__
;

308 
__BEGIN_NAMESPACE_STD


310 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


311 extern "C++" 
wchar_t
 *
	$wmemchr
 (
wchar_t
 *
__s
, wchar_t 
__c
, 
size_t
 
__n
)

312 
__THROW
 
	`__asm
 ("wmemchr") 
__attribute_pure__
;

313 extern "C++" 
__const
 
wchar_t
 *
	$wmemchr
 (
__const
 
wchar_t
 *
__s
, wchar_t 
__c
,

314 
size_t
 
__n
)

315 
__THROW
 
	`__asm
 ("wmemchr") 
__attribute_pure__
;

317 extern 
wchar_t
 *
	$wmemchr
 (
__const
 
wchar_t
 *
__s
, wchar_t 
__c
, 
size_t
 
__n
)

318 
__THROW
 
__attribute_pure__
;

322 extern int 
	$wmemcmp
 (
__const
 
wchar_t
 *
__restrict
 
__s1
,

323 
__const
 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
)

324 
__THROW
 
__attribute_pure__
;

327 extern 
wchar_t
 *
	$wmemcpy
 (
wchar_t
 *
__restrict
 
__s1
,

328 
__const
 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
) 
__THROW
;

332 extern 
wchar_t
 *
	$wmemmove
 (
wchar_t
 *
__s1
, 
__const
 wchar_t *
__s2
, 
size_t
 
__n
)

333 
__THROW
;

336 extern 
wchar_t
 *
	$wmemset
 (
wchar_t
 *
__s
, wchar_t 
__c
, 
size_t
 
__n
) 
__THROW
;

337 
__END_NAMESPACE_STD


339 #ifdef 
__USE_GNU


342 extern 
wchar_t
 *
	$wmempcpy
 (
wchar_t
 *
__restrict
 
__s1
,

343 
__const
 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
)

344 
__THROW
;

348 
__BEGIN_NAMESPACE_STD


351 extern 
wint_t
 
	$btowc
 (int 
__c
) 
__THROW
;

355 extern int 
	$wctob
 (
wint_t
 
__c
) 
__THROW
;

359 extern int 
	$mbsinit
 (
__const
 
mbstate_t
 *
__ps
) 
__THROW
 
__attribute_pure__
;

363 extern 
size_t
 
	$mbrtowc
 (
wchar_t
 *
__restrict
 
__pwc
,

364 
__const
 char *
__restrict
 
__s
, 
size_t
 
__n
,

365 
mbstate_t
 *
__p
) 
__THROW
;

368 extern 
size_t
 
	$wcrtomb
 (char *
__restrict
 
__s
, 
wchar_t
 
__wc
,

369 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

372 extern 
size_t
 
	$__mbrlen
 (
__const
 char *
__restrict
 
__s
, 
size_t
 
__n
,

373 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

374 extern 
size_t
 
	$mbrlen
 (
__const
 char *
__restrict
 
__s
, 
size_t
 
__n
,

375 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

376 
__END_NAMESPACE_STD


378 #ifdef 
__USE_EXTERN_INLINES


384 extern 
wint_t
 
	$__btowc_alias
 (int 
__c
) 
	`__asm
 ("btowc");

385 
__extern_inline
 
wint_t


386 
	`__NTH
 (
	$btowc
 (int 
__c
))

387 { return (
	`__builtin_constant_p
 (
__c
) && __c >= '\0' && __c <= '\x7f'

388 ? (
wint_t
) 
__c
 : 
	`__btowc_alias
 (__c)); 
	}
}

390 extern int 
	$__wctob_alias
 (
wint_t
 
__c
) 
	`__asm
 ("wctob");

391 
__extern_inline
 int

392 
	`__NTH
 (
	$wctob
 (
wint_t
 
__wc
))

393 { return (
	`__builtin_constant_p
 (
__wc
) && __wc >= 
L
'\0' && __wc <= L'\x7f'

394 ? (int) 
__wc
 : 
	`__wctob_alias
 (__wc)); 
	}
}

396 
__extern_inline
 
size_t


397 
__NTH
 (
	$mbrlen
 (
__const
 char *
__restrict
 
__s
, 
size_t
 
__n
,

398 
mbstate_t
 *
__restrict
 
__ps
))

399 { return (
__ps
 != 
NULL


400 ? 
	`mbrtowc
 (
NULL
, 
__s
, 
__n
, 
__ps
) : 
	`__mbrlen
 (__s, __n, NULL)); 
	}
}

403 
__BEGIN_NAMESPACE_STD


406 extern 
size_t
 
	$mbsrtowcs
 (
wchar_t
 *
__restrict
 
__dst
,

407 
__const
 char **
__restrict
 
__src
, 
size_t
 
__len
,

408 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

412 extern 
size_t
 
	$wcsrtombs
 (char *
__restrict
 
__dst
,

413 
__const
 
wchar_t
 **
__restrict
 
__src
, 
size_t
 
__len
,

414 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

415 
__END_NAMESPACE_STD


418 #ifdef 
__USE_XOPEN2K8


421 extern 
size_t
 
	$mbsnrtowcs
 (
wchar_t
 *
__restrict
 
__dst
,

422 
__const
 char **
__restrict
 
__src
, 
size_t
 
__nmc
,

423 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

427 extern 
size_t
 
	$wcsnrtombs
 (char *
__restrict
 
__dst
,

428 
__const
 
wchar_t
 **
__restrict
 
__src
,

429 
size_t
 
__nwc
, size_t 
__len
,

430 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

435 #ifdef 
__USE_XOPEN


437 extern int 
	$wcwidth
 (
wchar_t
 
__c
) 
__THROW
;

441 extern int 
	$wcswidth
 (
__const
 
wchar_t
 *
__s
, 
size_t
 
__n
) 
__THROW
;

445 
__BEGIN_NAMESPACE_STD


448 extern double 
	$wcstod
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

449 
wchar_t
 **
__restrict
 
__endptr
) 
__THROW
;

450 
__END_NAMESPACE_STD


452 #ifdef 
__USE_ISOC99


453 
__BEGIN_NAMESPACE_C99


455 extern float 
	$wcstof
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

456 
wchar_t
 **
__restrict
 
__endptr
) 
__THROW
;

457 extern long double 
	$wcstold
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

458 
wchar_t
 **
__restrict
 
__endptr
) 
__THROW
;

459 
__END_NAMESPACE_C99


463 
__BEGIN_NAMESPACE_STD


466 extern long int 
	$wcstol
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

467 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
) 
__THROW
;

471 extern unsigned long int 
	$wcstoul
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

472 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
)

473 
__THROW
;

474 
__END_NAMESPACE_STD


476 #if 
defined
 
__USE_ISOC99
 || (defined 
__GNUC__
 && defined 
__USE_GNU
)

477 
__BEGIN_NAMESPACE_C99


480 
__extension__


481 extern long long int 
	$wcstoll
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

482 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
)

483 
__THROW
;

487 
__extension__


488 extern unsigned long long int 
	$wcstoull
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

489 
wchar_t
 **
__restrict
 
__endptr
,

490 int 
__base
) 
__THROW
;

491 
__END_NAMESPACE_C99


494 #if 
defined
 
__GNUC__
 && defined 
__USE_GNU


497 
__extension__


498 extern long long int 
	$wcstoq
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

499 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
)

500 
__THROW
;

504 
__extension__


505 extern unsigned long long int 
	$wcstouq
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

506 
wchar_t
 **
__restrict
 
__endptr
,

507 int 
__base
) 
__THROW
;

510 #ifdef 
__USE_GNU


524 #include 
	~<xlocale.h
>

528 extern long int 
	$wcstol_l
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

529 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
,

530 
__locale_t
 
__loc
) 
__THROW
;

532 extern unsigned long int 
	$wcstoul_l
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

533 
wchar_t
 **
__restrict
 
__endptr
,

534 int 
__base
, 
__locale_t
 
__loc
) 
__THROW
;

536 
__extension__


537 extern long long int 
	$wcstoll_l
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

538 
wchar_t
 **
__restrict
 
__endptr
,

539 int 
__base
, 
__locale_t
 
__loc
) 
__THROW
;

541 
__extension__


542 extern unsigned long long int 
	$wcstoull_l
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

543 
wchar_t
 **
__restrict
 
__endptr
,

544 int 
__base
, 
__locale_t
 
__loc
)

545 
__THROW
;

547 extern double 
	$wcstod_l
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

548 
wchar_t
 **
__restrict
 
__endptr
, 
__locale_t
 
__loc
)

549 
__THROW
;

551 extern float 
	$wcstof_l
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

552 
wchar_t
 **
__restrict
 
__endptr
, 
__locale_t
 
__loc
)

553 
__THROW
;

555 extern long double 
	$wcstold_l
 (
__const
 
wchar_t
 *
__restrict
 
__nptr
,

556 
wchar_t
 **
__restrict
 
__endptr
,

557 
__locale_t
 
__loc
) 
__THROW
;

562 extern 
wchar_t
 *
	$wcpcpy
 (
wchar_t
 *
__restrict
 
__dest
,

563 
__const
 
wchar_t
 *
__restrict
 
__src
) 
__THROW
;

567 extern 
wchar_t
 *
	$wcpncpy
 (
wchar_t
 *
__restrict
 
__dest
,

568 
__const
 
wchar_t
 *
__restrict
 
__src
, 
size_t
 
__n
)

569 
__THROW
;

575 #ifdef 
__USE_XOPEN2K8


578 extern 
__FILE
 *
	$open_wmemstream
 (
wchar_t
 **
__bufloc
, 
size_t
 *
__sizeloc
) 
__THROW
;

581 #if 
defined
 
__USE_ISOC95
 || defined 
__USE_UNIX98


582 
__BEGIN_NAMESPACE_STD


585 extern int 
	$fwide
 (
__FILE
 *
__fp
, int 
__mode
) 
__THROW
;

592 extern int 
	`fwprintf
 (
__FILE
 *
__restrict
 
__stream
,

593 
__const
 
wchar_t
 *
__restrict
 
__format
, ...)

599 extern int 
	`wprintf
 (
__const
 
wchar_t
 *
__restrict
 
__format
, ...)

602 extern int 
	$swprintf
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

603 
__const
 
wchar_t
 *
__restrict
 
__format
, ...)

604 
__THROW
 ;

610 extern int 
	`vfwprintf
 (
__FILE
 *
__restrict
 
__s
,

611 
__const
 
wchar_t
 *
__restrict
 
__format
,

612 
__gnuc_va_list
 
__arg
)

618 extern int 
	`vwprintf
 (
__const
 
wchar_t
 *
__restrict
 
__format
,

619 
__gnuc_va_list
 
__arg
)

623 extern int 
	$vswprintf
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

624 
__const
 
wchar_t
 *
__restrict
 
__format
,

625 
__gnuc_va_list
 
__arg
)

626 
__THROW
 ;

633 extern int 
	`fwscanf
 (
__FILE
 *
__restrict
 
__stream
,

634 
__const
 
wchar_t
 *
__restrict
 
__format
, ...)

640 extern int 
	`wscanf
 (
__const
 
wchar_t
 *
__restrict
 
__format
, ...)

643 extern int 
	$swscanf
 (
__const
 
wchar_t
 *
__restrict
 
__s
,

644 
__const
 
wchar_t
 *
__restrict
 
__format
, ...)

645 
__THROW
 ;

647 #if 
defined
 
__USE_ISOC99
 && !defined 
__USE_GNU
 \

648 && (!
defined
 
__LDBL_COMPAT
 || !defined 
__REDIRECT
) \

649 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

650 #ifdef 
__REDIRECT


654 extern int 
	`__REDIRECT
 (
fwscanf
, (
__FILE
 *
__restrict
 
__stream
,

655 
__const
 
wchar_t
 *
__restrict
 
__format
, ...),

656 
__isoc99_fwscanf
)

658 extern int 
	`__REDIRECT
 (
wscanf
, (
__const
 
wchar_t
 *
__restrict
 
__format
, ...),

659 
__isoc99_wscanf
)

661 extern int 
	`__REDIRECT
 (
swscanf
, (
__const
 
wchar_t
 *
__restrict
 
__s
,

662 
__const
 
wchar_t
 *
__restrict
 
__format
, ...),

663 
__isoc99_swscanf
)

664 
__THROW
 ;

666 extern int 
	`__isoc99_fwscanf
 (
__FILE
 *
__restrict
 
__stream
,

667 
__const
 
wchar_t
 *
__restrict
 
__format
, ...);

668 extern int 
	`__isoc99_wscanf
 (
__const
 
wchar_t
 *
__restrict
 
__format
, ...);

669 extern int 
	$__isoc99_swscanf
 (
__const
 
wchar_t
 *
__restrict
 
__s
,

670 
__const
 
wchar_t
 *
__restrict
 
__format
, ...)

671 
__THROW
;

672 #define 
	#fwscanf
 
__isoc99_fwscanf


	)

673 #define 
	#wscanf
 
__isoc99_wscanf


	)

674 #define 
	#swscanf
 
__isoc99_swscanf


	)

678 
__END_NAMESPACE_STD


681 #ifdef 
__USE_ISOC99


682 
__BEGIN_NAMESPACE_C99


687 extern int 
	`vfwscanf
 (
__FILE
 *
__restrict
 
__s
,

688 
__const
 
wchar_t
 *
__restrict
 
__format
,

689 
__gnuc_va_list
 
__arg
)

695 extern int 
	`vwscanf
 (
__const
 
wchar_t
 *
__restrict
 
__format
,

696 
__gnuc_va_list
 
__arg
)

699 extern int 
	$vswscanf
 (
__const
 
wchar_t
 *
__restrict
 
__s
,

700 
__const
 
wchar_t
 *
__restrict
 
__format
,

701 
__gnuc_va_list
 
__arg
)

702 
__THROW
 ;

704 #if !
defined
 
__USE_GNU
 \

705 && (!
defined
 
__LDBL_COMPAT
 || !defined 
__REDIRECT
) \

706 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

707 #ifdef 
__REDIRECT


708 extern int 
	`__REDIRECT
 (
vfwscanf
, (
__FILE
 *
__restrict
 
__s
,

709 
__const
 
wchar_t
 *
__restrict
 
__format
,

710 
__gnuc_va_list
 
__arg
), 
__isoc99_vfwscanf
)

712 extern int 
	`__REDIRECT
 (
vwscanf
, (
__const
 
wchar_t
 *
__restrict
 
__format
,

713 
__gnuc_va_list
 
__arg
), 
__isoc99_vwscanf
)

715 extern int 
	`__REDIRECT
 (
vswscanf
, (
__const
 
wchar_t
 *
__restrict
 
__s
,

716 
__const
 
wchar_t
 *
__restrict
 
__format
,

717 
__gnuc_va_list
 
__arg
), 
__isoc99_vswscanf
)

718 
__THROW
 ;

720 extern int 
	`__isoc99_vfwscanf
 (
__FILE
 *
__restrict
 
__s
,

721 
__const
 
wchar_t
 *
__restrict
 
__format
,

722 
__gnuc_va_list
 
__arg
);

723 extern int 
	`__isoc99_vwscanf
 (
__const
 
wchar_t
 *
__restrict
 
__format
,

724 
__gnuc_va_list
 
__arg
);

725 extern int 
	$__isoc99_vswscanf
 (
__const
 
wchar_t
 *
__restrict
 
__s
,

726 
__const
 
wchar_t
 *
__restrict
 
__format
,

727 
__gnuc_va_list
 
__arg
) 
__THROW
;

728 #define 
	#vfwscanf
 
__isoc99_vfwscanf


	)

729 #define 
	#vwscanf
 
__isoc99_vwscanf


	)

730 #define 
	#vswscanf
 
__isoc99_vswscanf


	)

734 
__END_NAMESPACE_C99


738 
__BEGIN_NAMESPACE_STD


743 extern 
wint_t
 
	`fgetwc
 (
__FILE
 *
__stream
);

744 extern 
wint_t
 
	`getwc
 (
__FILE
 *
__stream
);

750 extern 
wint_t
 
	`getwchar
 (void);

757 extern 
wint_t
 
	`fputwc
 (
wchar_t
 
__wc
, 
__FILE
 *
__stream
);

758 extern 
wint_t
 
	`putwc
 (
wchar_t
 
__wc
, 
__FILE
 *
__stream
);

764 extern 
wint_t
 
	`putwchar
 (
wchar_t
 
__wc
);

772 extern 
wchar_t
 *
	`fgetws
 (wchar_t *
__restrict
 
__ws
, int 
__n
,

773 
__FILE
 *
__restrict
 
__stream
);

779 extern int 
	`fputws
 (
__const
 
wchar_t
 *
__restrict
 
__ws
,

780 
__FILE
 *
__restrict
 
__stream
);

787 extern 
wint_t
 
	`ungetwc
 (wint_t 
__wc
, 
__FILE
 *
__stream
);

788 
__END_NAMESPACE_STD


791 #ifdef 
__USE_GNU


799 extern 
wint_t
 
	`getwc_unlocked
 (
__FILE
 *
__stream
);

800 extern 
wint_t
 
	`getwchar_unlocked
 (void);

808 extern 
wint_t
 
	`fgetwc_unlocked
 (
__FILE
 *
__stream
);

816 extern 
wint_t
 
	`fputwc_unlocked
 (
wchar_t
 
__wc
, 
__FILE
 *
__stream
);

825 extern 
wint_t
 
	`putwc_unlocked
 (
wchar_t
 
__wc
, 
__FILE
 *
__stream
);

826 extern 
wint_t
 
	`putwchar_unlocked
 (
wchar_t
 
__wc
);

835 extern 
wchar_t
 *
	`fgetws_unlocked
 (wchar_t *
__restrict
 
__ws
, int 
__n
,

836 
__FILE
 *
__restrict
 
__stream
);

844 extern int 
	`fputws_unlocked
 (
__const
 
wchar_t
 *
__restrict
 
__ws
,

845 
__FILE
 *
__restrict
 
__stream
);

849 
__BEGIN_NAMESPACE_C99


853 extern 
size_t
 
	$wcsftime
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__maxsize
,

854 
__const
 
wchar_t
 *
__restrict
 
__format
,

855 
__const
 struct 
tm
 *
__restrict
 
__tp
) 
__THROW
;

856 
__END_NAMESPACE_C99


858 #ifdef 
__USE_GNU


859 #include 
	~<xlocale.h
>

863 extern 
size_t
 
	$wcsftime_l
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__maxsize
,

864 
__const
 
wchar_t
 *
__restrict
 
__format
,

865 
__const
 struct 
tm
 *
__restrict
 
__tp
,

866 
__locale_t
 
__loc
) 
__THROW
;

875 #if 
defined
 
__USE_UNIX98
 && !defined 
__USE_GNU


876 #define 
	#__need_iswxxx


	)

877 #include 
	~<wctype.h
>

881 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__extern_always_inline


882 #include 
	~<bits/wchar2.h
>

885 #ifdef 
__LDBL_COMPAT


886 #include 
	~<bits/wchar-ldbl.h
>

889 
__END_DECLS


897 #undef 
__need_mbstate_t


898 #undef 
__need_wint_t


	@/usr/include/asm-generic/errno.h

1 #ifndef 
_ASM_GENERIC_ERRNO_H


2 #define 
	#_ASM_GENERIC_ERRNO_H


	)

4 #include 
	~<asm-generic/errno-base.h
>

6 #define 
	#EDEADLK
 35

	)

7 #define 
	#ENAMETOOLONG
 36

	)

8 #define 
	#ENOLCK
 37

	)

9 #define 
	#ENOSYS
 38

	)

10 #define 
	#ENOTEMPTY
 39

	)

11 #define 
	#ELOOP
 40

	)

12 #define 
	#EWOULDBLOCK
 
EAGAIN


	)

13 #define 
	#ENOMSG
 42

	)

14 #define 
	#EIDRM
 43

	)

15 #define 
	#ECHRNG
 44

	)

16 #define 
	#EL2NSYNC
 45

	)

17 #define 
	#EL3HLT
 46

	)

18 #define 
	#EL3RST
 47

	)

19 #define 
	#ELNRNG
 48

	)

20 #define 
	#EUNATCH
 49

	)

21 #define 
	#ENOCSI
 50

	)

22 #define 
	#EL2HLT
 51

	)

23 #define 
	#EBADE
 52

	)

24 #define 
	#EBADR
 53

	)

25 #define 
	#EXFULL
 54

	)

26 #define 
	#ENOANO
 55

	)

27 #define 
	#EBADRQC
 56

	)

28 #define 
	#EBADSLT
 57

	)

30 #define 
	#EDEADLOCK
 
EDEADLK


	)

32 #define 
	#EBFONT
 59

	)

33 #define 
	#ENOSTR
 60

	)

34 #define 
	#ENODATA
 61

	)

35 #define 
	#ETIME
 62

	)

36 #define 
	#ENOSR
 63

	)

37 #define 
	#ENONET
 64

	)

38 #define 
	#ENOPKG
 65

	)

39 #define 
	#EREMOTE
 66

	)

40 #define 
	#ENOLINK
 67

	)

41 #define 
	#EADV
 68

	)

42 #define 
	#ESRMNT
 69

	)

43 #define 
	#ECOMM
 70

	)

44 #define 
	#EPROTO
 71

	)

45 #define 
	#EMULTIHOP
 72

	)

46 #define 
	#EDOTDOT
 73

	)

47 #define 
	#EBADMSG
 74

	)

48 #define 
	#EOVERFLOW
 75

	)

49 #define 
	#ENOTUNIQ
 76

	)

50 #define 
	#EBADFD
 77

	)

51 #define 
	#EREMCHG
 78

	)

52 #define 
	#ELIBACC
 79

	)

53 #define 
	#ELIBBAD
 80

	)

54 #define 
	#ELIBSCN
 81

	)

55 #define 
	#ELIBMAX
 82

	)

56 #define 
	#ELIBEXEC
 83

	)

57 #define 
	#EILSEQ
 84

	)

58 #define 
	#ERESTART
 85

	)

59 #define 
	#ESTRPIPE
 86

	)

60 #define 
	#EUSERS
 87

	)

61 #define 
	#ENOTSOCK
 88

	)

62 #define 
	#EDESTADDRREQ
 89

	)

63 #define 
	#EMSGSIZE
 90

	)

64 #define 
	#EPROTOTYPE
 91

	)

65 #define 
	#ENOPROTOOPT
 92

	)

66 #define 
	#EPROTONOSUPPORT
 93

	)

67 #define 
	#ESOCKTNOSUPPORT
 94

	)

68 #define 
	#EOPNOTSUPP
 95

	)

69 #define 
	#EPFNOSUPPORT
 96

	)

70 #define 
	#EAFNOSUPPORT
 97

	)

71 #define 
	#EADDRINUSE
 98

	)

72 #define 
	#EADDRNOTAVAIL
 99

	)

73 #define 
	#ENETDOWN
 100

	)

74 #define 
	#ENETUNREACH
 101

	)

75 #define 
	#ENETRESET
 102

	)

76 #define 
	#ECONNABORTED
 103

	)

77 #define 
	#ECONNRESET
 104

	)

78 #define 
	#ENOBUFS
 105

	)

79 #define 
	#EISCONN
 106

	)

80 #define 
	#ENOTCONN
 107

	)

81 #define 
	#ESHUTDOWN
 108

	)

82 #define 
	#ETOOMANYREFS
 109

	)

83 #define 
	#ETIMEDOUT
 110

	)

84 #define 
	#ECONNREFUSED
 111

	)

85 #define 
	#EHOSTDOWN
 112

	)

86 #define 
	#EHOSTUNREACH
 113

	)

87 #define 
	#EALREADY
 114

	)

88 #define 
	#EINPROGRESS
 115

	)

89 #define 
	#ESTALE
 116

	)

90 #define 
	#EUCLEAN
 117

	)

91 #define 
	#ENOTNAM
 118

	)

92 #define 
	#ENAVAIL
 119

	)

93 #define 
	#EISNAM
 120

	)

94 #define 
	#EREMOTEIO
 121

	)

95 #define 
	#EDQUOT
 122

	)

97 #define 
	#ENOMEDIUM
 123

	)

98 #define 
	#EMEDIUMTYPE
 124

	)

99 #define 
	#ECANCELED
 125

	)

100 #define 
	#ENOKEY
 126

	)

101 #define 
	#EKEYEXPIRED
 127

	)

102 #define 
	#EKEYREVOKED
 128

	)

103 #define 
	#EKEYREJECTED
 129

	)

106 #define 
	#EOWNERDEAD
 130

	)

107 #define 
	#ENOTRECOVERABLE
 131

	)

109 #define 
	#ERFKILL
 132

	)

111 #define 
	#EHWPOISON
 133

	)

	@/usr/include/bits/wchar-ldbl.h

20 #ifndef 
_WCHAR_H


24 #if 
defined
 
__USE_ISOC95
 || defined 
__USE_UNIX98


25 
__BEGIN_NAMESPACE_C99


26 
__LDBL_REDIR_DECL
 (
fwprintf
);

27 
__LDBL_REDIR_DECL
 (
wprintf
);

28 
__LDBL_REDIR_DECL
 (
swprintf
);

29 
__LDBL_REDIR_DECL
 (
vfwprintf
);

30 
__LDBL_REDIR_DECL
 (
vwprintf
);

31 
__LDBL_REDIR_DECL
 (
vswprintf
);

32 #if 
defined
 
__USE_ISOC99
 && !defined 
__USE_GNU
 \

33 && !
defined
 
	g__REDIRECT
 \

34 && (
defined
 
	g__STRICT_ANSI__
 || defined 
	g__USE_XOPEN2K
)

35 
	$__LDBL_REDIR1_DECL
 (
fwscanf
, 
__nldbl___isoc99_fwscanf
)

36 
	$__LDBL_REDIR1_DECL
 (
wscanf
, 
__nldbl___isoc99_wscanf
)

37 
	$__LDBL_REDIR1_DECL
 (
swscanf
, 
__nldbl___isoc99_swscanf
)

39 
	`__LDBL_REDIR_DECL
 (
fwscanf
);

40 
	`__LDBL_REDIR_DECL
 (
wscanf
);

41 
	`__LDBL_REDIR_DECL
 (
swscanf
);

43 
__END_NAMESPACE_C99


46 #ifdef 
__USE_ISOC99


47 
__BEGIN_NAMESPACE_C99


48 
	`__LDBL_REDIR1_DECL
 (
wcstold
, 
wcstod
);

49 #if !
defined
 
__USE_GNU
 && !defined 
__REDIRECT
 \

50 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

51 
	$__LDBL_REDIR1_DECL
 (
vfwscanf
, 
__nldbl___isoc99_vfwscanf
)

52 
	$__LDBL_REDIR1_DECL
 (
vwscanf
, 
__nldbl___isoc99_vwscanf
)

53 
	$__LDBL_REDIR1_DECL
 (
vswscanf
, 
__nldbl___isoc99_vswscanf
)

55 
	`__LDBL_REDIR_DECL
 (
vfwscanf
);

56 
	`__LDBL_REDIR_DECL
 (
vwscanf
);

57 
	`__LDBL_REDIR_DECL
 (
vswscanf
);

59 
__END_NAMESPACE_C99


62 #ifdef 
__USE_GNU


63 
	`__LDBL_REDIR1_DECL
 (
wcstold_l
, 
wcstod_l
);

66 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__extern_always_inline


67 
	$__LDBL_REDIR_DECL
 (
__swprintf_chk
)

68 
	$__LDBL_REDIR_DECL
 (
__vswprintf_chk
)

69 #if 
__USE_FORTIFY_LEVEL
 > 1

70 
	$__LDBL_REDIR_DECL
 (
__fwprintf_chk
)

71 
	$__LDBL_REDIR_DECL
 (
__wprintf_chk
)

72 
	$__LDBL_REDIR_DECL
 (
__vfwprintf_chk
)

73 
	$__LDBL_REDIR_DECL
 (
__vwprintf_chk
)

	@/usr/include/bits/wchar.h

20 #ifndef 
_BITS_WCHAR_H


21 #define 
	#_BITS_WCHAR_H
 1

	)

23 #define 
	#__WCHAR_MIN
 (-2147483647 - 1)

	)

24 #define 
	#__WCHAR_MAX
 (2147483647)

	)

	@/usr/include/bits/wchar2.h

20 #ifndef 
_WCHAR_H


25 extern 
wchar_t
 *
	$__wmemcpy_chk
 (
wchar_t
 *
__restrict
 
__s1
,

26 
__const
 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
,

27 
size_t
 
__ns1
) 
__THROW
;

28 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wmemcpy_alias
,

29 (
wchar_t
 *
__restrict
 
__s1
,

30 
__const
 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
),

31 
wmemcpy
);

32 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wmemcpy_chk_warn
,

33 (
wchar_t
 *
__restrict
 
__s1
,

34 
__const
 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
,

35 
size_t
 
__ns1
), 
__wmemcpy_chk
)

36 
	`__warnattr
 ("wmemcpy called with length bigger than size of destination "

39 
__extern_always_inline
 
wchar_t
 *

40 
	`__NTH
 (
	$wmemcpy
 (
wchar_t
 *
__restrict
 
__s1
, 
__const
 wchar_t *__restrict 
__s2
,

41 
size_t
 
__n
))

43 if (
	`__bos0
 (
__s1
) != (
size_t
) -1)

45 if (!
	`__builtin_constant_p
 (
__n
))

46 return 
	`__wmemcpy_chk
 (
__s1
, 
__s2
, 
__n
,

47 
	`__bos0
 (
__s1
) / sizeof (
wchar_t
));

49 if (
__n
 > 
	`__bos0
 (
__s1
) / sizeof (
wchar_t
))

50 return 
	`__wmemcpy_chk_warn
 (
__s1
, 
__s2
, 
__n
,

51 
	`__bos0
 (
__s1
) / sizeof (
wchar_t
));

53 return 
	`__wmemcpy_alias
 (
__s1
, 
__s2
, 
__n
);

54 
	}
}

57 extern 
wchar_t
 *
	$__wmemmove_chk
 (
wchar_t
 *
__s1
, 
__const
 wchar_t *
__s2
,

58 
size_t
 
__n
, size_t 
__ns1
) 
__THROW
;

59 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wmemmove_alias
, (wchar_t *
__s1
,

60 
__const
 
wchar_t
 *
__s2
,

61 
size_t
 
__n
), 
wmemmove
);

62 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wmemmove_chk_warn
,

63 (
wchar_t
 *
__s1
, 
__const
 wchar_t *
__s2
,

64 
size_t
 
__n
, size_t 
__ns1
), 
__wmemmove_chk
)

65 
	`__warnattr
 ("wmemmove called with length bigger than size of destination "

68 
__extern_always_inline
 
wchar_t
 *

69 
	`__NTH
 (
	$wmemmove
 (
wchar_t
 *
__s1
, 
__const
 wchar_t *
__s2
, 
size_t
 
__n
))

71 if (
	`__bos0
 (
__s1
) != (
size_t
) -1)

73 if (!
	`__builtin_constant_p
 (
__n
))

74 return 
	`__wmemmove_chk
 (
__s1
, 
__s2
, 
__n
,

75 
	`__bos0
 (
__s1
) / sizeof (
wchar_t
));

77 if (
__n
 > 
	`__bos0
 (
__s1
) / sizeof (
wchar_t
))

78 return 
	`__wmemmove_chk_warn
 (
__s1
, 
__s2
, 
__n
,

79 
	`__bos0
 (
__s1
) / sizeof (
wchar_t
));

81 return 
	`__wmemmove_alias
 (
__s1
, 
__s2
, 
__n
);

82 
	}
}

85 #ifdef 
__USE_GNU


86 extern 
wchar_t
 *
	$__wmempcpy_chk
 (
wchar_t
 *
__restrict
 
__s1
,

87 
__const
 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
,

88 
size_t
 
__ns1
) 
__THROW
;

89 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wmempcpy_alias
,

90 (
wchar_t
 *
__restrict
 
__s1
,

91 
__const
 
wchar_t
 *
__restrict
 
__s2
,

92 
size_t
 
__n
), 
wmempcpy
);

93 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wmempcpy_chk_warn
,

94 (
wchar_t
 *
__restrict
 
__s1
,

95 
__const
 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
,

96 
size_t
 
__ns1
), 
__wmempcpy_chk
)

97 
	`__warnattr
 ("wmempcpy called with length bigger than size of destination "

100 
__extern_always_inline
 
wchar_t
 *

101 
	`__NTH
 (
	$wmempcpy
 (
wchar_t
 *
__restrict
 
__s1
, 
__const
 wchar_t *__restrict 
__s2
,

102 
size_t
 
__n
))

104 if (
	`__bos0
 (
__s1
) != (
size_t
) -1)

106 if (!
	`__builtin_constant_p
 (
__n
))

107 return 
	`__wmempcpy_chk
 (
__s1
, 
__s2
, 
__n
,

108 
	`__bos0
 (
__s1
) / sizeof (
wchar_t
));

110 if (
__n
 > 
	`__bos0
 (
__s1
) / sizeof (
wchar_t
))

111 return 
	`__wmempcpy_chk_warn
 (
__s1
, 
__s2
, 
__n
,

112 
	`__bos0
 (
__s1
) / sizeof (
wchar_t
));

114 return 
	`__wmempcpy_alias
 (
__s1
, 
__s2
, 
__n
);

115 
	}
}

119 extern 
wchar_t
 *
	$__wmemset_chk
 (
wchar_t
 *
__s
, wchar_t 
__c
, 
size_t
 
__n
,

120 
size_t
 
__ns
) 
__THROW
;

121 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wmemset_alias
, (wchar_t *
__s
, wchar_t 
__c
,

122 
size_t
 
__n
), 
wmemset
);

123 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wmemset_chk_warn
,

124 (
wchar_t
 *
__s
, wchar_t 
__c
, 
size_t
 
__n
,

125 
size_t
 
__ns
), 
__wmemset_chk
)

126 
	`__warnattr
 ("wmemset called with length bigger than size of destination "

129 
__extern_always_inline
 
wchar_t
 *

130 
	`__NTH
 (
	$wmemset
 (
wchar_t
 *
__s
, wchar_t 
__c
, 
size_t
 
__n
))

132 if (
	`__bos0
 (
__s
) != (
size_t
) -1)

134 if (!
	`__builtin_constant_p
 (
__n
))

135 return 
	`__wmemset_chk
 (
__s
, 
__c
, 
__n
, 
	`__bos0
 (__s) / sizeof (
wchar_t
));

137 if (
__n
 > 
	`__bos0
 (
__s
) / sizeof (
wchar_t
))

138 return 
	`__wmemset_chk_warn
 (
__s
, 
__c
, 
__n
,

139 
	`__bos0
 (
__s
) / sizeof (
wchar_t
));

141 return 
	`__wmemset_alias
 (
__s
, 
__c
, 
__n
);

142 
	}
}

145 extern 
wchar_t
 *
	$__wcscpy_chk
 (
wchar_t
 *
__restrict
 
__dest
,

146 
__const
 
wchar_t
 *
__restrict
 
__src
,

147 
size_t
 
__n
) 
__THROW
;

148 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wcscpy_alias
,

149 (
wchar_t
 *
__restrict
 
__dest
,

150 
__const
 
wchar_t
 *
__restrict
 
__src
), 
wcscpy
);

152 
__extern_always_inline
 
wchar_t
 *

153 
	`__NTH
 (
	$wcscpy
 (
wchar_t
 *
__restrict
 
__dest
, 
__const
 wchar_t *__restrict 
__src
))

155 if (
	`__bos
 (
__dest
) != (
size_t
) -1)

156 return 
	`__wcscpy_chk
 (
__dest
, 
__src
, 
	`__bos
 (__dest) / sizeof (
wchar_t
));

157 return 
	`__wcscpy_alias
 (
__dest
, 
__src
);

158 
	}
}

161 extern 
wchar_t
 *
	$__wcpcpy_chk
 (
wchar_t
 *
__restrict
 
__dest
,

162 
__const
 
wchar_t
 *
__restrict
 
__src
,

163 
size_t
 
__destlen
) 
__THROW
;

164 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wcpcpy_alias
,

165 (
wchar_t
 *
__restrict
 
__dest
,

166 
__const
 
wchar_t
 *
__restrict
 
__src
), 
wcpcpy
);

168 
__extern_always_inline
 
wchar_t
 *

169 
	`__NTH
 (
	$wcpcpy
 (
wchar_t
 *
__restrict
 
__dest
, 
__const
 wchar_t *__restrict 
__src
))

171 if (
	`__bos
 (
__dest
) != (
size_t
) -1)

172 return 
	`__wcpcpy_chk
 (
__dest
, 
__src
, 
	`__bos
 (__dest) / sizeof (
wchar_t
));

173 return 
	`__wcpcpy_alias
 (
__dest
, 
__src
);

174 
	}
}

177 extern 
wchar_t
 *
	$__wcsncpy_chk
 (
wchar_t
 *
__restrict
 
__dest
,

178 
__const
 
wchar_t
 *
__restrict
 
__src
, 
size_t
 
__n
,

179 
size_t
 
__destlen
) 
__THROW
;

180 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wcsncpy_alias
,

181 (
wchar_t
 *
__restrict
 
__dest
,

182 
__const
 
wchar_t
 *
__restrict
 
__src
,

183 
size_t
 
__n
), 
wcsncpy
);

184 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wcsncpy_chk_warn
,

185 (
wchar_t
 *
__restrict
 
__dest
,

186 
__const
 
wchar_t
 *
__restrict
 
__src
,

187 
size_t
 
__n
, size_t 
__destlen
), 
__wcsncpy_chk
)

188 
	`__warnattr
 ("wcsncpy called with length bigger than size of destination "

191 
__extern_always_inline
 
wchar_t
 *

192 
	`__NTH
 (
	$wcsncpy
 (
wchar_t
 *
__restrict
 
__dest
, 
__const
 wchar_t *__restrict 
__src
,

193 
size_t
 
__n
))

195 if (
	`__bos
 (
__dest
) != (
size_t
) -1)

197 if (!
	`__builtin_constant_p
 (
__n
))

198 return 
	`__wcsncpy_chk
 (
__dest
, 
__src
, 
__n
,

199 
	`__bos
 (
__dest
) / sizeof (
wchar_t
));

200 if (
__n
 > 
	`__bos
 (
__dest
) / sizeof (
wchar_t
))

201 return 
	`__wcsncpy_chk_warn
 (
__dest
, 
__src
, 
__n
,

202 
	`__bos
 (
__dest
) / sizeof (
wchar_t
));

204 return 
	`__wcsncpy_alias
 (
__dest
, 
__src
, 
__n
);

205 
	}
}

208 extern 
wchar_t
 *
	$__wcpncpy_chk
 (
wchar_t
 *
__restrict
 
__dest
,

209 
__const
 
wchar_t
 *
__restrict
 
__src
, 
size_t
 
__n
,

210 
size_t
 
__destlen
) 
__THROW
;

211 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wcpncpy_alias
,

212 (
wchar_t
 *
__restrict
 
__dest
,

213 
__const
 
wchar_t
 *
__restrict
 
__src
,

214 
size_t
 
__n
), 
wcpncpy
);

215 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wcpncpy_chk_warn
,

216 (
wchar_t
 *
__restrict
 
__dest
,

217 
__const
 
wchar_t
 *
__restrict
 
__src
,

218 
size_t
 
__n
, size_t 
__destlen
), 
__wcpncpy_chk
)

219 
	`__warnattr
 ("wcpncpy called with length bigger than size of destination "

222 
__extern_always_inline
 
wchar_t
 *

223 
	`__NTH
 (
	$wcpncpy
 (
wchar_t
 *
__restrict
 
__dest
, 
__const
 wchar_t *__restrict 
__src
,

224 
size_t
 
__n
))

226 if (
	`__bos
 (
__dest
) != (
size_t
) -1)

228 if (!
	`__builtin_constant_p
 (
__n
))

229 return 
	`__wcpncpy_chk
 (
__dest
, 
__src
, 
__n
,

230 
	`__bos
 (
__dest
) / sizeof (
wchar_t
));

231 if (
__n
 > 
	`__bos
 (
__dest
) / sizeof (
wchar_t
))

232 return 
	`__wcpncpy_chk_warn
 (
__dest
, 
__src
, 
__n
,

233 
	`__bos
 (
__dest
) / sizeof (
wchar_t
));

235 return 
	`__wcpncpy_alias
 (
__dest
, 
__src
, 
__n
);

236 
	}
}

239 extern 
wchar_t
 *
	$__wcscat_chk
 (
wchar_t
 *
__restrict
 
__dest
,

240 
__const
 
wchar_t
 *
__restrict
 
__src
,

241 
size_t
 
__destlen
) 
__THROW
;

242 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wcscat_alias
,

243 (
wchar_t
 *
__restrict
 
__dest
,

244 
__const
 
wchar_t
 *
__restrict
 
__src
), 
wcscat
);

246 
__extern_always_inline
 
wchar_t
 *

247 
	`__NTH
 (
	$wcscat
 (
wchar_t
 *
__restrict
 
__dest
, 
__const
 wchar_t *__restrict 
__src
))

249 if (
	`__bos
 (
__dest
) != (
size_t
) -1)

250 return 
	`__wcscat_chk
 (
__dest
, 
__src
, 
	`__bos
 (__dest) / sizeof (
wchar_t
));

251 return 
	`__wcscat_alias
 (
__dest
, 
__src
);

252 
	}
}

255 extern 
wchar_t
 *
	$__wcsncat_chk
 (
wchar_t
 *
__restrict
 
__dest
,

256 
__const
 
wchar_t
 *
__restrict
 
__src
,

257 
size_t
 
__n
, size_t 
__destlen
) 
__THROW
;

258 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wcsncat_alias
,

259 (
wchar_t
 *
__restrict
 
__dest
,

260 
__const
 
wchar_t
 *
__restrict
 
__src
,

261 
size_t
 
__n
), 
wcsncat
);

263 
__extern_always_inline
 
wchar_t
 *

264 
	`__NTH
 (
	$wcsncat
 (
wchar_t
 *
__restrict
 
__dest
, 
__const
 wchar_t *__restrict 
__src
,

265 
size_t
 
__n
))

267 if (
	`__bos
 (
__dest
) != (
size_t
) -1)

268 return 
	`__wcsncat_chk
 (
__dest
, 
__src
, 
__n
,

269 
	`__bos
 (
__dest
) / sizeof (
wchar_t
));

270 return 
	`__wcsncat_alias
 (
__dest
, 
__src
, 
__n
);

271 
	}
}

274 extern int 
	$__swprintf_chk
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

275 int 
__flag
, 
size_t
 
__s_len
,

276 
__const
 
wchar_t
 *
__restrict
 
__format
, ...)

277 
__THROW
 ;

279 extern int 
	`__REDIRECT_NTH_LDBL
 (
__swprintf_alias
,

280 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

281 
__const
 
wchar_t
 *
__restrict
 
__fmt
, ...),

282 
swprintf
);

284 #ifdef 
__va_arg_pack


285 
__extern_always_inline
 int

286 
	`__NTH
 (
	$swprintf
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

287 
__const
 
wchar_t
 *
__restrict
 
__fmt
, ...))

289 if (
	`__bos
 (
__s
) != (
size_t
) -1 || 
__USE_FORTIFY_LEVEL
 > 1)

290 return 
	`__swprintf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

291 
	`__bos
 (
__s
) / sizeof (
wchar_t
),

292 
__fmt
, 
	`__va_arg_pack
 ());

293 return 
	`__swprintf_alias
 (
__s
, 
__n
, 
__fmt
, 
	`__va_arg_pack
 ());

294 
	}
}

295 #elif !
defined
 
__cplusplus


297 #define 
	#swprintf
(
s
, 
n
, ...) \

298 (
	`__bos
 (
s
) != (
size_t
) -1 || 
__USE_FORTIFY_LEVEL
 > 1 \

299 ? 
	`__swprintf_chk
 (
s
, 
n
, 
__USE_FORTIFY_LEVEL
 - 1, \

300 
	`__bos
 (
s
) / sizeof (
wchar_t
), 
__VA_ARGS__
) \

301 : 
	`swprintf
 (
s
, 
n
, 
__VA_ARGS__
))

	)

304 extern int 
	$__vswprintf_chk
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

305 int 
__flag
, 
size_t
 
__s_len
,

306 
__const
 
wchar_t
 *
__restrict
 
__format
,

307 
__gnuc_va_list
 
__arg
)

308 
__THROW
 ;

310 extern int 
	`__REDIRECT_NTH_LDBL
 (
__vswprintf_alias
,

311 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

312 
__const
 
wchar_t
 *
__restrict
 
__fmt
,

313 
__gnuc_va_list
 
__ap
), 
vswprintf
);

315 
__extern_always_inline
 int

316 
	`__NTH
 (
	$vswprintf
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

317 
__const
 
wchar_t
 *
__restrict
 
__fmt
, 
__gnuc_va_list
 
__ap
))

319 if (
	`__bos
 (
__s
) != (
size_t
) -1 || 
__USE_FORTIFY_LEVEL
 > 1)

320 return 
	`__vswprintf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

321 
	`__bos
 (
__s
) / sizeof (
wchar_t
), 
__fmt
, 
__ap
);

322 return 
	`__vswprintf_alias
 (
__s
, 
__n
, 
__fmt
, 
__ap
);

323 
	}
}

326 #if 
__USE_FORTIFY_LEVEL
 > 1

328 extern int 
__fwprintf_chk
 (
__FILE
 *
__restrict
 
__stream
, int 
__flag
,

329 
__const
 
wchar_t
 *
__restrict
 
__format
, ...);

330 extern int 
__wprintf_chk
 (int 
__flag
, 
__const
 
wchar_t
 *
__restrict
 
__format
,

332 extern int 
__vfwprintf_chk
 (
__FILE
 *
__restrict
 
__stream
, int 
__flag
,

333 
__const
 
wchar_t
 *
__restrict
 
__format
,

334 
__gnuc_va_list
 
__ap
);

335 extern int 
__vwprintf_chk
 (int 
__flag
, 
__const
 
wchar_t
 *
__restrict
 
__format
,

336 
__gnuc_va_list
 
__ap
);

338 #ifdef 
__va_arg_pack


339 
__extern_always_inline
 int

340 
	$wprintf
 (
__const
 
wchar_t
 *
__restrict
 
__fmt
, ...)

342 return 
	`__wprintf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
	`__va_arg_pack
 ());

343 
	}
}

345 
__extern_always_inline
 int

346 
	$fwprintf
 (
__FILE
 *
__restrict
 
__stream
, 
__const
 
wchar_t
 *__restrict 
__fmt
, ...)

348 return 
	`__fwprintf_chk
 (
__stream
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

349 
	`__va_arg_pack
 ());

350 
	}
}

351 #elif !
defined
 
__cplusplus


352 #define 
	#wprintf
(...) \

353 
	`__wprintf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

354 #define 
	#fwprintf
(
stream
, ...) \

355 
	`__fwprintf_chk
 (
stream
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

358 
__extern_always_inline
 int

359 
	$vwprintf
 (
__const
 
wchar_t
 *
__restrict
 
__fmt
, 
__gnuc_va_list
 
__ap
)

361 return 
	`__vwprintf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__ap
);

362 
	}
}

364 
__extern_always_inline
 int

365 
	$vfwprintf
 (
__FILE
 *
__restrict
 
__stream
,

366 
__const
 
wchar_t
 *
__restrict
 
__fmt
, 
__gnuc_va_list
 
__ap
)

368 return 
	`__vfwprintf_chk
 (
__stream
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__ap
);

369 
	}
}

373 extern 
wchar_t
 *
	$__fgetws_chk
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__size
, int 
__n
,

374 
__FILE
 *
__restrict
 
__stream
) 
__wur
;

375 extern 
wchar_t
 *
	`__REDIRECT
 (
__fgetws_alias
,

376 (
wchar_t
 *
__restrict
 
__s
, int 
__n
,

377 
__FILE
 *
__restrict
 
__stream
), 
fgetws
) 
__wur
;

378 extern 
wchar_t
 *
	`__REDIRECT
 (
__fgetws_chk_warn
,

379 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__size
, int 
__n
,

380 
__FILE
 *
__restrict
 
__stream
), 
__fgetws_chk
)

381 
__wur
 
	`__warnattr
 ("fgetws called with bigger size than length "

384 
__extern_always_inline
 
__wur
 
wchar_t
 *

385 
	$fgetws
 (
wchar_t
 *
__restrict
 
__s
, int 
__n
, 
__FILE
 *__restrict 
__stream
)

387 if (
	`__bos
 (
__s
) != (
size_t
) -1)

389 if (!
	`__builtin_constant_p
 (
__n
) || __n <= 0)

390 return 
	`__fgetws_chk
 (
__s
, 
	`__bos
 (__s) / sizeof (
wchar_t
),

391 
__n
, 
__stream
);

393 if ((
size_t
) 
__n
 > 
	`__bos
 (
__s
) / sizeof (
wchar_t
))

394 return 
	`__fgetws_chk_warn
 (
__s
, 
	`__bos
 (__s) / sizeof (
wchar_t
),

395 
__n
, 
__stream
);

397 return 
	`__fgetws_alias
 (
__s
, 
__n
, 
__stream
);

398 
	}
}

400 #ifdef 
__USE_GNU


401 extern 
wchar_t
 *
	$__fgetws_unlocked_chk
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__size
,

402 int 
__n
, 
__FILE
 *
__restrict
 
__stream
)

403 
__wur
;

404 extern 
wchar_t
 *
	`__REDIRECT
 (
__fgetws_unlocked_alias
,

405 (
wchar_t
 *
__restrict
 
__s
, int 
__n
,

406 
__FILE
 *
__restrict
 
__stream
), 
fgetws_unlocked
)

407 
__wur
;

408 extern 
wchar_t
 *
	`__REDIRECT
 (
__fgetws_unlocked_chk_warn
,

409 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__size
, int 
__n
,

410 
__FILE
 *
__restrict
 
__stream
),

411 
__fgetws_unlocked_chk
)

412 
__wur
 
	`__warnattr
 ("fgetws_unlocked called with bigger size than length "

415 
__extern_always_inline
 
__wur
 
wchar_t
 *

416 
	$fgetws_unlocked
 (
wchar_t
 *
__restrict
 
__s
, int 
__n
, 
__FILE
 *__restrict 
__stream
)

418 if (
	`__bos
 (
__s
) != (
size_t
) -1)

420 if (!
	`__builtin_constant_p
 (
__n
) || __n <= 0)

421 return 
	`__fgetws_unlocked_chk
 (
__s
, 
	`__bos
 (__s) / sizeof (
wchar_t
),

422 
__n
, 
__stream
);

424 if ((
size_t
) 
__n
 > 
	`__bos
 (
__s
) / sizeof (
wchar_t
))

425 return 
	`__fgetws_unlocked_chk_warn
 (
__s
, 
	`__bos
 (__s) / sizeof (
wchar_t
),

426 
__n
, 
__stream
);

428 return 
	`__fgetws_unlocked_alias
 (
__s
, 
__n
, 
__stream
);

429 
	}
}

433 extern 
size_t
 
	$__wcrtomb_chk
 (char *
__restrict
 
__s
, 
wchar_t
 
__wchar
,

434 
mbstate_t
 *
__restrict
 
__p
,

435 
size_t
 
__buflen
) 
__THROW
 
__wur
;

436 extern 
size_t
 
	`__REDIRECT_NTH
 (
__wcrtomb_alias
,

437 (char *
__restrict
 
__s
, 
wchar_t
 
__wchar
,

438 
mbstate_t
 *
__restrict
 
__ps
), 
wcrtomb
) 
__wur
;

440 
__extern_always_inline
 
__wur
 
size_t


441 
	`__NTH
 (
	$wcrtomb
 (char *
__restrict
 
__s
, 
wchar_t
 
__wchar
,

442 
mbstate_t
 *
__restrict
 
__ps
))

447 #define 
	#__WCHAR_MB_LEN_MAX
 16

	)

448 #if 
defined
 
MB_LEN_MAX
 && MB_LEN_MAX != 
__WCHAR_MB_LEN_MAX


451 if (
	`__bos
 (
__s
) != (
size_t
) -1 && 
__WCHAR_MB_LEN_MAX
 > __bos (__s))

452 return 
	`__wcrtomb_chk
 (
__s
, 
__wchar
, 
__ps
, 
	`__bos
 (__s));

453 return 
	`__wcrtomb_alias
 (
__s
, 
__wchar
, 
__ps
);

454 
	}
}

457 extern 
size_t
 
	$__mbsrtowcs_chk
 (
wchar_t
 *
__restrict
 
__dst
,

458 
__const
 char **
__restrict
 
__src
,

459 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
,

460 
size_t
 
__dstlen
) 
__THROW
;

461 extern 
size_t
 
	`__REDIRECT_NTH
 (
__mbsrtowcs_alias
,

462 (
wchar_t
 *
__restrict
 
__dst
,

463 
__const
 char **
__restrict
 
__src
,

464 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
),

465 
mbsrtowcs
);

466 extern 
size_t
 
	`__REDIRECT_NTH
 (
__mbsrtowcs_chk_warn
,

467 (
wchar_t
 *
__restrict
 
__dst
,

468 
__const
 char **
__restrict
 
__src
,

469 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
,

470 
size_t
 
__dstlen
), 
__mbsrtowcs_chk
)

471 
	`__warnattr
 ("mbsrtowcs called with dst buffer smaller than len "

474 
__extern_always_inline
 
size_t


475 
	`__NTH
 (
	$mbsrtowcs
 (
wchar_t
 *
__restrict
 
__dst
, 
__const
 char **__restrict 
__src
,

476 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
))

478 if (
	`__bos
 (
__dst
) != (
size_t
) -1)

480 if (!
	`__builtin_constant_p
 (
__len
))

481 return 
	`__mbsrtowcs_chk
 (
__dst
, 
__src
, 
__len
, 
__ps
,

482 
	`__bos
 (
__dst
) / sizeof (
wchar_t
));

484 if (
__len
 > 
	`__bos
 (
__dst
) / sizeof (
wchar_t
))

485 return 
	`__mbsrtowcs_chk_warn
 (
__dst
, 
__src
, 
__len
, 
__ps
,

486 
	`__bos
 (
__dst
) / sizeof (
wchar_t
));

488 return 
	`__mbsrtowcs_alias
 (
__dst
, 
__src
, 
__len
, 
__ps
);

489 
	}
}

492 extern 
size_t
 
	$__wcsrtombs_chk
 (char *
__restrict
 
__dst
,

493 
__const
 
wchar_t
 **
__restrict
 
__src
,

494 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
,

495 
size_t
 
__dstlen
) 
__THROW
;

496 extern 
size_t
 
	`__REDIRECT_NTH
 (
__wcsrtombs_alias
,

497 (char *
__restrict
 
__dst
,

498 
__const
 
wchar_t
 **
__restrict
 
__src
,

499 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
),

500 
wcsrtombs
);

501 extern 
size_t
 
	`__REDIRECT_NTH
 (
__wcsrtombs_chk_warn
,

502 (char *
__restrict
 
__dst
,

503 
__const
 
wchar_t
 **
__restrict
 
__src
,

504 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
,

505 
size_t
 
__dstlen
), 
__wcsrtombs_chk
)

506 
	`__warnattr
 ("wcsrtombs called with dst buffer smaller than len");

508 
__extern_always_inline
 
size_t


509 
	`__NTH
 (
	$wcsrtombs
 (char *
__restrict
 
__dst
, 
__const
 
wchar_t
 **__restrict 
__src
,

510 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
))

512 if (
	`__bos
 (
__dst
) != (
size_t
) -1)

514 if (!
	`__builtin_constant_p
 (
__len
))

515 return 
	`__wcsrtombs_chk
 (
__dst
, 
__src
, 
__len
, 
__ps
, 
	`__bos
 (__dst));

517 if (
__len
 > 
	`__bos
 (
__dst
))

518 return 
	`__wcsrtombs_chk_warn
 (
__dst
, 
__src
, 
__len
, 
__ps
, 
	`__bos
 (__dst));

520 return 
	`__wcsrtombs_alias
 (
__dst
, 
__src
, 
__len
, 
__ps
);

521 
	}
}

524 #ifdef 
__USE_GNU


525 extern 
size_t
 
	$__mbsnrtowcs_chk
 (
wchar_t
 *
__restrict
 
__dst
,

526 
__const
 char **
__restrict
 
__src
, 
size_t
 
__nmc
,

527 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
,

528 
size_t
 
__dstlen
) 
__THROW
;

529 extern 
size_t
 
	`__REDIRECT_NTH
 (
__mbsnrtowcs_alias
,

530 (
wchar_t
 *
__restrict
 
__dst
,

531 
__const
 char **
__restrict
 
__src
, 
size_t
 
__nmc
,

532 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
),

533 
mbsnrtowcs
);

534 extern 
size_t
 
	`__REDIRECT_NTH
 (
__mbsnrtowcs_chk_warn
,

535 (
wchar_t
 *
__restrict
 
__dst
,

536 
__const
 char **
__restrict
 
__src
, 
size_t
 
__nmc
,

537 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
,

538 
size_t
 
__dstlen
), 
__mbsnrtowcs_chk
)

539 
	`__warnattr
 ("mbsnrtowcs called with dst buffer smaller than len "

542 
__extern_always_inline
 
size_t


543 
	`__NTH
 (
	$mbsnrtowcs
 (
wchar_t
 *
__restrict
 
__dst
, 
__const
 char **__restrict 
__src
,

544 
size_t
 
__nmc
, size_t 
__len
, 
mbstate_t
 *
__restrict
 
__ps
))

546 if (
	`__bos
 (
__dst
) != (
size_t
) -1)

548 if (!
	`__builtin_constant_p
 (
__len
))

549 return 
	`__mbsnrtowcs_chk
 (
__dst
, 
__src
, 
__nmc
, 
__len
, 
__ps
,

550 
	`__bos
 (
__dst
) / sizeof (
wchar_t
));

552 if (
__len
 > 
	`__bos
 (
__dst
) / sizeof (
wchar_t
))

553 return 
	`__mbsnrtowcs_chk_warn
 (
__dst
, 
__src
, 
__nmc
, 
__len
, 
__ps
,

554 
	`__bos
 (
__dst
) / sizeof (
wchar_t
));

556 return 
	`__mbsnrtowcs_alias
 (
__dst
, 
__src
, 
__nmc
, 
__len
, 
__ps
);

557 
	}
}

560 extern 
size_t
 
	$__wcsnrtombs_chk
 (char *
__restrict
 
__dst
,

561 
__const
 
wchar_t
 **
__restrict
 
__src
,

562 
size_t
 
__nwc
, size_t 
__len
,

563 
mbstate_t
 *
__restrict
 
__ps
, 
size_t
 
__dstlen
)

564 
__THROW
;

565 extern 
size_t
 
	`__REDIRECT_NTH
 (
__wcsnrtombs_alias
,

566 (char *
__restrict
 
__dst
,

567 
__const
 
wchar_t
 **
__restrict
 
__src
,

568 
size_t
 
__nwc
, size_t 
__len
,

569 
mbstate_t
 *
__restrict
 
__ps
), 
wcsnrtombs
);

570 extern 
size_t
 
	`__REDIRECT_NTH
 (
__wcsnrtombs_chk_warn
,

571 (char *
__restrict
 
__dst
,

572 
__const
 
wchar_t
 **
__restrict
 
__src
,

573 
size_t
 
__nwc
, size_t 
__len
,

574 
mbstate_t
 *
__restrict
 
__ps
,

575 
size_t
 
__dstlen
), 
__wcsnrtombs_chk
)

576 
	`__warnattr
 ("wcsnrtombs called with dst buffer smaller than len");

578 
__extern_always_inline
 
size_t


579 
	`__NTH
 (
	$wcsnrtombs
 (char *
__restrict
 
__dst
, 
__const
 
wchar_t
 **__restrict 
__src
,

580 
size_t
 
__nwc
, size_t 
__len
, 
mbstate_t
 *
__restrict
 
__ps
))

582 if (
	`__bos
 (
__dst
) != (
size_t
) -1)

584 if (!
	`__builtin_constant_p
 (
__len
))

585 return 
	`__wcsnrtombs_chk
 (
__dst
, 
__src
, 
__nwc
, 
__len
, 
__ps
,

586 
	`__bos
 (
__dst
));

588 if (
__len
 > 
	`__bos
 (
__dst
))

589 return 
	`__wcsnrtombs_chk_warn
 (
__dst
, 
__src
, 
__nwc
, 
__len
, 
__ps
,

590 
	`__bos
 (
__dst
));

592 return 
	`__wcsnrtombs_alias
 (
__dst
, 
__src
, 
__nwc
, 
__len
, 
__ps
);

593 
	}
}

	@/usr/include/pthread.h

20 #ifndef 
_PTHREAD_H


21 #define 
	#_PTHREAD_H
 1

	)

23 #include 
	~<features.h
>

24 #include 
	~<endian.h
>

25 #include 
	~<sched.h
>

26 #include 
	~<time.h
>

28 #include 
	~<bits/pthreadtypes.h
>

29 #include 
	~<bits/setjmp.h
>

30 #include 
	~<bits/wordsize.h
>

36 
	mPTHREAD_CREATE_JOINABLE
,

37 #define 
	#PTHREAD_CREATE_JOINABLE
 
PTHREAD_CREATE_JOINABLE


	)

38 
	mPTHREAD_CREATE_DETACHED


39 #define 
	#PTHREAD_CREATE_DETACHED
 
PTHREAD_CREATE_DETACHED


	)

46 
	mPTHREAD_MUTEX_TIMED_NP
,

47 
	mPTHREAD_MUTEX_RECURSIVE_NP
,

48 
	mPTHREAD_MUTEX_ERRORCHECK_NP
,

49 
	mPTHREAD_MUTEX_ADAPTIVE_NP


50 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K8


52 
	mPTHREAD_MUTEX_NORMAL
 = 
PTHREAD_MUTEX_TIMED_NP
,

53 
	mPTHREAD_MUTEX_RECURSIVE
 = 
PTHREAD_MUTEX_RECURSIVE_NP
,

54 
	mPTHREAD_MUTEX_ERRORCHECK
 = 
PTHREAD_MUTEX_ERRORCHECK_NP
,

55 
	mPTHREAD_MUTEX_DEFAULT
 = 
PTHREAD_MUTEX_NORMAL


57 #ifdef 
__USE_GNU


59 , 
	mPTHREAD_MUTEX_FAST_NP
 = 
PTHREAD_MUTEX_TIMED_NP


64 #ifdef 
__USE_XOPEN2K


68 
	mPTHREAD_MUTEX_STALLED
,

69 
	mPTHREAD_MUTEX_STALLED_NP
 = 
PTHREAD_MUTEX_STALLED
,

70 
	mPTHREAD_MUTEX_ROBUST
,

71 
	mPTHREAD_MUTEX_ROBUST_NP
 = 
PTHREAD_MUTEX_ROBUST


76 #ifdef 
__USE_UNIX98


80 
	mPTHREAD_PRIO_NONE
,

81 
	mPTHREAD_PRIO_INHERIT
,

82 
	mPTHREAD_PRIO_PROTECT


88 #if 
__WORDSIZE
 == 64

89 #define 
	#PTHREAD_MUTEX_INITIALIZER
 \

90 { { 0, 0, 0, 0, 0, 0, { 0, 0 } } }

	)

91 #ifdef 
__USE_GNU


92 #define 
	#PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
 \

93 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_RECURSIVE_NP
, 0, { 0, 0 } } }

	)

94 #define 
	#PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
 \

95 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_ERRORCHECK_NP
, 0, { 0, 0 } } }

	)

96 #define 
	#PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 \

97 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_ADAPTIVE_NP
, 0, { 0, 0 } } }

	)

100 #define 
	#PTHREAD_MUTEX_INITIALIZER
 \

101 { { 0, 0, 0, 0, 0, { 0 } } }

	)

102 #ifdef 
__USE_GNU


103 #define 
	#PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
 \

104 { { 0, 0, 0, 
PTHREAD_MUTEX_RECURSIVE_NP
, 0, { 0 } } }

	)

105 #define 
	#PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
 \

106 { { 0, 0, 0, 
PTHREAD_MUTEX_ERRORCHECK_NP
, 0, { 0 } } }

	)

107 #define 
	#PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 \

108 { { 0, 0, 0, 
PTHREAD_MUTEX_ADAPTIVE_NP
, 0, { 0 } } }

	)

114 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K


117 
	mPTHREAD_RWLOCK_PREFER_READER_NP
,

118 
	mPTHREAD_RWLOCK_PREFER_WRITER_NP
,

119 
	mPTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
,

120 
	mPTHREAD_RWLOCK_DEFAULT_NP
 = 
PTHREAD_RWLOCK_PREFER_READER_NP


124 #define 
	#PTHREAD_RWLOCK_INITIALIZER
 \

125 { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }

	)

126 #ifdef 
__USE_GNU


127 #if 
__WORDSIZE
 == 64

128 #define 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

130 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
 } }

	)

132 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


133 #define 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

134 { { 0, 0, 0, 0, 0, 0, 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
, \

135 0, 0, 0, 0 } }

	)

137 #define 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

138 { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
,\

139 0 } }

	)

149 
	mPTHREAD_INHERIT_SCHED
,

150 #define 
	#PTHREAD_INHERIT_SCHED
 
PTHREAD_INHERIT_SCHED


	)

151 
	mPTHREAD_EXPLICIT_SCHED


152 #define 
	#PTHREAD_EXPLICIT_SCHED
 
PTHREAD_EXPLICIT_SCHED


	)

159 
	mPTHREAD_SCOPE_SYSTEM
,

160 #define 
	#PTHREAD_SCOPE_SYSTEM
 
PTHREAD_SCOPE_SYSTEM


	)

161 
	mPTHREAD_SCOPE_PROCESS


162 #define 
	#PTHREAD_SCOPE_PROCESS
 
PTHREAD_SCOPE_PROCESS


	)

169 
	mPTHREAD_PROCESS_PRIVATE
,

170 #define 
	#PTHREAD_PROCESS_PRIVATE
 
PTHREAD_PROCESS_PRIVATE


	)

171 
	mPTHREAD_PROCESS_SHARED


172 #define 
	#PTHREAD_PROCESS_SHARED
 
PTHREAD_PROCESS_SHARED


	)

178 #define 
	#PTHREAD_COND_INITIALIZER
 { { 0, 0, 0, 0, 0, (void *) 0, 0, 0 } }

	)

182 struct 
	s_pthread_cleanup_buffer


184 void (*
	m__routine
) (void *);

185 void *
	m__arg
;

186 int 
	m__canceltype
;

187 struct 
_pthread_cleanup_buffer
 *
	m__prev
;

193 
	mPTHREAD_CANCEL_ENABLE
,

194 #define 
	#PTHREAD_CANCEL_ENABLE
 
PTHREAD_CANCEL_ENABLE


	)

195 
	mPTHREAD_CANCEL_DISABLE


196 #define 
	#PTHREAD_CANCEL_DISABLE
 
PTHREAD_CANCEL_DISABLE


	)

200 
	mPTHREAD_CANCEL_DEFERRED
,

201 #define 
	#PTHREAD_CANCEL_DEFERRED
 
PTHREAD_CANCEL_DEFERRED


	)

202 
	mPTHREAD_CANCEL_ASYNCHRONOUS


203 #define 
	#PTHREAD_CANCEL_ASYNCHRONOUS
 
PTHREAD_CANCEL_ASYNCHRONOUS


	)

205 #define 
	#PTHREAD_CANCELED
 ((void *) -1)

	)

209 #define 
	#PTHREAD_ONCE_INIT
 0

	)

212 #ifdef 
__USE_XOPEN2K


216 #define 
	#PTHREAD_BARRIER_SERIAL_THREAD
 -1

	)

220 
__BEGIN_DECLS


225 extern int 
pthread_create
 (
pthread_t
 *
__restrict
 
__newthread
,

226 
__const
 
pthread_attr_t
 *
__restrict
 
__attr
,

227 void *(*
__start_routine
) (void *),

228 void *
__restrict
 
__arg
) 
__THROW
 
__nonnull
 ((1, 3));

234 extern void 
	$pthread_exit
 (void *
__retval
) 
	`__attribute__
 ((
__noreturn__
));

242 extern int 
	`pthread_join
 (
pthread_t
 
__th
, void **
__thread_return
);

244 #ifdef 
__USE_GNU


247 extern int 
	$pthread_tryjoin_np
 (
pthread_t
 
__th
, void **
__thread_return
) 
__THROW
;

255 extern int 
	`pthread_timedjoin_np
 (
pthread_t
 
__th
, void **
__thread_return
,

256 
__const
 struct 
timespec
 *
__abstime
);

263 extern int 
	$pthread_detach
 (
pthread_t
 
__th
) 
__THROW
;

267 extern 
pthread_t
 
	$pthread_self
 (void) 
__THROW
 
	`__attribute__
 ((
__const__
));

270 extern int 
	$pthread_equal
 (
pthread_t
 
__thread1
, pthread_t 
__thread2
) 
__THROW
;

278 extern int 
	$pthread_attr_init
 (
pthread_attr_t
 *
__attr
) 
__THROW
 
	`__nonnull
 ((1));

281 extern int 
	$pthread_attr_destroy
 (
pthread_attr_t
 *
__attr
)

282 
__THROW
 
	`__nonnull
 ((1));

285 extern int 
	$pthread_attr_getdetachstate
 (
__const
 
pthread_attr_t
 *
__attr
,

286 int *
__detachstate
)

287 
__THROW
 
	`__nonnull
 ((1, 2));

290 extern int 
	$pthread_attr_setdetachstate
 (
pthread_attr_t
 *
__attr
,

291 int 
__detachstate
)

292 
__THROW
 
	`__nonnull
 ((1));

296 extern int 
	$pthread_attr_getguardsize
 (
__const
 
pthread_attr_t
 *
__attr
,

297 
size_t
 *
__guardsize
)

298 
__THROW
 
	`__nonnull
 ((1, 2));

301 extern int 
	$pthread_attr_setguardsize
 (
pthread_attr_t
 *
__attr
,

302 
size_t
 
__guardsize
)

303 
__THROW
 
	`__nonnull
 ((1));

307 extern int 
	$pthread_attr_getschedparam
 (
__const
 
pthread_attr_t
 *
__restrict


308 
__attr
,

309 struct 
sched_param
 *
__restrict
 
__param
)

310 
__THROW
 
	`__nonnull
 ((1, 2));

313 extern int 
	$pthread_attr_setschedparam
 (
pthread_attr_t
 *
__restrict
 
__attr
,

314 
__const
 struct 
sched_param
 *
__restrict


315 
__param
) 
__THROW
 
	`__nonnull
 ((1, 2));

318 extern int 
	$pthread_attr_getschedpolicy
 (
__const
 
pthread_attr_t
 *
__restrict


319 
__attr
, int *
__restrict
 
__policy
)

320 
__THROW
 
	`__nonnull
 ((1, 2));

323 extern int 
	$pthread_attr_setschedpolicy
 (
pthread_attr_t
 *
__attr
, int 
__policy
)

324 
__THROW
 
	`__nonnull
 ((1));

327 extern int 
	$pthread_attr_getinheritsched
 (
__const
 
pthread_attr_t
 *
__restrict


328 
__attr
, int *
__restrict
 
__inherit
)

329 
__THROW
 
	`__nonnull
 ((1, 2));

332 extern int 
	$pthread_attr_setinheritsched
 (
pthread_attr_t
 *
__attr
,

333 int 
__inherit
)

334 
__THROW
 
	`__nonnull
 ((1));

338 extern int 
	$pthread_attr_getscope
 (
__const
 
pthread_attr_t
 *
__restrict
 
__attr
,

339 int *
__restrict
 
__scope
)

340 
__THROW
 
	`__nonnull
 ((1, 2));

343 extern int 
	$pthread_attr_setscope
 (
pthread_attr_t
 *
__attr
, int 
__scope
)

344 
__THROW
 
	`__nonnull
 ((1));

347 extern int 
	$pthread_attr_getstackaddr
 (
__const
 
pthread_attr_t
 *
__restrict


348 
__attr
, void **
__restrict
 
__stackaddr
)

349 
__THROW
 
	`__nonnull
 ((1, 2)) 
__attribute_deprecated__
;

355 extern int 
	$pthread_attr_setstackaddr
 (
pthread_attr_t
 *
__attr
,

356 void *
__stackaddr
)

357 
__THROW
 
	`__nonnull
 ((1)) 
__attribute_deprecated__
;

360 extern int 
	$pthread_attr_getstacksize
 (
__const
 
pthread_attr_t
 *
__restrict


361 
__attr
, 
size_t
 *
__restrict
 
__stacksize
)

362 
__THROW
 
	`__nonnull
 ((1, 2));

367 extern int 
	$pthread_attr_setstacksize
 (
pthread_attr_t
 *
__attr
,

368 
size_t
 
__stacksize
)

369 
__THROW
 
	`__nonnull
 ((1));

371 #ifdef 
__USE_XOPEN2K


373 extern int 
	$pthread_attr_getstack
 (
__const
 
pthread_attr_t
 *
__restrict
 
__attr
,

374 void **
__restrict
 
__stackaddr
,

375 
size_t
 *
__restrict
 
__stacksize
)

376 
__THROW
 
	`__nonnull
 ((1, 2, 3));

381 extern int 
	$pthread_attr_setstack
 (
pthread_attr_t
 *
__attr
, void *
__stackaddr
,

382 
size_t
 
__stacksize
) 
__THROW
 
	`__nonnull
 ((1));

385 #ifdef 
__USE_GNU


388 extern int 
	$pthread_attr_setaffinity_np
 (
pthread_attr_t
 *
__attr
,

389 
size_t
 
__cpusetsize
,

390 
__const
 
cpu_set_t
 *
__cpuset
)

391 
__THROW
 
	`__nonnull
 ((1, 3));

395 extern int 
	$pthread_attr_getaffinity_np
 (
__const
 
pthread_attr_t
 *
__attr
,

396 
size_t
 
__cpusetsize
,

397 
cpu_set_t
 *
__cpuset
)

398 
__THROW
 
	`__nonnull
 ((1, 3));

404 extern int 
	$pthread_getattr_np
 (
pthread_t
 
__th
, 
pthread_attr_t
 *
__attr
)

405 
__THROW
 
	`__nonnull
 ((2));

413 extern int 
	$pthread_setschedparam
 (
pthread_t
 
__target_thread
, int 
__policy
,

414 
__const
 struct 
sched_param
 *
__param
)

415 
__THROW
 
	`__nonnull
 ((3));

418 extern int 
	$pthread_getschedparam
 (
pthread_t
 
__target_thread
,

419 int *
__restrict
 
__policy
,

420 struct 
sched_param
 *
__restrict
 
__param
)

421 
__THROW
 
	`__nonnull
 ((2, 3));

424 extern int 
	$pthread_setschedprio
 (
pthread_t
 
__target_thread
, int 
__prio
)

425 
__THROW
;

428 #ifdef 
__USE_GNU


430 extern int 
	$pthread_getname_np
 (
pthread_t
 
__target_thread
, char *
__buf
,

431 
size_t
 
__buflen
)

432 
__THROW
 
	`__nonnull
 ((2));

435 extern int 
	$pthread_setname_np
 (
pthread_t
 
__target_thread
, 
__const
 char *
__name
)

436 
__THROW
 
	`__nonnull
 ((2));

440 #ifdef 
__USE_UNIX98


442 extern int 
	$pthread_getconcurrency
 (void) 
__THROW
;

445 extern int 
	$pthread_setconcurrency
 (int 
__level
) 
__THROW
;

448 #ifdef 
__USE_GNU


453 extern int 
	$pthread_yield
 (void) 
__THROW
;

458 extern int 
	$pthread_setaffinity_np
 (
pthread_t
 
__th
, 
size_t
 
__cpusetsize
,

459 
__const
 
cpu_set_t
 *
__cpuset
)

460 
__THROW
 
	`__nonnull
 ((3));

463 extern int 
	$pthread_getaffinity_np
 (
pthread_t
 
__th
, 
size_t
 
__cpusetsize
,

464 
cpu_set_t
 *
__cpuset
)

465 
__THROW
 
	`__nonnull
 ((3));

478 extern int 
	`pthread_once
 (
pthread_once_t
 *
__once_control
,

479 void (*
__init_routine
) (void)) 
	`__nonnull
 ((1, 2));

490 extern int 
	`pthread_setcancelstate
 (int 
__state
, int *
__oldstate
);

494 extern int 
	`pthread_setcanceltype
 (int 
__type
, int *
__oldtype
);

497 extern int 
	`pthread_cancel
 (
pthread_t
 
__th
);

502 extern void 
	`pthread_testcancel
 (void);

511 
__jmp_buf
 
__cancel_jmp_buf
;

512 int 
__mask_was_saved
;

513 } 
__cancel_jmp_buf
[1];

514 void *
__pad
[4];

515 } 
	t__pthread_unwind_buf_t
 
	t__attribute__
 ((
	t__aligned__
));

518 #ifndef 
__cleanup_fct_attribute


519 #define 
	#__cleanup_fct_attribute


	)

524 struct 
	s__pthread_cleanup_frame


526 void (*
__cancel_routine
) (void *);

527 void *
__cancel_arg
;

528 int 
__do_it
;

529 int 
__cancel_type
;

532 #if 
defined
 
__GNUC__
 && defined 
__EXCEPTIONS


533 #ifdef 
__cplusplus


535 class 
	c__pthread_cleanup_class


537 void (*
__cancel_routine
) (void *);

538 void *
__cancel_arg
;

539 int 
__do_it
;

540 int 
__cancel_type
;

542 
public
:

543 
	`__pthread_cleanup_class
 (void (*
__fct
) (void *), void *
__arg
)

544 : 
	`__cancel_routine
 (
__fct
), 
	`__cancel_arg
 (
__arg
), 
	$__do_it
 (1) { }

545 ~
	$__pthread_cleanup_class
 () { if (
__do_it
) 
	`__cancel_routine
 (
__cancel_arg
); 
	}
}

546 void 
	$__setdoit
 (int 
__newval
) { 
__do_it
 = __newval; 
	}
}

547 void 
	$__defer
 () { 
	`pthread_setcanceltype
 (
PTHREAD_CANCEL_DEFERRED
,

548 &
__cancel_type
); 
	}
}

549 void 
	$__restore
 () const { 
	`pthread_setcanceltype
 (
__cancel_type
, 0); 
	}
}

559 #define 
	#pthread_cleanup_push
(
routine
, 
arg
) \

561 
__pthread_cleanup_class
 
	`__clframe
 (
routine
, 
arg
)

	)

565 #define 
	#pthread_cleanup_pop
(
execute
) \

566 
__clframe
.
	`__setdoit
 (
execute
); \

567 } while (0)

	)

569 #ifdef 
__USE_GNU


573 #define 
	#pthread_cleanup_push_defer_np
(
routine
, 
arg
) \

575 
__pthread_cleanup_class
 
	`__clframe
 (
routine
, 
arg
); \

576 
__clframe
.
	`__defer
 ()

	)

581 #define 
	#pthread_cleanup_pop_restore_np
(
execute
) \

582 
__clframe
.
	`__restore
 (); \

583 
__clframe
.
	`__setdoit
 (
execute
); \

584 } while (0)

	)

591 
__extern_inline
 void

592 
	$__pthread_cleanup_routine
 (struct 
__pthread_cleanup_frame
 *
__frame
)

594 if (
__frame
->
__do_it
)

595 
__frame
->
	`__cancel_routine
 (__frame->
__cancel_arg
);

596 
	}
}

605 #define 
	#pthread_cleanup_push
(
routine
, 
arg
) \

607 struct 
__pthread_cleanup_frame
 
__clframe
 \

608 
	`__attribute__
 ((
	`__cleanup__
 (
__pthread_cleanup_routine
))) \

609 = { .
__cancel_routine
 = (
routine
), .
__cancel_arg
 = (
arg
), \

610 .
__do_it
 = 1 };

	)

614 #define 
	#pthread_cleanup_pop
(
execute
) \

615 
__clframe
.
__do_it
 = (
execute
); \

616 } while (0)

	)

618 #ifdef 
__USE_GNU


622 #define 
	#pthread_cleanup_push_defer_np
(
routine
, 
arg
) \

624 struct 
__pthread_cleanup_frame
 
__clframe
 \

625 
	`__attribute__
 ((
	`__cleanup__
 (
__pthread_cleanup_routine
))) \

626 = { .
__cancel_routine
 = (
routine
), .
__cancel_arg
 = (
arg
), \

627 .
__do_it
 = 1 }; \

628 (void) 
	`pthread_setcanceltype
 (
PTHREAD_CANCEL_DEFERRED
, \

629 &
__clframe
.
__cancel_type
)

	)

634 #define 
	#pthread_cleanup_pop_restore_np
(
execute
) \

635 (void) 
	`pthread_setcanceltype
 (
__clframe
.
__cancel_type
, 
NULL
); \

636 
__clframe
.
__do_it
 = (
execute
); \

637 } while (0)

	)

648 #define 
	#pthread_cleanup_push
(
routine
, 
arg
) \

650 
__pthread_unwind_buf_t
 
__cancel_buf
; \

651 void (*
__cancel_routine
) (void *) = (
routine
); \

652 void *
__cancel_arg
 = (
arg
); \

653 int 
not_first_call
 = 
	`__sigsetjmp
 ((struct 
__jmp_buf_tag
 *) (void *) \

654 
__cancel_buf
.
__cancel_jmp_buf
, 0); \

655 if (
	`__builtin_expect
 (
not_first_call
, 0)) \

657 
	`__cancel_routine
 (
__cancel_arg
); \

658 
	`__pthread_unwind_next
 (&
__cancel_buf
); \

662 
	`__pthread_register_cancel
 (&
__cancel_buf
); \

663 do {

	)

664 extern void 
__pthread_register_cancel
 (
__pthread_unwind_buf_t
 *
__buf
)

665 
__cleanup_fct_attribute
;

669 #define 
	#pthread_cleanup_pop
(
execute
) \

672 
	`__pthread_unregister_cancel
 (&
__cancel_buf
); \

673 if (
execute
) \

674 
	`__cancel_routine
 (
__cancel_arg
); \

675 } while (0)

	)

676 extern void 
	$__pthread_unregister_cancel
 (
__pthread_unwind_buf_t
 *
__buf
)

677 
__cleanup_fct_attribute
;

679 #ifdef 
__USE_GNU


683 #define 
	#pthread_cleanup_push_defer_np
(
routine
, 
arg
) \

685 
__pthread_unwind_buf_t
 
__cancel_buf
; \

686 void (*
__cancel_routine
) (void *) = (
routine
); \

687 void *
__cancel_arg
 = (
arg
); \

688 int 
not_first_call
 = 
	`__sigsetjmp
 ((struct 
__jmp_buf_tag
 *) (void *) \

689 
__cancel_buf
.
__cancel_jmp_buf
, 0); \

690 if (
	`__builtin_expect
 (
not_first_call
, 0)) \

692 
	`__cancel_routine
 (
__cancel_arg
); \

693 
	`__pthread_unwind_next
 (&
__cancel_buf
); \

697 
	`__pthread_register_cancel_defer
 (&
__cancel_buf
); \

698 do {

	)

699 extern void 
	`__pthread_register_cancel_defer
 (
__pthread_unwind_buf_t
 *
__buf
)

700 
__cleanup_fct_attribute
;

705 #define 
	#pthread_cleanup_pop_restore_np
(
execute
) \

708 
	`__pthread_unregister_cancel_restore
 (&
__cancel_buf
); \

709 if (
execute
) \

710 
	`__cancel_routine
 (
__cancel_arg
); \

711 
	}
} while (0)

	)

712 extern void 
	$__pthread_unregister_cancel_restore
 (
__pthread_unwind_buf_t
 *
__buf
)

713 
__cleanup_fct_attribute
;

717 extern void 
	$__pthread_unwind_next
 (
__pthread_unwind_buf_t
 *
__buf
)

718 
__cleanup_fct_attribute
 
	`__attribute__
 ((
__noreturn__
))

719 #ifndef 
SHARED


720 
	`__attribute__
 ((
__weak__
))

726 struct 
__jmp_buf_tag
;

727 extern int 
	$__sigsetjmp
 (struct 
__jmp_buf_tag
 *
__env
, int 
__savemask
) 
__THROW
;

733 extern int 
	$pthread_mutex_init
 (
pthread_mutex_t
 *
__mutex
,

734 
__const
 
pthread_mutexattr_t
 *
__mutexattr
)

735 
__THROW
 
	`__nonnull
 ((1));

738 extern int 
	$pthread_mutex_destroy
 (
pthread_mutex_t
 *
__mutex
)

739 
__THROW
 
	`__nonnull
 ((1));

742 extern int 
	$pthread_mutex_trylock
 (
pthread_mutex_t
 *
__mutex
)

743 
__THROW
 
	`__nonnull
 ((1));

746 extern int 
	$pthread_mutex_lock
 (
pthread_mutex_t
 *
__mutex
)

747 
__THROW
 
	`__nonnull
 ((1));

749 #ifdef 
__USE_XOPEN2K


751 extern int 
	$pthread_mutex_timedlock
 (
pthread_mutex_t
 *
__restrict
 
__mutex
,

752 
__const
 struct 
timespec
 *
__restrict


753 
__abstime
) 
__THROW
 
	`__nonnull
 ((1, 2));

757 extern int 
	$pthread_mutex_unlock
 (
pthread_mutex_t
 *
__mutex
)

758 
__THROW
 
	`__nonnull
 ((1));

762 extern int 
	$pthread_mutex_getprioceiling
 (
__const
 
pthread_mutex_t
 *

763 
__restrict
 
__mutex
,

764 int *
__restrict
 
__prioceiling
)

765 
__THROW
 
	`__nonnull
 ((1, 2));

769 extern int 
	$pthread_mutex_setprioceiling
 (
pthread_mutex_t
 *
__restrict
 
__mutex
,

770 int 
__prioceiling
,

771 int *
__restrict
 
__old_ceiling
)

772 
__THROW
 
	`__nonnull
 ((1, 3));

775 #ifdef 
__USE_XOPEN2K8


777 extern int 
	$pthread_mutex_consistent
 (
pthread_mutex_t
 *
__mutex
)

778 
__THROW
 
	`__nonnull
 ((1));

779 #ifdef 
__USE_GNU


780 extern int 
	$pthread_mutex_consistent_np
 (
pthread_mutex_t
 *
__mutex
)

781 
__THROW
 
	`__nonnull
 ((1));

790 extern int 
	$pthread_mutexattr_init
 (
pthread_mutexattr_t
 *
__attr
)

791 
__THROW
 
	`__nonnull
 ((1));

794 extern int 
	$pthread_mutexattr_destroy
 (
pthread_mutexattr_t
 *
__attr
)

795 
__THROW
 
	`__nonnull
 ((1));

798 extern int 
	$pthread_mutexattr_getpshared
 (
__const
 
pthread_mutexattr_t
 *

799 
__restrict
 
__attr
,

800 int *
__restrict
 
__pshared
)

801 
__THROW
 
	`__nonnull
 ((1, 2));

804 extern int 
	$pthread_mutexattr_setpshared
 (
pthread_mutexattr_t
 *
__attr
,

805 int 
__pshared
)

806 
__THROW
 
	`__nonnull
 ((1));

808 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K8


810 extern int 
	$pthread_mutexattr_gettype
 (
__const
 
pthread_mutexattr_t
 *
__restrict


811 
__attr
, int *
__restrict
 
__kind
)

812 
__THROW
 
	`__nonnull
 ((1, 2));

817 extern int 
	$pthread_mutexattr_settype
 (
pthread_mutexattr_t
 *
__attr
, int 
__kind
)

818 
__THROW
 
	`__nonnull
 ((1));

822 extern int 
	$pthread_mutexattr_getprotocol
 (
__const
 
pthread_mutexattr_t
 *

823 
__restrict
 
__attr
,

824 int *
__restrict
 
__protocol
)

825 
__THROW
 
	`__nonnull
 ((1, 2));

829 extern int 
	$pthread_mutexattr_setprotocol
 (
pthread_mutexattr_t
 *
__attr
,

830 int 
__protocol
)

831 
__THROW
 
	`__nonnull
 ((1));

834 extern int 
	$pthread_mutexattr_getprioceiling
 (
__const
 
pthread_mutexattr_t
 *

835 
__restrict
 
__attr
,

836 int *
__restrict
 
__prioceiling
)

837 
__THROW
 
	`__nonnull
 ((1, 2));

840 extern int 
	$pthread_mutexattr_setprioceiling
 (
pthread_mutexattr_t
 *
__attr
,

841 int 
__prioceiling
)

842 
__THROW
 
	`__nonnull
 ((1));

844 #ifdef 
__USE_XOPEN2K


846 extern int 
	$pthread_mutexattr_getrobust
 (
__const
 
pthread_mutexattr_t
 *
__attr
,

847 int *
__robustness
)

848 
__THROW
 
	`__nonnull
 ((1, 2));

849 #ifdef 
__USE_GNU


850 extern int 
	$pthread_mutexattr_getrobust_np
 (
__const
 
pthread_mutexattr_t
 *
__attr
,

851 int *
__robustness
)

852 
__THROW
 
	`__nonnull
 ((1, 2));

856 extern int 
	$pthread_mutexattr_setrobust
 (
pthread_mutexattr_t
 *
__attr
,

857 int 
__robustness
)

858 
__THROW
 
	`__nonnull
 ((1));

859 #ifdef 
__USE_GNU


860 extern int 
	$pthread_mutexattr_setrobust_np
 (
pthread_mutexattr_t
 *
__attr
,

861 int 
__robustness
)

862 
__THROW
 
	`__nonnull
 ((1));

867 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K


872 extern int 
	$pthread_rwlock_init
 (
pthread_rwlock_t
 *
__restrict
 
__rwlock
,

873 
__const
 
pthread_rwlockattr_t
 *
__restrict


874 
__attr
) 
__THROW
 
	`__nonnull
 ((1));

877 extern int 
	$pthread_rwlock_destroy
 (
pthread_rwlock_t
 *
__rwlock
)

878 
__THROW
 
	`__nonnull
 ((1));

881 extern int 
	$pthread_rwlock_rdlock
 (
pthread_rwlock_t
 *
__rwlock
)

882 
__THROW
 
	`__nonnull
 ((1));

885 extern int 
	$pthread_rwlock_tryrdlock
 (
pthread_rwlock_t
 *
__rwlock
)

886 
__THROW
 
	`__nonnull
 ((1));

888 #ifdef 
__USE_XOPEN2K


890 extern int 
	$pthread_rwlock_timedrdlock
 (
pthread_rwlock_t
 *
__restrict
 
__rwlock
,

891 
__const
 struct 
timespec
 *
__restrict


892 
__abstime
) 
__THROW
 
	`__nonnull
 ((1, 2));

896 extern int 
	$pthread_rwlock_wrlock
 (
pthread_rwlock_t
 *
__rwlock
)

897 
__THROW
 
	`__nonnull
 ((1));

900 extern int 
	$pthread_rwlock_trywrlock
 (
pthread_rwlock_t
 *
__rwlock
)

901 
__THROW
 
	`__nonnull
 ((1));

903 #ifdef 
__USE_XOPEN2K


905 extern int 
	$pthread_rwlock_timedwrlock
 (
pthread_rwlock_t
 *
__restrict
 
__rwlock
,

906 
__const
 struct 
timespec
 *
__restrict


907 
__abstime
) 
__THROW
 
	`__nonnull
 ((1, 2));

911 extern int 
	$pthread_rwlock_unlock
 (
pthread_rwlock_t
 *
__rwlock
)

912 
__THROW
 
	`__nonnull
 ((1));

918 extern int 
	$pthread_rwlockattr_init
 (
pthread_rwlockattr_t
 *
__attr
)

919 
__THROW
 
	`__nonnull
 ((1));

922 extern int 
	$pthread_rwlockattr_destroy
 (
pthread_rwlockattr_t
 *
__attr
)

923 
__THROW
 
	`__nonnull
 ((1));

926 extern int 
	$pthread_rwlockattr_getpshared
 (
__const
 
pthread_rwlockattr_t
 *

927 
__restrict
 
__attr
,

928 int *
__restrict
 
__pshared
)

929 
__THROW
 
	`__nonnull
 ((1, 2));

932 extern int 
	$pthread_rwlockattr_setpshared
 (
pthread_rwlockattr_t
 *
__attr
,

933 int 
__pshared
)

934 
__THROW
 
	`__nonnull
 ((1));

937 extern int 
	$pthread_rwlockattr_getkind_np
 (
__const
 
pthread_rwlockattr_t
 *

938 
__restrict
 
__attr
,

939 int *
__restrict
 
__pref
)

940 
__THROW
 
	`__nonnull
 ((1, 2));

943 extern int 
	$pthread_rwlockattr_setkind_np
 (
pthread_rwlockattr_t
 *
__attr
,

944 int 
__pref
) 
__THROW
 
	`__nonnull
 ((1));

952 extern int 
	$pthread_cond_init
 (
pthread_cond_t
 *
__restrict
 
__cond
,

953 
__const
 
pthread_condattr_t
 *
__restrict


954 
__cond_attr
) 
__THROW
 
	`__nonnull
 ((1));

957 extern int 
	$pthread_cond_destroy
 (
pthread_cond_t
 *
__cond
)

958 
__THROW
 
	`__nonnull
 ((1));

961 extern int 
	$pthread_cond_signal
 (
pthread_cond_t
 *
__cond
)

962 
__THROW
 
	`__nonnull
 ((1));

965 extern int 
	$pthread_cond_broadcast
 (
pthread_cond_t
 *
__cond
)

966 
__THROW
 
	`__nonnull
 ((1));

973 extern int 
	$pthread_cond_wait
 (
pthread_cond_t
 *
__restrict
 
__cond
,

974 
pthread_mutex_t
 *
__restrict
 
__mutex
)

975 
	`__nonnull
 ((1, 2));

984 extern int 
	$pthread_cond_timedwait
 (
pthread_cond_t
 *
__restrict
 
__cond
,

985 
pthread_mutex_t
 *
__restrict
 
__mutex
,

986 
__const
 struct 
timespec
 *
__restrict


987 
__abstime
) 
	`__nonnull
 ((1, 2, 3));

992 extern int 
	$pthread_condattr_init
 (
pthread_condattr_t
 *
__attr
)

993 
__THROW
 
	`__nonnull
 ((1));

996 extern int 
	$pthread_condattr_destroy
 (
pthread_condattr_t
 *
__attr
)

997 
__THROW
 
	`__nonnull
 ((1));

1000 extern int 
	$pthread_condattr_getpshared
 (
__const
 
pthread_condattr_t
 *

1001 
__restrict
 
__attr
,

1002 int *
__restrict
 
__pshared
)

1003 
__THROW
 
	`__nonnull
 ((1, 2));

1006 extern int 
	$pthread_condattr_setpshared
 (
pthread_condattr_t
 *
__attr
,

1007 int 
__pshared
) 
__THROW
 
	`__nonnull
 ((1));

1009 #ifdef 
__USE_XOPEN2K


1011 extern int 
	$pthread_condattr_getclock
 (
__const
 
pthread_condattr_t
 *

1012 
__restrict
 
__attr
,

1013 
__clockid_t
 *
__restrict
 
__clock_id
)

1014 
__THROW
 
	`__nonnull
 ((1, 2));

1017 extern int 
	$pthread_condattr_setclock
 (
pthread_condattr_t
 *
__attr
,

1018 
__clockid_t
 
__clock_id
)

1019 
__THROW
 
	`__nonnull
 ((1));

1023 #ifdef 
__USE_XOPEN2K


1028 extern int 
	$pthread_spin_init
 (
pthread_spinlock_t
 *
__lock
, int 
__pshared
)

1029 
__THROW
 
	`__nonnull
 ((1));

1032 extern int 
	$pthread_spin_destroy
 (
pthread_spinlock_t
 *
__lock
)

1033 
__THROW
 
	`__nonnull
 ((1));

1036 extern int 
	$pthread_spin_lock
 (
pthread_spinlock_t
 *
__lock
)

1037 
__THROW
 
	`__nonnull
 ((1));

1040 extern int 
	$pthread_spin_trylock
 (
pthread_spinlock_t
 *
__lock
)

1041 
__THROW
 
	`__nonnull
 ((1));

1044 extern int 
	$pthread_spin_unlock
 (
pthread_spinlock_t
 *
__lock
)

1045 
__THROW
 
	`__nonnull
 ((1));

1052 extern int 
	$pthread_barrier_init
 (
pthread_barrier_t
 *
__restrict
 
__barrier
,

1053 
__const
 
pthread_barrierattr_t
 *
__restrict


1054 
__attr
, unsigned int 
__count
)

1055 
__THROW
 
	`__nonnull
 ((1));

1058 extern int 
	$pthread_barrier_destroy
 (
pthread_barrier_t
 *
__barrier
)

1059 
__THROW
 
	`__nonnull
 ((1));

1062 extern int 
	$pthread_barrier_wait
 (
pthread_barrier_t
 *
__barrier
)

1063 
__THROW
 
	`__nonnull
 ((1));

1067 extern int 
	$pthread_barrierattr_init
 (
pthread_barrierattr_t
 *
__attr
)

1068 
__THROW
 
	`__nonnull
 ((1));

1071 extern int 
	$pthread_barrierattr_destroy
 (
pthread_barrierattr_t
 *
__attr
)

1072 
__THROW
 
	`__nonnull
 ((1));

1075 extern int 
	$pthread_barrierattr_getpshared
 (
__const
 
pthread_barrierattr_t
 *

1076 
__restrict
 
__attr
,

1077 int *
__restrict
 
__pshared
)

1078 
__THROW
 
	`__nonnull
 ((1, 2));

1081 extern int 
	$pthread_barrierattr_setpshared
 (
pthread_barrierattr_t
 *
__attr
,

1082 int 
__pshared
)

1083 
__THROW
 
	`__nonnull
 ((1));

1095 extern int 
	`pthread_key_create
 (
pthread_key_t
 *
__key
,

1096 void (*
__destr_function
) (void *))

1097 
__THROW
 
	`__nonnull
 ((1));

1100 extern int 
	$pthread_key_delete
 (
pthread_key_t
 
__key
) 
__THROW
;

1103 extern void *
	$pthread_getspecific
 (
pthread_key_t
 
__key
) 
__THROW
;

1106 extern int 
	$pthread_setspecific
 (
pthread_key_t
 
__key
,

1107 
__const
 void *
__pointer
) 
__THROW
 ;

1110 #ifdef 
__USE_XOPEN2K


1112 extern int 
	$pthread_getcpuclockid
 (
pthread_t
 
__thread_id
,

1113 
__clockid_t
 *
__clock_id
)

1114 
__THROW
 
	`__nonnull
 ((2));

1129 extern int 
	`pthread_atfork
 (void (*
__prepare
) (void),

1130 void (*
__parent
) (void),

1131 void (*
__child
) (void)) 
__THROW
;

1134 #ifdef 
__USE_EXTERN_INLINES


1136 
__extern_inline
 int

1137 
	`__NTH
 (
	$pthread_equal
 (
pthread_t
 
__thread1
, pthread_t 
__thread2
))

1139 return 
__thread1
 == 
__thread2
;

1140 
	}
}

1143 
	g__END_DECLS


	@/usr/include/wctype.h

24 #ifndef 
_WCTYPE_H


26 #include 
	~<features.h
>

27 #include 
	~<bits/types.h
>

29 #ifndef 
__need_iswxxx


30 #define 
	#_WCTYPE_H
 1

	)

33 #define 
	#__need_wint_t


	)

34 #include 
	~<wchar.h
>

38 #ifndef 
WEOF


39 #define 
	#WEOF
 (0xffffffffu)

	)

42 #undef 
__need_iswxxx


47 #ifndef 
__iswxxx_defined


48 #define 
	#__iswxxx_defined
 1

	)

50 
__BEGIN_NAMESPACE_C99


53 typedef unsigned long int 
	twctype_t
;

54 
	g__END_NAMESPACE_C99


56 #ifndef 
_ISwbit


61 #include 
	~<endian.h
>

62 #if 
__BYTE_ORDER
 == 
__BIG_ENDIAN


63 #define 
	#_ISwbit
(
bit
) (1 << (bit))

	)

65 #define 
	#_ISwbit
(
bit
) \

66 ((
bit
) < 8 ? (int) ((1UL << (bit)) << 24) \

67 : ((
bit
) < 16 ? (int) ((1UL << (bit)) << 8) \

68 : ((
bit
) < 24 ? (int) ((1UL << (bit)) >> 8) \

69 : (int) ((1UL << (
bit
)) >> 24))))

	)

74 
	m__ISwupper
 = 0,

75 
	m__ISwlower
 = 1,

76 
	m__ISwalpha
 = 2,

77 
	m__ISwdigit
 = 3,

78 
	m__ISwxdigit
 = 4,

79 
	m__ISwspace
 = 5,

80 
	m__ISwprint
 = 6,

81 
	m__ISwgraph
 = 7,

82 
	m__ISwblank
 = 8,

83 
	m__ISwcntrl
 = 9,

84 
	m__ISwpunct
 = 10,

85 
	m__ISwalnum
 = 11,

87 
	m_ISwupper
 = 
_ISwbit
 (
__ISwupper
),

88 
	m_ISwlower
 = 
_ISwbit
 (
__ISwlower
),

89 
	m_ISwalpha
 = 
_ISwbit
 (
__ISwalpha
),

90 
	m_ISwdigit
 = 
_ISwbit
 (
__ISwdigit
),

91 
	m_ISwxdigit
 = 
_ISwbit
 (
__ISwxdigit
),

92 
	m_ISwspace
 = 
_ISwbit
 (
__ISwspace
),

93 
	m_ISwprint
 = 
_ISwbit
 (
__ISwprint
),

94 
	m_ISwgraph
 = 
_ISwbit
 (
__ISwgraph
),

95 
	m_ISwblank
 = 
_ISwbit
 (
__ISwblank
),

96 
	m_ISwcntrl
 = 
_ISwbit
 (
__ISwcntrl
),

97 
	m_ISwpunct
 = 
_ISwbit
 (
__ISwpunct
),

98 
	m_ISwalnum
 = 
_ISwbit
 (
__ISwalnum
)

103 
__BEGIN_DECLS


105 
__BEGIN_NAMESPACE_C99


112 extern int 
	$iswalnum
 (
wint_t
 
__wc
) 
__THROW
;

118 extern int 
	$iswalpha
 (
wint_t
 
__wc
) 
__THROW
;

121 extern int 
	$iswcntrl
 (
wint_t
 
__wc
) 
__THROW
;

125 extern int 
	$iswdigit
 (
wint_t
 
__wc
) 
__THROW
;

129 extern int 
	$iswgraph
 (
wint_t
 
__wc
) 
__THROW
;

134 extern int 
	$iswlower
 (
wint_t
 
__wc
) 
__THROW
;

137 extern int 
	$iswprint
 (
wint_t
 
__wc
) 
__THROW
;

142 extern int 
	$iswpunct
 (
wint_t
 
__wc
) 
__THROW
;

147 extern int 
	$iswspace
 (
wint_t
 
__wc
) 
__THROW
;

152 extern int 
	$iswupper
 (
wint_t
 
__wc
) 
__THROW
;

157 extern int 
	$iswxdigit
 (
wint_t
 
__wc
) 
__THROW
;

162 #ifdef 
__USE_ISOC99


163 extern int 
	$iswblank
 (
wint_t
 
__wc
) 
__THROW
;

172 extern 
wctype_t
 
	$wctype
 (
__const
 char *
__property
) 
__THROW
;

176 extern int 
	$iswctype
 (
wint_t
 
__wc
, 
wctype_t
 
__desc
) 
__THROW
;

177 
__END_NAMESPACE_C99


184 
__BEGIN_NAMESPACE_C99


187 typedef 
__const
 
	t__int32_t
 *
	twctrans_t
;

188 
__END_NAMESPACE_C99


189 #ifdef 
__USE_GNU


190 
	$__USING_NAMESPACE_C99
(
wctrans_t
)

193 
__BEGIN_NAMESPACE_C99


195 extern 
wint_t
 
	$towlower
 (
wint_t
 
__wc
) 
__THROW
;

198 extern 
wint_t
 
	$towupper
 (
wint_t
 
__wc
) 
__THROW
;

199 
__END_NAMESPACE_C99


201 
__END_DECLS


208 #ifdef 
_WCTYPE_H


214 
__BEGIN_DECLS


216 
__BEGIN_NAMESPACE_C99


219 extern 
wctrans_t
 
	$wctrans
 (
__const
 char *
__property
) 
__THROW
;

222 extern 
wint_t
 
	$towctrans
 (
wint_t
 
__wc
, 
wctrans_t
 
__desc
) 
__THROW
;

223 
__END_NAMESPACE_C99


225 #ifdef 
__USE_XOPEN2K8


227 #include 
	~<xlocale.h
>

231 extern int 
	$iswalnum_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

237 extern int 
	$iswalpha_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

240 extern int 
	$iswcntrl_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

244 extern int 
	$iswdigit_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

248 extern int 
	$iswgraph_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

253 extern int 
	$iswlower_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

256 extern int 
	$iswprint_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

261 extern int 
	$iswpunct_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

266 extern int 
	$iswspace_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

271 extern int 
	$iswupper_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

276 extern int 
	$iswxdigit_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

281 extern int 
	$iswblank_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

285 extern 
wctype_t
 
	$wctype_l
 (
__const
 char *
__property
, 
__locale_t
 
__locale
)

286 
__THROW
;

290 extern int 
	$iswctype_l
 (
wint_t
 
__wc
, 
wctype_t
 
__desc
, 
__locale_t
 
__locale
)

291 
__THROW
;

299 extern 
wint_t
 
	$towlower_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

302 extern 
wint_t
 
	$towupper_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

306 extern 
wctrans_t
 
	$wctrans_l
 (
__const
 char *
__property
, 
__locale_t
 
__locale
)

307 
__THROW
;

310 extern 
wint_t
 
	$towctrans_l
 (
wint_t
 
__wc
, 
wctrans_t
 
__desc
,

311 
__locale_t
 
__locale
) 
__THROW
;

315 
__END_DECLS


	@/usr/include/asm-generic/errno-base.h

1 #ifndef 
_ASM_GENERIC_ERRNO_BASE_H


2 #define 
	#_ASM_GENERIC_ERRNO_BASE_H


	)

4 #define 
	#EPERM
 1

	)

5 #define 
	#ENOENT
 2

	)

6 #define 
	#ESRCH
 3

	)

7 #define 
	#EINTR
 4

	)

8 #define 
	#EIO
 5

	)

9 #define 
	#ENXIO
 6

	)

10 #define 
	#E2BIG
 7

	)

11 #define 
	#ENOEXEC
 8

	)

12 #define 
	#EBADF
 9

	)

13 #define 
	#ECHILD
 10

	)

14 #define 
	#EAGAIN
 11

	)

15 #define 
	#ENOMEM
 12

	)

16 #define 
	#EACCES
 13

	)

17 #define 
	#EFAULT
 14

	)

18 #define 
	#ENOTBLK
 15

	)

19 #define 
	#EBUSY
 16

	)

20 #define 
	#EEXIST
 17

	)

21 #define 
	#EXDEV
 18

	)

22 #define 
	#ENODEV
 19

	)

23 #define 
	#ENOTDIR
 20

	)

24 #define 
	#EISDIR
 21

	)

25 #define 
	#EINVAL
 22

	)

26 #define 
	#ENFILE
 23

	)

27 #define 
	#EMFILE
 24

	)

28 #define 
	#ENOTTY
 25

	)

29 #define 
	#ETXTBSY
 26

	)

30 #define 
	#EFBIG
 27

	)

31 #define 
	#ENOSPC
 28

	)

32 #define 
	#ESPIPE
 29

	)

33 #define 
	#EROFS
 30

	)

34 #define 
	#EMLINK
 31

	)

35 #define 
	#EPIPE
 32

	)

36 #define 
	#EDOM
 33

	)

37 #define 
	#ERANGE
 34

	)

	@/usr/include/bits/setjmp.h

20 #ifndef 
_BITS_SETJMP_H


21 #define 
	#_BITS_SETJMP_H
 1

	)

23 #if !
defined
 
_SETJMP_H
 && !defined 
_PTHREAD_H


27 #include 
	~<bits/wordsize.h
>

29 #ifndef 
_ASM


31 #if 
__WORDSIZE
 == 64

32 typedef long int 
	t__jmp_buf
[8];

34 typedef int 
	t__jmp_buf
[6];

	@/usr/include/sched.h

21 #ifndef 
_SCHED_H


22 #define 
	#_SCHED_H
 1

	)

24 #include 
	~<features.h
>

27 #include 
	~<bits/types.h
>

29 #define 
	#__need_size_t


	)

30 #include 
	~<stddef.h
>

32 #define 
	#__need_time_t


	)

33 #define 
	#__need_timespec


	)

34 #include 
	~<time.h
>

36 #ifndef 
__pid_t_defined


37 typedef 
__pid_t
 
	tpid_t
;

38 #define 
	#__pid_t_defined


	)

43 #include 
	~<bits/sched.h
>

45 #define 
	#sched_priority
 
__sched_priority


	)

48 
__BEGIN_DECLS


51 extern int 
	$sched_setparam
 (
__pid_t
 
__pid
, 
__const
 struct 
sched_param
 *
__param
)

52 
__THROW
;

55 extern int 
	$sched_getparam
 (
__pid_t
 
__pid
, struct 
sched_param
 *
__param
) 
__THROW
;

58 extern int 
	$sched_setscheduler
 (
__pid_t
 
__pid
, int 
__policy
,

59 
__const
 struct 
sched_param
 *
__param
) 
__THROW
;

62 extern int 
	$sched_getscheduler
 (
__pid_t
 
__pid
) 
__THROW
;

65 extern int 
	$sched_yield
 (void) 
__THROW
;

68 extern int 
	$sched_get_priority_max
 (int 
__algorithm
) 
__THROW
;

71 extern int 
	$sched_get_priority_min
 (int 
__algorithm
) 
__THROW
;

74 extern int 
	$sched_rr_get_interval
 (
__pid_t
 
__pid
, struct 
timespec
 *
__t
) 
__THROW
;

77 #ifdef 
__USE_GNU


79 #define 
	#CPU_SETSIZE
 
__CPU_SETSIZE


	)

80 #define 
	#CPU_SET
(
cpu
, 
cpusetp
) 
	`__CPU_SET_S
 (cpu, sizeof (
cpu_set_t
), cpusetp)

	)

81 #define 
	#CPU_CLR
(
cpu
, 
cpusetp
) 
	`__CPU_CLR_S
 (cpu, sizeof (
cpu_set_t
), cpusetp)

	)

82 #define 
	#CPU_ISSET
(
cpu
, 
cpusetp
) 
	`__CPU_ISSET_S
 (cpu, sizeof (
cpu_set_t
), \

83 
cpusetp
)

	)

84 #define 
	#CPU_ZERO
(
cpusetp
) 
	`__CPU_ZERO_S
 (sizeof (
cpu_set_t
), cpusetp)

	)

85 #define 
	#CPU_COUNT
(
cpusetp
) 
	`__CPU_COUNT_S
 (sizeof (
cpu_set_t
), cpusetp)

	)

87 #define 
	#CPU_SET_S
(
cpu
, 
setsize
, 
cpusetp
) 
	`__CPU_SET_S
 (cpu, setsize, cpusetp)

	)

88 #define 
	#CPU_CLR_S
(
cpu
, 
setsize
, 
cpusetp
) 
	`__CPU_CLR_S
 (cpu, setsize, cpusetp)

	)

89 #define 
	#CPU_ISSET_S
(
cpu
, 
setsize
, 
cpusetp
) 
	`__CPU_ISSET_S
 (cpu, setsize, \

90 
cpusetp
)

	)

91 #define 
	#CPU_ZERO_S
(
setsize
, 
cpusetp
) 
	`__CPU_ZERO_S
 (setsize, cpusetp)

	)

92 #define 
	#CPU_COUNT_S
(
setsize
, 
cpusetp
) 
	`__CPU_COUNT_S
 (setsize, cpusetp)

	)

94 #define 
	#CPU_EQUAL
(
cpusetp1
, 
cpusetp2
) \

95 
	`__CPU_EQUAL_S
 (sizeof (
cpu_set_t
), 
cpusetp1
, 
cpusetp2
)

	)

96 #define 
	#CPU_EQUAL_S
(
setsize
, 
cpusetp1
, 
cpusetp2
) \

97 
	`__CPU_EQUAL_S
 (
setsize
, 
cpusetp1
, 
cpusetp2
)

	)

99 #define 
	#CPU_AND
(
destset
, 
srcset1
, 
srcset2
) \

100 
	`__CPU_OP_S
 (sizeof (
cpu_set_t
), 
destset
, 
srcset1
, 
srcset2
, &)

	)

101 #define 
	#CPU_OR
(
destset
, 
srcset1
, 
srcset2
) \

102 
	`__CPU_OP_S
 (sizeof (
cpu_set_t
), 
destset
, 
srcset1
, 
srcset2
, |)

	)

103 #define 
	#CPU_XOR
(
destset
, 
srcset1
, 
srcset2
) \

104 
	`__CPU_OP_S
 (sizeof (
cpu_set_t
), 
destset
, 
srcset1
, 
srcset2
, ^)

	)

105 #define 
	#CPU_AND_S
(
setsize
, 
destset
, 
srcset1
, 
srcset2
) \

106 
	`__CPU_OP_S
 (
setsize
, 
destset
, 
srcset1
, 
srcset2
, &)

	)

107 #define 
	#CPU_OR_S
(
setsize
, 
destset
, 
srcset1
, 
srcset2
) \

108 
	`__CPU_OP_S
 (
setsize
, 
destset
, 
srcset1
, 
srcset2
, |)

	)

109 #define 
	#CPU_XOR_S
(
setsize
, 
destset
, 
srcset1
, 
srcset2
) \

110 
	`__CPU_OP_S
 (
setsize
, 
destset
, 
srcset1
, 
srcset2
, ^)

	)

112 #define 
	#CPU_ALLOC_SIZE
(
count
) 
	`__CPU_ALLOC_SIZE
 (count)

	)

113 #define 
	#CPU_ALLOC
(
count
) 
	`__CPU_ALLOC
 (count)

	)

114 #define 
	#CPU_FREE
(
cpuset
) 
	`__CPU_FREE
 (cpuset)

	)

118 extern int 
	$sched_setaffinity
 (
__pid_t
 
__pid
, 
size_t
 
__cpusetsize
,

119 
__const
 
cpu_set_t
 *
__cpuset
) 
__THROW
;

122 extern int 
	$sched_getaffinity
 (
__pid_t
 
__pid
, 
size_t
 
__cpusetsize
,

123 
cpu_set_t
 *
__cpuset
) 
__THROW
;

126 
__END_DECLS


	@/usr/include/bits/sched.h

22 #ifndef 
__need_schedparam


24 #ifndef 
_SCHED_H


30 #define 
	#SCHED_OTHER
 0

	)

31 #define 
	#SCHED_FIFO
 1

	)

32 #define 
	#SCHED_RR
 2

	)

33 #ifdef 
__USE_GNU


34 #define 
	#SCHED_BATCH
 3

	)

35 #define 
	#SCHED_IDLE
 5

	)

37 #define 
	#SCHED_RESET_ON_FORK
 0x40000000

	)

40 #ifdef 
__USE_MISC


42 #define 
	#CSIGNAL
 0x000000ff

	)

43 #define 
	#CLONE_VM
 0x00000100

	)

44 #define 
	#CLONE_FS
 0x00000200

	)

45 #define 
	#CLONE_FILES
 0x00000400

	)

46 #define 
	#CLONE_SIGHAND
 0x00000800

	)

47 #define 
	#CLONE_PTRACE
 0x00002000

	)

48 #define 
	#CLONE_VFORK
 0x00004000

	)

50 #define 
	#CLONE_PARENT
 0x00008000

	)

52 #define 
	#CLONE_THREAD
 0x00010000

	)

53 #define 
	#CLONE_NEWNS
 0x00020000

	)

54 #define 
	#CLONE_SYSVSEM
 0x00040000

	)

55 #define 
	#CLONE_SETTLS
 0x00080000

	)

56 #define 
	#CLONE_PARENT_SETTID
 0x00100000

	)

58 #define 
	#CLONE_CHILD_CLEARTID
 0x00200000

	)

60 #define 
	#CLONE_DETACHED
 0x00400000

	)

61 #define 
	#CLONE_UNTRACED
 0x00800000

	)

63 #define 
	#CLONE_CHILD_SETTID
 0x01000000

	)

65 #define 
	#CLONE_NEWUTS
 0x04000000

	)

66 #define 
	#CLONE_NEWIPC
 0x08000000

	)

67 #define 
	#CLONE_NEWUSER
 0x10000000

	)

68 #define 
	#CLONE_NEWPID
 0x20000000

	)

69 #define 
	#CLONE_NEWNET
 0x40000000

	)

70 #define 
	#CLONE_IO
 0x80000000

	)

74 struct 
	ssched_param


76 int 
	m__sched_priority
;

79 
	g__BEGIN_DECLS


81 #ifdef 
__USE_MISC


83 extern int 
clone
 (int (*
__fn
) (void *
__arg
), void *
__child_stack
,

84 int 
__flags
, void *
__arg
, ...) 
__THROW
;

87 extern int 
	$unshare
 (int 
__flags
) 
__THROW
;

90 extern int 
	$sched_getcpu
 (void) 
__THROW
;

93 
__END_DECLS


97 #if !
defined
 
__defined_schedparam
 \

98 && (
defined
 
__need_schedparam
 || defined 
_SCHED_H
)

99 #define 
	#__defined_schedparam
 1

	)

101 struct 
	s__sched_param


103 int 
__sched_priority
;

105 #undef 
__need_schedparam


109 #if 
defined
 
_SCHED_H
 && !defined 
__cpu_set_t_defined


110 #define 
	#__cpu_set_t_defined


	)

112 #define 
	#__CPU_SETSIZE
 1024

	)

113 #define 
	#__NCPUBITS
 (8 * sizeof (
__cpu_mask
))

	)

116 typedef unsigned long int 
	t__cpu_mask
;

119 #define 
	#__CPUELT
(
cpu
) ((cpu) / 
__NCPUBITS
)

	)

120 #define 
	#__CPUMASK
(
cpu
) ((
__cpu_mask
) 1 << ((cpu) % 
__NCPUBITS
))

	)

125 
__cpu_mask
 
__bits
[
__CPU_SETSIZE
 / 
__NCPUBITS
];

126 } 
	tcpu_set_t
;

129 #if 
	`__GNUC_PREREQ
 (2, 91)

130 #define 
	#__CPU_ZERO_S
(
setsize
, 
cpusetp
) \

131 do 
	`__builtin_memset
 (
cpusetp
, '\0', 
setsize
); while (0)

	)

133 #define 
	#__CPU_ZERO_S
(
setsize
, 
cpusetp
) \

135 
size_t
 
__i
; \

136 
size_t
 
__imax
 = (
setsize
) / sizeof (
__cpu_mask
); \

137 
__cpu_mask
 *
__bits
 = (
cpusetp
)->__bits; \

138 for (
__i
 = 0; __i < 
__imax
; ++__i) \

139 
__bits
[
__i
] = 0; \

140 
	}
} while (0)

	)

142 #define 
	#__CPU_SET_S
(
cpu
, 
setsize
, 
cpusetp
) \

143 (
__extension__
 \

144 ({ 
size_t
 
__cpu
 = (
cpu
); \

145 
__cpu
 < 8 * (
setsize
) \

146 ? (((
__cpu_mask
 *) ((
cpusetp
)->
__bits
))[
	`__CPUELT
 (
__cpu
)] \

147 |= 
	`__CPUMASK
 (
__cpu
)) \

148 : 0; }))

	)

149 #define 
	#__CPU_CLR_S
(
cpu
, 
setsize
, 
cpusetp
) \

150 (
__extension__
 \

151 ({ 
size_t
 
__cpu
 = (
cpu
); \

152 
__cpu
 < 8 * (
setsize
) \

153 ? (((
__cpu_mask
 *) ((
cpusetp
)->
__bits
))[
	`__CPUELT
 (
__cpu
)] \

154 &= ~
	`__CPUMASK
 (
__cpu
)) \

155 : 0; }))

	)

156 #define 
	#__CPU_ISSET_S
(
cpu
, 
setsize
, 
cpusetp
) \

157 (
__extension__
 \

158 ({ 
size_t
 
__cpu
 = (
cpu
); \

159 
__cpu
 < 8 * (
setsize
) \

160 ? ((((
__const
 
__cpu_mask
 *) ((
cpusetp
)->
__bits
))[
	`__CPUELT
 (
__cpu
)] \

161 & 
	`__CPUMASK
 (
__cpu
))) != 0 \

162 : 0; }))

	)

164 #define 
	#__CPU_COUNT_S
(
setsize
, 
cpusetp
) \

165 
	`__sched_cpucount
 (
setsize
, 
cpusetp
)

	)

167 #if 
__GNUC_PREREQ
 (2, 91)

168 #define 
	#__CPU_EQUAL_S
(
setsize
, 
cpusetp1
, 
cpusetp2
) \

169 (
	`__builtin_memcmp
 (
cpusetp1
, 
cpusetp2
, 
setsize
) == 0)

	)

171 #define 
	#__CPU_EQUAL_S
(
setsize
, 
cpusetp1
, 
cpusetp2
) \

172 (
__extension__
 \

173 ({ 
__const
 
__cpu_mask
 *
__arr1
 = (
cpusetp1
)->
__bits
; \

174 
__const
 
__cpu_mask
 *
__arr2
 = (
cpusetp2
)->
__bits
; \

175 
size_t
 
__imax
 = (
setsize
) / sizeof (
__cpu_mask
); \

176 
size_t
 
__i
; \

177 for (
__i
 = 0; __i < 
__imax
; ++__i) \

178 if (
__bits
[
__i
] != __bits[__i]) \

180 
__i
 == 
__imax
; }))

	)

183 #define 
	#__CPU_OP_S
(
setsize
, 
destset
, 
srcset1
, 
srcset2
, 
op
) \

184 (
__extension__
 \

185 ({ 
cpu_set_t
 *
__dest
 = (
destset
); \

186 
__const
 
__cpu_mask
 *
__arr1
 = (
srcset1
)->
__bits
; \

187 
__const
 
__cpu_mask
 *
__arr2
 = (
srcset2
)->
__bits
; \

188 
size_t
 
__imax
 = (
setsize
) / sizeof (
__cpu_mask
); \

189 
size_t
 
__i
; \

190 for (
__i
 = 0; __i < 
__imax
; ++__i) \

191 ((
__cpu_mask
 *) 
__dest
->
__bits
)[
__i
] = 
__arr1
[__i] 
op
 
__arr2
[__i]; \

192 
__dest
; }))

	)

194 #define 
	#__CPU_ALLOC_SIZE
(
count
) \

195 ((((
count
) + 
__NCPUBITS
 - 1) / __NCPUBITS) * sizeof (
__cpu_mask
))

	)

196 #define 
	#__CPU_ALLOC
(
count
) 
	`__sched_cpualloc
 (count)

	)

197 #define 
	#__CPU_FREE
(
cpuset
) 
	`__sched_cpufree
 (cpuset)

	)

199 
__BEGIN_DECLS


201 extern int 
	$__sched_cpucount
 (
size_t
 
__setsize
, const 
cpu_set_t
 *
__setp
)

202 
__THROW
;

203 extern 
cpu_set_t
 *
	$__sched_cpualloc
 (
size_t
 
__count
) 
__THROW
 
__wur
;

204 extern void 
	$__sched_cpufree
 (
cpu_set_t
 *
__set
) 
__THROW
;

206 
__END_DECLS


	@
1
.
1
/usr/include
160
3517
include/compcol_double.h
include/comprow_double.h
include/coord_double.h
include/diagpre_double.h
include/icpre_double.h
include/ilupre_double.h
include/iohb.h
include/iohb_double.h
include/iotext.h
include/iotext_double.h
include/iotext_type.h
include/minstr.h
include/qsort_double.h
include/qsort_int.h
include/qsort_type.h
include/spblas.h
include/tblas1.h
include/tmvec.h
include/tmvmat.h
mv/include/iotext.h
mv/include/mvblas.h
mv/include/mvblasc.h
mv/include/mvblasd.h
mv/include/mvblasf.h
mv/include/mvblasi.h
mv/include/mvblast.h
mv/include/mvm.h
mv/include/mvmc.h
mv/include/mvmd.h
mv/include/mvmf.h
mv/include/mvmi.h
mv/include/mvmrf.h
mv/include/mvmt.h
mv/include/mvmtp.h
mv/include/mvv.h
mv/include/mvvc.h
mv/include/mvvd.h
mv/include/mvvf.h
mv/include/mvvi.h
mv/include/mvvind.h
mv/include/mvvrf.h
mv/include/mvvt.h
mv/include/mvvtp.h
mv/include/tblas1.h
mv/include/tmvmat.h
mv/include/vecdefs.h
mv/src/mvblasc.cc
mv/src/mvblasd.cc
mv/src/mvblasf.cc
mv/src/mvblasi.cc
mv/src/mvblast.cc
mv/src/mvmc.cc
mv/src/mvmd.cc
mv/src/mvmf.cc
mv/src/mvmi.cc
mv/src/mvmt.cc
mv/src/mvvc.cc
mv/src/mvvcio.cc
mv/src/mvvd.cc
mv/src/mvvdio.cc
mv/src/mvvf.cc
mv/src/mvvi.cc
mv/src/mvvt.cc
spblas/spmm.cc
spblas/spsm.cc
src/compcol_double.cc
src/comprow_double.cc
src/coord_double.cc
src/diagpre.cc
src/diagpre_double.cc
src/icpre.cc
src/icpre_double.cc
src/ilupre.cc
src/ilupre_1.5.cc
src/ilupre_double.cc
src/ilupre_double_1.5.cc
src/iohb.c
src/iohb_double.cc
src/iotext.c
src/iotext.cc
src/iotext_double.cc
src/qsort_double.cc
src/qsort_int.cc
src/qsort_type.cc
testing/td.cc
testing/tpre.cc
testing/tsl.cc
testing/tsp.cc
testing/tspsm.cc
/usr/include/alloca.h
/usr/include/assert.h
/usr/include/complex.h
/usr/include/errno.h
/usr/include/math.h
/usr/include/stdio.h
/usr/include/stdlib.h
/usr/include/string.h
/usr/include/bits/cmathcalls.h
/usr/include/bits/errno.h
/usr/include/bits/huge_val.h
/usr/include/bits/huge_valf.h
/usr/include/bits/huge_vall.h
/usr/include/bits/inf.h
/usr/include/bits/mathcalls.h
/usr/include/bits/mathdef.h
/usr/include/bits/mathinline.h
/usr/include/bits/nan.h
/usr/include/bits/stdio-ldbl.h
/usr/include/bits/stdio.h
/usr/include/bits/stdio2.h
/usr/include/bits/stdio_lim.h
/usr/include/bits/stdlib-ldbl.h
/usr/include/bits/stdlib.h
/usr/include/bits/string.h
/usr/include/bits/string2.h
/usr/include/bits/string3.h
/usr/include/bits/sys_errlist.h
/usr/include/bits/types.h
/usr/include/bits/waitflags.h
/usr/include/bits/waitstatus.h
/usr/include/features.h
/usr/include/getopt.h
/usr/include/libio.h
/usr/include/sys/types.h
/usr/include/xlocale.h
/usr/include/_G_config.h
/usr/include/bits/libio-ldbl.h
/usr/include/bits/pthreadtypes.h
/usr/include/bits/stdio-lock.h
/usr/include/bits/typesizes.h
/usr/include/bits/wordsize.h
/usr/include/ctype.h
/usr/include/endian.h
/usr/include/gnu/stubs.h
/usr/include/linux/errno.h
/usr/include/sys/cdefs.h
/usr/include/sys/select.h
/usr/include/sys/sysmacros.h
/usr/include/time.h
/usr/include/asm/errno.h
/usr/include/bits/byteswap.h
/usr/include/bits/endian.h
/usr/include/bits/libc-lock.h
/usr/include/bits/select.h
/usr/include/bits/sigset.h
/usr/include/bits/time.h
/usr/include/gconv.h
/usr/include/gnu/stubs-32.h
/usr/include/gnu/stubs-64.h
/usr/include/wchar.h
/usr/include/asm-generic/errno.h
/usr/include/bits/wchar-ldbl.h
/usr/include/bits/wchar.h
/usr/include/bits/wchar2.h
/usr/include/pthread.h
/usr/include/wctype.h
/usr/include/asm-generic/errno-base.h
/usr/include/bits/setjmp.h
/usr/include/sched.h
/usr/include/bits/sched.h
